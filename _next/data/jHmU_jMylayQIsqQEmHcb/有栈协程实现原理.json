{"pageProps":{"site":{"domain":"yangsoon.github.io","name":"YangSoon","rootNotionPageId":"72a669717cf642c2a2524439d99d8f44","rootNotionSpaceId":null,"description":"YangSoon, Cloud Native Developer"},"recordMap":{"block":{"091a74ac-4142-4f28-ba1d-5c9810ccc648":{"role":"reader","value":{"id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","version":100,"type":"page","properties":{"title":[["有栈协程实现原理",[["b"]]]]},"content":["fa1c3357-8d66-49c7-b61e-4d3d69346323","053a4920-5603-423b-9ade-546274c449e8","57c53cca-ff1b-40e9-bb07-727965277060","1b3e9d75-0f62-4510-9d37-cff48a0ef8b1","0bf3a3ce-ce50-468a-a7b4-7572bc7f1950","eaa93a3a-20d5-4bc8-8b06-16af7753d5df","c4b4cc20-8808-4229-b76e-b2c220ea8819","80e01be4-edc7-42ac-88dc-d44c0022b938","78c54cf6-c4c3-45e5-a965-841a0c9215bd","582af19c-4877-4609-b669-dea8e1fe3466","674b8f34-799a-486a-9368-a3c70263d731","b44648ac-613f-4eae-877c-ff22c079e520","ac6a02ff-a1a9-4a4d-b210-3f40fd667c84","7d7ba4e8-77a1-42ac-ac74-ecaeb6ba6c99","47b81bd6-877c-4a0c-b71e-414cb56d1665","f2e65cac-3449-4d0f-bb72-f1aa748b9ddb","12cfdaf2-14e0-4720-8af4-32f69336d87d","010204f7-4312-449e-8d7b-2c647fa7aca2","098d17c4-973d-4986-a38b-9bc724c172ef","dff2befb-112a-460c-9ed3-df3e39f50182","177caef2-deb2-4f19-ad1b-b7f5a8bcf401","c0225528-1c15-4ded-a5d6-1d7434d2916f","09acbf6c-f422-4723-bbeb-4e4e916b7170","780e6eca-b041-4bf2-bfb4-d115c10097e2","91243b24-4801-4c77-9e9c-e5d05b98d66a","ba511ef4-cd74-4973-9aa9-af7ee9d2483c","01bc0475-504f-48d1-b921-a2cd8ca652f2","7d97a16b-9fcc-435d-9fb4-8e6453129f37","edfe5570-b469-48ac-bace-e9ffe3650f54","9471b13e-899c-4902-a3ee-7c43b5b1bb4a","5ab357ce-c62a-4d0f-87c6-84ead807b96c","4bc00fd1-79fe-43a3-a5ca-27d6c7abbfd0","6318cf56-93de-4904-b90e-0234105865a7","540d0eb1-f3fc-424f-afa3-76e2181a02c3","b4484646-5632-4371-b39d-5eef692ceb67","d9deb8e7-40c7-4fe4-8eb0-bfb752060fdd","d1ecda80-7514-440c-8c23-535297a6a91b","87aeecae-7857-4a4f-b90d-3d7a8e945deb","bd7e22a3-e682-479d-8bd8-8fb0d4527d45","406e6a66-b1dd-4932-aa08-3b88d489fe5e","58990965-bc3c-41c8-9038-a68734fb08a4","1e2d64d1-197b-40f1-a1a0-46c22195ca4a","2e2ce295-0cf9-4c66-aef6-8aba7cc8f4eb","74685b96-c189-4b3b-adc8-cb907e50cca5","4ceedf79-79f2-4612-bbc7-dbe08c086a41","48003433-31c1-4af9-ad2a-48c27e804153","6883e37a-fadd-43e3-b77d-bc09077f8f45","b648ed22-db76-471c-8507-3d30eed58cb6","172b9e94-4813-42c1-a44c-e31a10bf2967","aab791af-e935-4ebd-8e0b-343ac6a544c3","6a9228c8-f496-44c6-803a-5399ed9b0246","1144815e-b4a4-4ff2-a510-9512fae5d994","a695fe60-b955-4d1a-8858-45e37c881bf6","a538893a-d10a-47ca-9297-92840ebf55d8","ed19cb98-6f5b-4567-96da-5accf18c3c19","a889aa77-b744-41b7-bed5-4cf9c2c34b33","8ad58dab-92fc-4d99-8018-7e885a163486","0a0ea707-5068-417e-a782-15ea90c4b74a","1b60ff74-2a97-4d4d-9b6e-3c0929a0e01d","7c6dbb6a-6ce7-494f-9455-2e5ad0d02e31","11cad9c9-8bbb-4e58-9da6-9a3881dd4f0e","eb011bca-c829-4a89-a740-a355627be8ae","cb8f8b15-7af8-4c61-9ee2-dbacdee6064e","b868c37e-5c04-4e43-939c-472f1dfbc992","88c9e887-db20-4241-bf07-c2dd44582ab6","cdcb3a7c-bf51-4386-86c7-bc32e0966b73","b42e961a-ffb3-43c8-8756-dac03c1d84b0","24ebdf94-9fc9-4b7e-9b1b-c3639003386b","cd4a64fa-e1c1-4544-b095-86a35449f23d","419483df-3da3-4239-b638-85cb1d11c714","ba4b1cea-1dca-4674-afa8-1298753520d2","39186355-e05b-4c83-b109-ca7455af7e52","e6f45e9c-f5c2-4893-a08c-2ba13bd4ee46","d0cc1bb5-a9c4-4b9d-83c3-ccc5ac91f075","423eda57-4a61-4363-b779-0ad78643c5d1","e3936f41-19dc-4a64-b304-ec3ef3bbe451","30e6db8c-ecd8-472f-8de7-3f1ad30ef808","1f4a13e5-bb6f-48bb-85e6-dbe68007b3bc","bcd91fbe-d7b7-42e5-817a-dde056786718","fd04136b-3fca-4e06-b420-1acb1f1e4c9b","6a98cd37-4a7a-4f25-93e7-2bbc8b6b2112","e90453a6-2572-4b13-a863-fb9614226ac9","2abd4881-33d4-45c2-8ba0-94dae3f3020f","2b574031-7130-4de5-b0a6-a34c9ab0c10a"],"format":{"page_icon":"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/efaf9256-833c-41b8-a88d-7466ca5ceeb9/srchttp___img.pconline.com.cn_images_nospd_upload_upc_tx_pcdlc_2108_16_c7_274750145_1629102176621.pngreferhttp___img.pconline.com.webp"},"created_time":1661556701547,"last_edited_time":1661556900000,"parent_id":"72a66971-7cf6-42c2-a252-4439d99d8f44","parent_table":"block","alive":true,"file_ids":["efaf9256-833c-41b8-a88d-7466ca5ceeb9"],"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"72a66971-7cf6-42c2-a252-4439d99d8f44":{"role":"reader","value":{"id":"72a66971-7cf6-42c2-a252-4439d99d8f44","version":350,"type":"page","properties":{"title":[["yangsoon ‘s blog"]]},"content":["8a139bd3-c29e-4248-b950-43841f1b0076","ceb8c970-ebd0-4bb1-bd23-c481ed7fefab","b80b3335-c73f-4e47-a39b-3021b4dc650a","02130a54-428f-4e4b-861c-dcbed7945c3b","50d14bc2-cebe-43fc-9d71-aafd5cdc2947","091a74ac-4142-4f28-ba1d-5c9810ccc648","109db411-8605-412c-9217-c9bc2d611a84","46b5fd4b-3050-41cb-90ba-45cf6db1e56a","cbc30d69-9cfc-4d8e-b54f-89bb136bda62","9340a1bb-c18c-435b-aaba-8abad9eea920","52395b31-1471-4332-8b63-bcf6a19b22bf","aafbda78-8a0c-46ee-b112-b652bf92a255","79d6c9f7-68c2-4431-bf9a-11e6df0efa2a","84362361-7e17-464a-946a-63bd469bc488","d50561d4-440d-47dc-9803-2248d2230726"],"format":{"page_icon":"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/37907dd5-3c76-4966-a419-daa027a84972/IMG_2189.jpg","page_full_width":false,"page_small_text":false,"copied_from_pointer":{"id":"bd32b787-e471-49f3-8941-174a9c6846b6","table":"block","spaceId":"bb9288f4-efb5-417f-bf44-1a79fa04feb1"}},"permissions":[{"role":"editor","type":"user_permission","user_id":"d1805983-7869-451d-bf8b-64135a5d4ee7"},{"role":"reader","type":"public_permission","added_timestamp":1660963691744,"allow_duplicate":false}],"created_time":1660961589760,"last_edited_time":1661557200000,"parent_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6","parent_table":"space","alive":true,"copied_from":"bd32b787-e471-49f3-8941-174a9c6846b6","file_ids":["63e89fe9-f5cd-4414-be0e-53d91aa54fc3","37907dd5-3c76-4966-a419-daa027a84972"],"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"fa1c3357-8d66-49c7-b61e-4d3d69346323":{"role":"reader","value":{"id":"fa1c3357-8d66-49c7-b61e-4d3d69346323","version":20,"type":"text","properties":{"title":[["本文主要讲解有栈协程的实现原理，以云风实现的coroutine为例。"]]},"created_time":1661556706145,"last_edited_time":1661556720000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"053a4920-5603-423b-9ade-546274c449e8":{"role":"reader","value":{"id":"053a4920-5603-423b-9ade-546274c449e8","version":2,"type":"sub_header","properties":{"title":[["协程"]]},"created_time":1661556706146,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"57c53cca-ff1b-40e9-bb07-727965277060":{"role":"reader","value":{"id":"57c53cca-ff1b-40e9-bb07-727965277060","version":2,"type":"text","properties":{"title":[["关于协程的概念，在网上没有找到很好的解释，下面就说说个人的理解，(有栈)协程可以理解为一个用户态下的线程，在用户态下进行线程（协程）的上下文切换。但是和传统的线程不同的是：线程是抢占式执行，当发生系统调用或者中断的时候，交由OS调度执行；而协程是通过yield主动让出cpu所有权，切换到其他协程执行。"]]},"created_time":1661556706146,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"1b3e9d75-0f62-4510-9d37-cff48a0ef8b1":{"role":"reader","value":{"id":"1b3e9d75-0f62-4510-9d37-cff48a0ef8b1","version":2,"type":"sub_header","properties":{"title":[["进程、线程"]]},"created_time":1661556706146,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"0bf3a3ce-ce50-468a-a7b4-7572bc7f1950":{"role":"reader","value":{"id":"0bf3a3ce-ce50-468a-a7b4-7572bc7f1950","version":2,"type":"sub_sub_header","properties":{"title":[["进程地址空间"]]},"created_time":1661556706146,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"eaa93a3a-20d5-4bc8-8b06-16af7753d5df":{"role":"reader","value":{"id":"eaa93a3a-20d5-4bc8-8b06-16af7753d5df","version":2,"type":"text","properties":{"title":[["一般来说一个进程的地址空间有这几个默认区域:"]]},"created_time":1661556706146,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"c4b4cc20-8808-4229-b76e-b2c220ea8819":{"role":"reader","value":{"id":"c4b4cc20-8808-4229-b76e-b2c220ea8819","version":2,"type":"numbered_list","properties":{"title":[["栈：栈用于维护函数调用的上下文，包括函数的参数，局部变量等等。"]]},"created_time":1661556706146,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"80e01be4-edc7-42ac-88dc-d44c0022b938":{"role":"reader","value":{"id":"80e01be4-edc7-42ac-88dc-d44c0022b938","version":2,"type":"numbered_list","properties":{"title":[["堆：用来容纳程序中动态分配的内存区域，当程序使用malloc和new分配的内存就来自于堆里"]]},"created_time":1661556706147,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"78c54cf6-c4c3-45e5-a965-841a0c9215bd":{"role":"reader","value":{"id":"78c54cf6-c4c3-45e5-a965-841a0c9215bd","version":2,"type":"numbered_list","properties":{"title":[["可执行文件映像。"]]},"created_time":1661556706147,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"582af19c-4877-4609-b669-dea8e1fe3466":{"role":"reader","value":{"id":"582af19c-4877-4609-b669-dea8e1fe3466","version":2,"type":"numbered_list","properties":{"title":[["保留区，是对内存中受到保护而禁止访问的内存区域的总称。"]]},"created_time":1661556706147,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"674b8f34-799a-486a-9368-a3c70263d731":{"role":"reader","value":{"id":"674b8f34-799a-486a-9368-a3c70263d731","version":2,"type":"text","properties":{"title":[["下图是linux下一个进程的典型内存布局: 在经典的操作系统中，栈总是 "],["向下增长",[["b"]]],[" ，从高地址向低地址增长，其中栈顶指针存储在 "],["[E|R]SP",[["b"]]],[" 寄存器中，而堆则总是 "],["向上增长",[["b"]]],[" ，从低地址向高地址增长。"]]},"created_time":1661556706147,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"b44648ac-613f-4eae-877c-ff22c079e520":{"role":"reader","value":{"id":"b44648ac-613f-4eae-877c-ff22c079e520","version":2,"type":"text","properties":{"title":[[""]]},"created_time":1661556706147,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"ac6a02ff-a1a9-4a4d-b210-3f40fd667c84":{"role":"reader","value":{"id":"ac6a02ff-a1a9-4a4d-b210-3f40fd667c84","version":2,"type":"image","properties":{"source":[["https://user-images.githubusercontent.com/29531394/69554356-a42f3380-0fdc-11ea-9cf6-21c7d4b62bcc.png"]]},"created_time":1661556706147,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"7d7ba4e8-77a1-42ac-ac74-ecaeb6ba6c99":{"role":"reader","value":{"id":"7d7ba4e8-77a1-42ac-ac74-ecaeb6ba6c99","version":2,"type":"sub_sub_header","properties":{"title":[["栈的增长方式"]]},"created_time":1661556706147,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"47b81bd6-877c-4a0c-b71e-414cb56d1665":{"role":"reader","value":{"id":"47b81bd6-877c-4a0c-b71e-414cb56d1665","version":2,"type":"text","properties":{"title":[["栈在程序运行中具有举足轻重的地位，最重要的，栈保存了一个函数调用所需要维护的信息，这常常被称为"],["堆栈帧",[["b"]]],["，堆栈帧一般包括下面几方面内容："]]},"created_time":1661556706147,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"f2e65cac-3449-4d0f-bb72-f1aa748b9ddb":{"role":"reader","value":{"id":"f2e65cac-3449-4d0f-bb72-f1aa748b9ddb","version":2,"type":"numbered_list","properties":{"title":[["函数的返回地址和参数"]]},"created_time":1661556706148,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"12cfdaf2-14e0-4720-8af4-32f69336d87d":{"role":"reader","value":{"id":"12cfdaf2-14e0-4720-8af4-32f69336d87d","version":2,"type":"numbered_list","properties":{"title":[["临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量"]]},"created_time":1661556706148,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"010204f7-4312-449e-8d7b-2c647fa7aca2":{"role":"reader","value":{"id":"010204f7-4312-449e-8d7b-2c647fa7aca2","version":2,"type":"numbered_list","properties":{"title":[["保存的上下文：包括在函数调用前后需要保存不变的寄存器的值"]]},"created_time":1661556706148,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"098d17c4-973d-4986-a38b-9bc724c172ef":{"role":"reader","value":{"id":"098d17c4-973d-4986-a38b-9bc724c172ef","version":2,"type":"text","properties":{"title":[["一个函数的堆栈帧用 "],["[E|R]SP,[E|R]BP",[["b"]]],[" ，这两个寄存器划定范围，"],["[E|R]SP",[["b"]]],["始终指向栈顶的位置称为栈指针寄存器，"],["[E|R]SP",[["b"]]],["指向堆栈帧的一个固定位置，"],["[E|R]SP",[["b"]]],[" 又被称为帧指针，一般函数中的局部变量靠 "],["[E|R]SP",[["b"]]],[" 加上偏移量寻找。"]]},"created_time":1661556706148,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"dff2befb-112a-460c-9ed3-df3e39f50182":{"role":"reader","value":{"id":"dff2befb-112a-460c-9ed3-df3e39f50182","version":2,"type":"quote","properties":{"title":[["[E|R]SP表示esp或者rsp寄存器，esp表示32位x86架构下的栈指针寄存器，rsp表示64位x86架构下的栈指针寄存器，同理于[E|R]BP。 帧指针并不是必须的, x86-64过程中的栈帧通常有固定的大小，在调用过程中栈指针保持固定的位置，使得可以通过相对于栈指针的偏移量来访问数据^1。"]]},"created_time":1661556706148,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"177caef2-deb2-4f19-ad1b-b7f5a8bcf401":{"role":"reader","value":{"id":"177caef2-deb2-4f19-ad1b-b7f5a8bcf401","version":2,"type":"text","properties":{"title":[["下面我们就简单讲解一下当程序调用一个简单的函数时，线程中的栈是如何增长的。假设有一个foo函数"]]},"created_time":1661556706148,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"c0225528-1c15-4ded-a5d6-1d7434d2916f":{"role":"reader","value":{"id":"c0225528-1c15-4ded-a5d6-1d7434d2916f","version":4,"type":"code","properties":{"title":[["int foo(int m, int n){\n  int a = 0; // #i\n  ....\n}\n"]],"language":[["C"]]},"format":{"code_wrap":true},"created_time":1661556706148,"last_edited_time":1661556720000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"09acbf6c-f422-4723-bbeb-4e4e916b7170":{"role":"reader","value":{"id":"09acbf6c-f422-4723-bbeb-4e4e916b7170","version":2,"type":"text","properties":{"title":[["该函数对应的堆栈帧的内存空间如下所示，一个函数的堆栈帧增长过程是这样的："]]},"created_time":1661556706148,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"780e6eca-b041-4bf2-bfb4-d115c10097e2":{"role":"reader","value":{"id":"780e6eca-b041-4bf2-bfb4-d115c10097e2","version":2,"type":"numbered_list","properties":{"title":[["把所有或一部分参数加入栈中，如果有其他参数没有入栈，那么使用某些寄存器传递"]]},"created_time":1661556706149,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"91243b24-4801-4c77-9e9c-e5d05b98d66a":{"role":"reader","value":{"id":"91243b24-4801-4c77-9e9c-e5d05b98d66a","version":2,"type":"numbered_list","properties":{"title":[["把当前指令的下一条指令地址压入栈中"]]},"created_time":1661556706149,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"ba511ef4-cd74-4973-9aa9-af7ee9d2483c":{"role":"reader","value":{"id":"ba511ef4-cd74-4973-9aa9-af7ee9d2483c","version":2,"type":"numbered_list","properties":{"title":[["跳转到函数体执行:"]]},"content":["d80d2234-5b60-47e0-be22-6992f853518b","2c91bb50-8e9a-4374-859e-70ad71d8258f","f4a104b3-6025-4cca-a61d-bcc93a4d8889","a3450908-ce05-48ba-b0e6-2b0ea6fc3813"],"created_time":1661556706149,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"d80d2234-5b60-47e0-be22-6992f853518b":{"role":"reader","value":{"id":"d80d2234-5b60-47e0-be22-6992f853518b","version":2,"type":"numbered_list","properties":{"title":[["把[e|r]bp压入栈中，指向上一个函数堆栈帧中的帧指针的位置"]]},"created_time":1661556706149,"last_edited_time":1661556660000,"parent_id":"ba511ef4-cd74-4973-9aa9-af7ee9d2483c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"2c91bb50-8e9a-4374-859e-70ad71d8258f":{"role":"reader","value":{"id":"2c91bb50-8e9a-4374-859e-70ad71d8258f","version":2,"type":"numbered_list","properties":{"title":[["保存调用前后需要保存不变的寄存器的值"]]},"created_time":1661556706149,"last_edited_time":1661556660000,"parent_id":"ba511ef4-cd74-4973-9aa9-af7ee9d2483c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"f4a104b3-6025-4cca-a61d-bcc93a4d8889":{"role":"reader","value":{"id":"f4a104b3-6025-4cca-a61d-bcc93a4d8889","version":2,"type":"numbered_list","properties":{"title":[["将局部变量压入栈中"]]},"created_time":1661556706149,"last_edited_time":1661556660000,"parent_id":"ba511ef4-cd74-4973-9aa9-af7ee9d2483c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"a3450908-ce05-48ba-b0e6-2b0ea6fc3813":{"role":"reader","value":{"id":"a3450908-ce05-48ba-b0e6-2b0ea6fc3813","version":2,"type":"text","properties":{"title":[["..."]]},"created_time":1661556706149,"last_edited_time":1661556660000,"parent_id":"ba511ef4-cd74-4973-9aa9-af7ee9d2483c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"01bc0475-504f-48d1-b921-a2cd8ca652f2":{"role":"reader","value":{"id":"01bc0475-504f-48d1-b921-a2cd8ca652f2","version":2,"type":"text","properties":{"title":[["当函数调用返回之后，相应的函数堆栈帧也会弹出，弹出的流程不是本篇文章的重点，在此就不详细讲解，感兴趣的推荐看 "],["程序员的自我修养",[["b"]]],[" 中讲解堆栈的部分。"]]},"created_time":1661556706149,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"7d97a16b-9fcc-435d-9fb4-8e6453129f37":{"role":"reader","value":{"id":"7d97a16b-9fcc-435d-9fb4-8e6453129f37","version":2,"type":"image","properties":{"source":[["https://user-images.githubusercontent.com/29531394/69641429-2847f080-109b-11ea-80fa-fab3c148dba6.png"]]},"created_time":1661556706149,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"edfe5570-b469-48ac-bace-e9ffe3650f54":{"role":"reader","value":{"id":"edfe5570-b469-48ac-bace-e9ffe3650f54","version":2,"type":"sub_sub_header","properties":{"title":[["线程"]]},"created_time":1661556706149,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"9471b13e-899c-4902-a3ee-7c43b5b1bb4a":{"role":"reader","value":{"id":"9471b13e-899c-4902-a3ee-7c43b5b1bb4a","version":2,"type":"text","properties":{"title":[["一个标准的线程由线程id、程序计数器(PC)、寄存器集合和栈组成。"]]},"created_time":1661556706150,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"5ab357ce-c62a-4d0f-87c6-84ead807b96c":{"role":"reader","value":{"id":"5ab357ce-c62a-4d0f-87c6-84ead807b96c","version":2,"type":"text","properties":{"title":[["每个线程类似一个独立进程，不同的是线程之间共享地址空间，能够访问到相同的数据。线程之间共享进程的内存空间(包括代码段、数据段、堆等)以及以下进程级的资源（如打开文件和信号）。"]]},"created_time":1661556706150,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"4bc00fd1-79fe-43a3-a5ca-27d6c7abbfd0":{"role":"reader","value":{"id":"4bc00fd1-79fe-43a3-a5ca-27d6c7abbfd0","version":2,"type":"text","properties":{"title":[["一个经典的进程和线程的关系如下图所示："]]},"created_time":1661556706150,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"6318cf56-93de-4904-b90e-0234105865a7":{"role":"reader","value":{"id":"6318cf56-93de-4904-b90e-0234105865a7","version":2,"type":"image","properties":{"source":[["https://user-images.githubusercontent.com/29531394/69556981-be6b1080-0fe0-11ea-8f46-9ef60c77f161.png"]]},"created_time":1661556706150,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"540d0eb1-f3fc-424f-afa3-76e2181a02c3":{"role":"reader","value":{"id":"540d0eb1-f3fc-424f-afa3-76e2181a02c3","version":2,"type":"sub_sub_header","properties":{"title":[["线程上下文切换"]]},"created_time":1661556706150,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"b4484646-5632-4371-b39d-5eef692ceb67":{"role":"reader","value":{"id":"b4484646-5632-4371-b39d-5eef692ceb67","version":2,"type":"text","properties":{"title":[["假设有2个线程运行在一个处理器上，从运行一个线程(T1)切换到另一个线程(T2)时，一定会发生上下文切换。对于进程，我们需要将状态保存到进程控制块(PCB)中，现在我们需要一个或多个线程控制块(TCB)来保存每个线程的状态，但是和进程上下文切换相比，线程在进行上下文切换的时候"],["地址空间保持不变",[["b"]]],["(即不需要切换当前使用的页表)。一个拥有多线程的进程的地址空间，如下图所示，我们可以看到每个线程拥有有自己的栈。"]]},"created_time":1661556706150,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"d9deb8e7-40c7-4fe4-8eb0-bfb752060fdd":{"role":"reader","value":{"id":"d9deb8e7-40c7-4fe4-8eb0-bfb752060fdd","version":2,"type":"image","properties":{"source":[["https://user-images.githubusercontent.com/29531394/69641464-372ea300-109b-11ea-9946-b107ad6f85d5.png"]]},"created_time":1661556706150,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"d1ecda80-7514-440c-8c23-535297a6a91b":{"role":"reader","value":{"id":"d1ecda80-7514-440c-8c23-535297a6a91b","version":2,"type":"sub_sub_header","properties":{"title":[["实现协程的理论依据"]]},"created_time":1661556706150,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"87aeecae-7857-4a4f-b90d-3d7a8e945deb":{"role":"reader","value":{"id":"87aeecae-7857-4a4f-b90d-3d7a8e945deb","version":2,"type":"text","properties":{"title":[["有栈协程就是实现了一个用户态的线程，用户可以在堆上模拟出协程的栈空间，当需要进行协程上下文切换的时候，主线程只需要交换栈空间和恢复协程的一些相关的寄存器的状态就可以实现一个用户态的线程上下文切换，没有了从用户态转换到内核态的切换成本，协程的执行也就更加高效。"]]},"created_time":1661556706150,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"bd7e22a3-e682-479d-8bd8-8fb0d4527d45":{"role":"reader","value":{"id":"bd7e22a3-e682-479d-8bd8-8fb0d4527d45","version":2,"type":"sub_header","properties":{"title":[["ucontext"]]},"created_time":1661556706150,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"406e6a66-b1dd-4932-aa08-3b88d489fe5e":{"role":"reader","value":{"id":"406e6a66-b1dd-4932-aa08-3b88d489fe5e","version":2,"type":"text","properties":{"title":[["我们参考的协程实现是云风大佬编写的coroutine，源码只有不到200行，很适合用来阅读学习。在这个版本的coroutine中，使用ucontext族函数实现。我们先来简单的看一下这个函数族的基本功能。该部分参考自博客"],["^2",[["a","https://blog.csdn.net/qq910894904/article/details/41911175"]]],["。"]]},"created_time":1661556706150,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"58990965-bc3c-41c8-9038-a68734fb08a4":{"role":"reader","value":{"id":"58990965-bc3c-41c8-9038-a68734fb08a4","version":2,"type":"text","properties":{"title":[["在类System V环境中,在头文件"],["< ucontext.h > ",[["c"]]],[" 中定义了两个结构类型，"],["mcontext_t",[["c"]]],[" 和 "],["ucontext_t",[["c"]]],["和四个函数"],["getcontext()",[["c"]]],[","],["setcontext()",[["c"]]],[","],["makecontext()",[["c"]]],[","],["swapcontext()",[["c"]]],[".利用它们可以在一个进程中实现用户级的线程切换。\n"],["ucontext_t",[["c"]]],[" 结构体定义如下:"]]},"created_time":1661556706151,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"1e2d64d1-197b-40f1-a1a0-46c22195ca4a":{"role":"reader","value":{"id":"1e2d64d1-197b-40f1-a1a0-46c22195ca4a","version":4,"type":"code","properties":{"title":[["typedef struct ucontext {\n  struct ucontext *uc_link;\n  sigset_t         uc_sigmask;\n  stack_t          uc_stack;\n  mcontext_t       uc_mcontext;\n  ...\n} ucontext_t;\n"]],"language":[["C"]]},"format":{"code_wrap":true},"created_time":1661556706151,"last_edited_time":1661556720000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"2e2ce295-0cf9-4c66-aef6-8aba7cc8f4eb":{"role":"reader","value":{"id":"2e2ce295-0cf9-4c66-aef6-8aba7cc8f4eb","version":2,"type":"text","properties":{"title":[["当当前上下文(如使用 "],["makecontext",[["c"]]],[" 创建的上下文）运行终止时系统会恢复"],["uc_link",[["c"]]],["指向的上下文；"],["uc_sigmask",[["c"]]],["为该上下文中的阻塞信号集合；"],["uc_stack",[["c"]]],["为该上下文中使用的栈；"],["uc_mcontext",[["c"]]],["保存的上下文的特定机器表示，包括调用线程的特定寄存器等。"]]},"created_time":1661556706151,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"74685b96-c189-4b3b-adc8-cb907e50cca5":{"role":"reader","value":{"id":"74685b96-c189-4b3b-adc8-cb907e50cca5","version":2,"type":"text","properties":{"title":[["下面讲解四个函数的作用，详细的函数使用方法参考man手册:"]]},"created_time":1661556706151,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"4ceedf79-79f2-4612-bbc7-dbe08c086a41":{"role":"reader","value":{"id":"4ceedf79-79f2-4612-bbc7-dbe08c086a41","version":2,"type":"numbered_list","properties":{"title":[["初始化ucp结构体，将当前的上下文保存到ucp中"]]},"content":["712b2725-8458-4e61-8bfd-cd393cd19ba6"],"created_time":1661556706151,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"712b2725-8458-4e61-8bfd-cd393cd19ba6":{"role":"reader","value":{"id":"712b2725-8458-4e61-8bfd-cd393cd19ba6","version":4,"type":"code","properties":{"title":[["int getcontext(ucontext_t *ucp);\n"]],"language":[["C"]]},"format":{"code_wrap":true},"created_time":1661556706151,"last_edited_time":1661556720000,"parent_id":"4ceedf79-79f2-4612-bbc7-dbe08c086a41","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"48003433-31c1-4af9-ad2a-48c27e804153":{"role":"reader","value":{"id":"48003433-31c1-4af9-ad2a-48c27e804153","version":2,"type":"numbered_list","properties":{"title":[["修改用户线程的上下文指向参数ucp，在调用makecontext之前必须调用getcontext初始化一个ucp，并且需要分配一个栈空间给初始化后的ucp，当上下文通过setcontext或者swapcontext激活后，就会紧接着调用第二个参数指向的函数func，参数argc代表 func所需的参数，在调用makecontext之前你需要初始化参数ucp->uc_link，这个参数表示func()执行之后，用户线程将要切换到ucp->uc_link所代表的上下文，其实是隐式的调用了setcontext函数。"]]},"content":["204cc5a0-7432-4697-9a9b-28b730ac42a4"],"created_time":1661556706151,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"204cc5a0-7432-4697-9a9b-28b730ac42a4":{"role":"reader","value":{"id":"204cc5a0-7432-4697-9a9b-28b730ac42a4","version":4,"type":"code","properties":{"title":[["void makecontext(ucontext_t *ucp, void (*func)(), int argc, ...);\n"]],"language":[["C"]]},"format":{"code_wrap":true},"created_time":1661556706151,"last_edited_time":1661556720000,"parent_id":"48003433-31c1-4af9-ad2a-48c27e804153","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"6883e37a-fadd-43e3-b77d-bc09077f8f45":{"role":"reader","value":{"id":"6883e37a-fadd-43e3-b77d-bc09077f8f45","version":2,"type":"numbered_list","properties":{"title":[["设置当前的上下文为ucp，setcontext的上下文ucp应该通过getcontext或者makecontext取得，如果调用成功则不返回。"]]},"content":["d6969ec0-5153-4171-8273-f46bad22111a"],"created_time":1661556706152,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"d6969ec0-5153-4171-8273-f46bad22111a":{"role":"reader","value":{"id":"d6969ec0-5153-4171-8273-f46bad22111a","version":4,"type":"code","properties":{"title":[["int setcontext(const ucontext_t *ucp);\n"]],"language":[["C"]]},"format":{"code_wrap":true},"created_time":1661556706152,"last_edited_time":1661556720000,"parent_id":"6883e37a-fadd-43e3-b77d-bc09077f8f45","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"b648ed22-db76-471c-8507-3d30eed58cb6":{"role":"reader","value":{"id":"b648ed22-db76-471c-8507-3d30eed58cb6","version":2,"type":"numbered_list","properties":{"title":[["保存当前上下文到oucp结构体中，然后激活upc上下文。"]]},"created_time":1661556706152,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"172b9e94-4813-42c1-a44c-e31a10bf2967":{"role":"reader","value":{"id":"172b9e94-4813-42c1-a44c-e31a10bf2967","version":4,"type":"code","properties":{"title":[["int swapcontext(ucontext_t *oucp, ucontext_t *ucp);\n"]],"language":[["C"]]},"format":{"code_wrap":true},"created_time":1661556706152,"last_edited_time":1661556780000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"aab791af-e935-4ebd-8e0b-343ac6a544c3":{"role":"reader","value":{"id":"aab791af-e935-4ebd-8e0b-343ac6a544c3","version":2,"type":"text","properties":{"title":[["写个简单的例子来看一下如何使用："]]},"created_time":1661556706152,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"6a9228c8-f496-44c6-803a-5399ed9b0246":{"role":"reader","value":{"id":"6a9228c8-f496-44c6-803a-5399ed9b0246","version":4,"type":"code","properties":{"title":[["#include <ucontext.h>\n#include <stdio.h>\n\nint func(void *arg) {\n  puts(\"this is func\");\n}\n\nvoid coroutine_test() {\n  char stack[1024 * 128];\n  ucontext_t child, main;\n  // 获取当前上下文\n  getcontext(&child);\n\n  // 分配栈空间 uc_stack.ss_sp 指向栈顶\n  child.uc_stack.ss_sp = stack;\n  child.uc_stack.ss_size = sizeof(stack);\n  child.uc_stack.ss_flags = 0;\n  // 指定后继上下文\n  child.uc_link = &main;\n  // child.uc_link = NULL;\n\n  makecontext(&child, (void (*)(void))func, 0);\n\n  //切换到child上下文，保存当前上下文到main\n  swapcontext(&main, &child);\n  // 如果设置了后继上下文，func函数指向完后会返回此处 如果设置为NULL，就不会执行这一步\n  puts(\"this is coroutine_test\");\n}\n\nint main() {\n  coroutine_test();\n  return 0;\n}\n"]],"language":[["C"]]},"format":{"code_wrap":true},"created_time":1661556706152,"last_edited_time":1661556780000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"1144815e-b4a4-4ff2-a510-9512fae5d994":{"role":"reader","value":{"id":"1144815e-b4a4-4ff2-a510-9512fae5d994","version":2,"type":"text","properties":{"title":[["程序的执行结果为："]]},"created_time":1661556706152,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"a695fe60-b955-4d1a-8858-45e37c881bf6":{"role":"reader","value":{"id":"a695fe60-b955-4d1a-8858-45e37c881bf6","version":4,"type":"code","properties":{"title":[["this is func\nthis is coroutine_test\n"]],"language":[["C"]]},"format":{"code_wrap":true},"created_time":1661556706152,"last_edited_time":1661556780000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"a538893a-d10a-47ca-9297-92840ebf55d8":{"role":"reader","value":{"id":"a538893a-d10a-47ca-9297-92840ebf55d8","version":2,"type":"sub_header","properties":{"title":[["coroutine实现"]]},"created_time":1661556706152,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"ed19cb98-6f5b-4567-96da-5accf18c3c19":{"role":"reader","value":{"id":"ed19cb98-6f5b-4567-96da-5accf18c3c19","version":2,"type":"text","properties":{"title":[["本文不打算详细讲解coroutine的代码实现，具体的实现细节大家可以参考文章"],["^3",[["a","https://zhuanlan.zhihu.com/p/84935949"]]],[",本文的代码注释也来自这篇文章，建议看完本节之后再阅读该文章来了解代码实现细节。通过学习了前几节讲到的基础知识，相信大家能够比较轻松的看懂协程代码的实现。本小节主要从整体的角度来讲解coroutine的实现。"]]},"created_time":1661556706152,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"a889aa77-b744-41b7-bed5-4cf9c2c34b33":{"role":"reader","value":{"id":"a889aa77-b744-41b7-bed5-4cf9c2c34b33","version":2,"type":"sub_sub_header","properties":{"title":[["coroutine例子"]]},"created_time":1661556706152,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"8ad58dab-92fc-4d99-8018-7e885a163486":{"role":"reader","value":{"id":"8ad58dab-92fc-4d99-8018-7e885a163486","version":4,"type":"code","properties":{"title":[["#include \"coroutine.h\"\n#include <stdio.h>\n\nstruct args {\n\tint n;\n};\n\nstatic void\nfoo(struct schedule * S, void *ud) {\n\tstruct args * arg = ud;\n\tint start = arg->n;\n\tint i;\n\tfor (i=0;i<5;i++) {\n\t\tprintf(\"coroutine %d : %d\\\\n\",coroutine_running(S) , start + i);\n\t\t// 切出当前协程\n\t\tcoroutine_yield(S);\n\t}\n}\n\nstatic void\ntest(struct schedule *S) {\n\tstruct args arg1 = { 0 };\n\tstruct args arg2 = { 100 };\n\n\t// 创建两个协程\n\tint co1 = coroutine_new(S, foo, &arg1);\n\tint co2 = coroutine_new(S, foo, &arg2);\n\tprintf(\"main start\\\\n\");\n\twhile (coroutine_status(S,co1) && coroutine_status(S,co2)) {\n\t\t// 使用协程co1\n\t\tcoroutine_resume(S,co1);\n\t\t// 使用协程co2\n\t\tcoroutine_resume(S,co2);\n\t}\n\tprintf(\"main end\\\\n\");\n}\n\nint\nmain() {\n\t// 创建一个协程调度器\n\tstruct schedule * S = coroutine_open();\n\ttest(S);\n\t// 关闭协程调度器\n\tcoroutine_close(S);\n\treturn 0;\n}\n"]],"language":[["C"]]},"format":{"code_wrap":true},"created_time":1661556706152,"last_edited_time":1661556780000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"0a0ea707-5068-417e-a782-15ea90c4b74a":{"role":"reader","value":{"id":"0a0ea707-5068-417e-a782-15ea90c4b74a","version":2,"type":"sub_sub_header","properties":{"title":[["核心对象"]]},"created_time":1661556706152,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"1b60ff74-2a97-4d4d-9b6e-3c0929a0e01d":{"role":"reader","value":{"id":"1b60ff74-2a97-4d4d-9b6e-3c0929a0e01d","version":2,"type":"numbered_list","properties":{"title":[["struct schedule* S",[["c"]]],[" 协程调度器"]]},"content":["5d12a6bb-198f-4a3a-87f1-03e678ce4680","2d319916-c6e9-4233-a006-ffa456c0449f","5185e2e6-ef95-41b9-90af-fd45fe7c4397","82231d47-d1ce-4aa6-9e99-c72c060971a1"],"created_time":1661556706153,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"5d12a6bb-198f-4a3a-87f1-03e678ce4680":{"role":"reader","value":{"id":"5d12a6bb-198f-4a3a-87f1-03e678ce4680","version":4,"type":"code","properties":{"title":[["struct schedule {\n    char stack[STACK_SIZE]; // 运行时栈，此栈即是共享栈\n    ucontext_t main; // 主协程的上下文\n    int nco;        // 当前存活的协程个数\n    int cap;        // 协程管理器的当前最大容量，即可以同时支持多少个协程。如果不够了，则进行2倍扩容\n    int running;    // 正在运行的协程ID\n    struct coroutine **co; // 一个一维数组，用于存放所有协程。其长度等于cap\n};\n"]],"language":[["C"]]},"format":{"code_wrap":true},"created_time":1661556706153,"last_edited_time":1661556780000,"parent_id":"1b60ff74-2a97-4d4d-9b6e-3c0929a0e01d","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"2d319916-c6e9-4233-a006-ffa456c0449f":{"role":"reader","value":{"id":"2d319916-c6e9-4233-a006-ffa456c0449f","version":2,"type":"text","properties":{"title":[["调度器中包含协程运行时的共享栈stack，共享栈可以认为所有的协程在运行时用的都是同一块栈，当调用协程的时候，将自己的栈拷贝到共享栈即可。当协程切出时，将栈空间再复制出来。"]]},"created_time":1661556706153,"last_edited_time":1661556660000,"parent_id":"1b60ff74-2a97-4d4d-9b6e-3c0929a0e01d","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"5185e2e6-ef95-41b9-90af-fd45fe7c4397":{"role":"reader","value":{"id":"5185e2e6-ef95-41b9-90af-fd45fe7c4397","version":2,"type":"text","properties":{"title":[["还包括主协程上下文，可以认为是协程执行完毕之后回到的上下文。"]]},"created_time":1661556706153,"last_edited_time":1661556660000,"parent_id":"1b60ff74-2a97-4d4d-9b6e-3c0929a0e01d","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"82231d47-d1ce-4aa6-9e99-c72c060971a1":{"role":"reader","value":{"id":"82231d47-d1ce-4aa6-9e99-c72c060971a1","version":2,"type":"text","properties":{"title":[["以及一个一维数组，用来存放调度器包括的所有协程。"]]},"created_time":1661556706153,"last_edited_time":1661556660000,"parent_id":"1b60ff74-2a97-4d4d-9b6e-3c0929a0e01d","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"7c6dbb6a-6ce7-494f-9455-2e5ad0d02e31":{"role":"reader","value":{"id":"7c6dbb6a-6ce7-494f-9455-2e5ad0d02e31","version":2,"type":"numbered_list","properties":{"title":[["coroutine",[["c"]]],["协程"]]},"content":["59526aa9-cd87-41cc-9f7a-1b0312caa9d7","0f224d02-df14-44e7-9282-49f90b6d5e12"],"created_time":1661556706153,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"59526aa9-cd87-41cc-9f7a-1b0312caa9d7":{"role":"reader","value":{"id":"59526aa9-cd87-41cc-9f7a-1b0312caa9d7","version":4,"type":"code","properties":{"title":[["struct coroutine {\n    coroutine_func func; // 协程所用的函数\n    void *ud;  // 协程参数\n    ucontext_t ctx; // 协程上下文\n    struct schedule * sch; // 该协程所属的调度器\n    ptrdiff_t cap;   // 已经分配的内存大小\n    ptrdiff_t size; // 当前协程运行时栈，保存起来后的大小\n    int status; // 协程当前的状态\n    char *stack; // 当前协程的保存起来的运行时栈\n};\n"]],"language":[["C"]]},"format":{"code_wrap":true},"created_time":1661556706153,"last_edited_time":1661556780000,"parent_id":"7c6dbb6a-6ce7-494f-9455-2e5ad0d02e31","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"0f224d02-df14-44e7-9282-49f90b6d5e12":{"role":"reader","value":{"id":"0f224d02-df14-44e7-9282-49f90b6d5e12","version":2,"type":"text","properties":{"title":[["coroutine",[["c"]]],["结构体包括协程需要执行的函数，协程自己的上下文，用于上下文切换，以及stack用来保存运行时栈。"]]},"created_time":1661556706153,"last_edited_time":1661556660000,"parent_id":"7c6dbb6a-6ce7-494f-9455-2e5ad0d02e31","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"11cad9c9-8bbb-4e58-9da6-9a3881dd4f0e":{"role":"reader","value":{"id":"11cad9c9-8bbb-4e58-9da6-9a3881dd4f0e","version":2,"type":"sub_sub_header","properties":{"title":[["协程状态"]]},"created_time":1661556706153,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"eb011bca-c829-4a89-a740-a355627be8ae":{"role":"reader","value":{"id":"eb011bca-c829-4a89-a740-a355627be8ae","version":2,"type":"text","properties":{"title":[["协程有4个状态，分别是READY、RUNNING、SUSPEND、DEAD这四个状态。状态转换如图所示："]]},"created_time":1661556706153,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"cb8f8b15-7af8-4c61-9ee2-dbacdee6064e":{"role":"reader","value":{"id":"cb8f8b15-7af8-4c61-9ee2-dbacdee6064e","version":2,"type":"image","properties":{"source":[["https://user-images.githubusercontent.com/29531394/69722195-7a4b4d80-1151-11ea-97e8-3c7c32c91046.png"]]},"created_time":1661556706154,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"b868c37e-5c04-4e43-939c-472f1dfbc992":{"role":"reader","value":{"id":"b868c37e-5c04-4e43-939c-472f1dfbc992","version":2,"type":"text","properties":{"title":[["coroutine_new",[["c"]]],["函数用来创建一个协程，协程进行状态转移的核心实现位于"],["coroutine_resume",[["c"]]],["函数和"],["coroutine_yield",[["c"]]],["函数中。"]]},"created_time":1661556706154,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"88c9e887-db20-4241-bf07-c2dd44582ab6":{"role":"reader","value":{"id":"88c9e887-db20-4241-bf07-c2dd44582ab6","version":2,"type":"sub_sub_header","properties":{"title":[["READY -> RUNNING"]]},"created_time":1661556706154,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"cdcb3a7c-bf51-4386-86c7-bc32e0966b73":{"role":"reader","value":{"id":"cdcb3a7c-bf51-4386-86c7-bc32e0966b73","version":2,"type":"text","properties":{"title":[["我们现看一下从READY状态转移到RUNNING状态进行的操作，和我们上面讲ucontext举的例子一样。首先，我们初始化协程的上下文，将协程的栈空间指向调度器中的共享栈，uc_link参数设定为S->main，当执行完makecontext指定的函数之后就会返回到调用coroutine_resume函数的地方。"]]},"created_time":1661556706154,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"b42e961a-ffb3-43c8-8756-dac03c1d84b0":{"role":"reader","value":{"id":"b42e961a-ffb3-43c8-8756-dac03c1d84b0","version":4,"type":"code","properties":{"title":[["// coroutine_resume\nswitch(status) {\n\tcase COROUTINE_READY:\n\t    //初始化ucontext_t结构体,将当前的上下文放到C->ctx里面\n\t\tgetcontext(&C->ctx);\n\t\t// 将当前协程的运行时栈的栈顶设置为S->stack，每个协程都这么设置，这就是所谓的共享栈。（注意，这里是栈顶）\n\t\tC->ctx.uc_stack.ss_sp = S->stack;\n\t\tC->ctx.uc_stack.ss_size = STACK_SIZE;\n\t\tC->ctx.uc_link = &S->main; // 如果协程执行完，将切换到主协程中执行\n\t\tS->running = id;\n\t\tC->status = COROUTINE_RUNNING;\n\n\t\t// 设置执行C->ctx函数, 并将S作为参数传进去\n\t\tuintptr_t ptr = (uintptr_t)S;\n\t\tmakecontext(&C->ctx, (void (*)(void)) mainfunc, 2, (uint32_t)ptr, (uint32_t)(ptr>>32));\n\n\t\t// 将当前的上下文放入S->main中，并将C->ctx的上下文替换到当前上下文\n\t\tswapcontext(&S->main, &C->ctx);\n\t\tbreak;\n"]],"language":[["C"]]},"format":{"code_wrap":true},"created_time":1661556706154,"last_edited_time":1661556780000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"24ebdf94-9fc9-4b7e-9b1b-c3639003386b":{"role":"reader","value":{"id":"24ebdf94-9fc9-4b7e-9b1b-c3639003386b","version":2,"type":"sub_sub_header","properties":{"title":[["RUNNING -> SUSPEND"]]},"created_time":1661556706154,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"cd4a64fa-e1c1-4544-b095-86a35449f23d":{"role":"reader","value":{"id":"cd4a64fa-e1c1-4544-b095-86a35449f23d","version":2,"type":"text","properties":{"title":[["当执行coroutine_yield函数之后，我们看到程序会首先保存当前协程的运行时栈，然后把协程的状态修改为挂起状态，并切换到主协程中。"]]},"created_time":1661556706154,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"419483df-3da3-4239-b638-85cb1d11c714":{"role":"reader","value":{"id":"419483df-3da3-4239-b638-85cb1d11c714","version":4,"type":"code","properties":{"title":[["void\ncoroutine_yield(struct schedule * S) {\n\t// 取出当前正在运行的协程\n\tint id = S->running;\n\tassert(id >= 0);\n\n\tstruct coroutine * C = S->co[id];\n\tassert((char *)&C > S->stack);\n\n\t// 将当前运行的协程的栈内容保存起来\n\t_save_stack(C,S->stack + STACK_SIZE);\n\n\t// 将当前栈的状态改为 挂起\n\tC->status = COROUTINE_SUSPEND;\n\tS->running = -1;\n\n\t// 所以这里可以看到，只能从协程切换到主协程中\n\tswapcontext(&C->ctx , &S->main);\n}\n"]],"language":[["C"]]},"format":{"code_wrap":true},"created_time":1661556706154,"last_edited_time":1661556780000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"ba4b1cea-1dca-4674-afa8-1298753520d2":{"role":"reader","value":{"id":"ba4b1cea-1dca-4674-afa8-1298753520d2","version":2,"type":"sub_sub_header","properties":{"title":[["SUSPEND -> RUNNING"]]},"created_time":1661556706154,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"39186355-e05b-4c83-b109-ca7455af7e52":{"role":"reader","value":{"id":"39186355-e05b-4c83-b109-ca7455af7e52","version":2,"type":"text","properties":{"title":[["当从挂起状态恢复为执行状态时，会将协程的运行时栈拷贝到共享栈，并再次切换上下文回到调用coroutine_yield函数的地方。"]]},"created_time":1661556706154,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"e6f45e9c-f5c2-4893-a08c-2ba13bd4ee46":{"role":"reader","value":{"id":"e6f45e9c-f5c2-4893-a08c-2ba13bd4ee46","version":4,"type":"code","properties":{"title":[["\tcase COROUTINE_SUSPEND:\n\t    // 将协程所保存的栈的内容，拷贝到当前运行时栈中\n\t\t// 其中C->size在yield时有保存\n\t\tmemcpy(S->stack + STACK_SIZE - C->size, C->stack, C->size);\n\t\tS->running = id;\n\t\tC->status = COROUTINE_RUNNING;\n\t\tswapcontext(&S->main, &C->ctx);\n\t\tbreak;\n"]],"language":[["C"]]},"format":{"code_wrap":true},"created_time":1661556706154,"last_edited_time":1661556780000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"d0cc1bb5-a9c4-4b9d-83c3-ccc5ac91f075":{"role":"reader","value":{"id":"d0cc1bb5-a9c4-4b9d-83c3-ccc5ac91f075","version":2,"type":"sub_sub_header","properties":{"title":[["运行栈保存"]]},"created_time":1661556706154,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"423eda57-4a61-4363-b779-0ad78643c5d1":{"role":"reader","value":{"id":"423eda57-4a61-4363-b779-0ad78643c5d1","version":2,"type":"text","properties":{"title":[["当执行coroutine_yield函数的时候，会发现该函数会调用"],["_save_stack",[["c"]]],["将当前协程的栈保存起来，因为coroutine是基于共享栈的，所以协程的栈内容需要单独保存起来。这里有一个很trick的点，那就是当前协程的运行栈怎么保存起来，也就是如何获取协程的栈空间。"]]},"created_time":1661556706155,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"e3936f41-19dc-4a64-b304-ec3ef3bbe451":{"role":"reader","value":{"id":"e3936f41-19dc-4a64-b304-ec3ef3bbe451","version":2,"type":"text","properties":{"title":[["一开始我们会在初始化调度器的时候设置共享栈的大小，stack指向栈顶，为了降低内存的占用，我们保存协程栈的时候不会直接保存一份和共享栈一样大小的栈空间，这时候我们需要找到该协程的栈顶位置。"]]},"created_time":1661556706155,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"30e6db8c-ecd8-472f-8de7-3f1ad30ef808":{"role":"reader","value":{"id":"30e6db8c-ecd8-472f-8de7-3f1ad30ef808","version":2,"type":"text","properties":{"title":[["下面代码的实现非常巧妙，他声明了一个局部变量dummy，而dummy的地址就是栈顶位置，大家可以参考上面讲的foo函数栈增长部分，相信你一定也能想到。"]]},"created_time":1661556706155,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"1f4a13e5-bb6f-48bb-85e6-dbe68007b3bc":{"role":"reader","value":{"id":"1f4a13e5-bb6f-48bb-85e6-dbe68007b3bc","version":4,"type":"code","properties":{"title":[["static void\n_save_stack(struct coroutine *C, char *top) {\n\t// 这个dummy很关键，是求取整个栈的关键\n\t// 这个非常经典，涉及到linux的内存分布，栈是从高地址向低地址扩展，因此\n\t// S->stack + STACK_SIZE就是运行时栈的栈底\n\t// dummy，此时在栈中，肯定是位于最底的位置的，即栈顶\n\t// top - &dummy 即整个栈的容量\n\tchar dummy = 0;\n\tassert(top - &dummy <= STACK_SIZE);\n\tif (C->cap < top - &dummy) {\n\t\tfree(C->stack);\n\t\tC->cap = top-&dummy;\n\t\tC->stack = malloc(C->cap);\n\t}\n\tC->size = top - &dummy;\n\tmemcpy(C->stack, &dummy, C->size);\n}\n"]],"language":[["C"]]},"format":{"code_wrap":true},"created_time":1661556706155,"last_edited_time":1661556780000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"bcd91fbe-d7b7-42e5-817a-dde056786718":{"role":"reader","value":{"id":"bcd91fbe-d7b7-42e5-817a-dde056786718","version":2,"type":"sub_header","properties":{"title":[["goroutine实现"]]},"created_time":1661556706155,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"fd04136b-3fca-4e06-b420-1acb1f1e4c9b":{"role":"reader","value":{"id":"fd04136b-3fca-4e06-b420-1acb1f1e4c9b","version":2,"type":"text","properties":{"title":[["golang语言中的goroutine也是一个有栈协程，但是和本文讲到的coroutine还是有很大不同，首先golang有自己的协程调度器，而且golang的协程是抢占式执行的，关于golang的协程要写的东西还是太多了，得再开一篇文章讨论，大家可以阅读下面的文章有个深入的了解。"]]},"created_time":1661556706155,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"6a98cd37-4a7a-4f25-93e7-2bbc8b6b2112":{"role":"reader","value":{"id":"6a98cd37-4a7a-4f25-93e7-2bbc8b6b2112","version":2,"type":"text","properties":{"title":[["深入golang-runtime的调度",[["a","https://zboya.github.io/post/go_scheduler/#%E6%B7%B1%E5%85%A5golang-runtime%E7%9A%84%E8%B0%83%E5%BA%A6"]]]]},"created_time":1661556706155,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"e90453a6-2572-4b13-a863-fb9614226ac9":{"role":"reader","value":{"id":"e90453a6-2572-4b13-a863-fb9614226ac9","version":2,"type":"sub_header","properties":{"title":[["参考文献"]]},"created_time":1661556706155,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"2abd4881-33d4-45c2-8ba0-94dae3f3020f":{"role":"reader","value":{"id":"2abd4881-33d4-45c2-8ba0-94dae3f3020f","version":2,"type":"numbered_list","properties":{"title":[["Operating Systems",[["a","https://book.douban.com/subject/19973015/"]]]]},"created_time":1661556706155,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"2b574031-7130-4de5-b0a6-a34c9ab0c10a":{"role":"reader","value":{"id":"2b574031-7130-4de5-b0a6-a34c9ab0c10a","version":2,"type":"numbered_list","properties":{"title":[["程序员的自我修养",[["a","https://book.douban.com/subject/3652388/"]]]]},"created_time":1661556706155,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}}},"space":{},"collection":{},"collection_view":{},"notion_user":{},"collection_query":{},"signed_urls":{},"preview_images":{}},"pageId":"091a74ac-4142-4f28-ba1d-5c9810ccc648"},"__N_SSG":true}