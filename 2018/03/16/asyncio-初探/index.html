<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> asyncio中使用阻塞函数 · yangsoon</title><meta name="description" content="asyncio中使用阻塞函数 - yangs"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://yangsoon.github.io/atom.xml" title="yangsoon"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/yangsoon" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="https://www.zhihu.com/people/song-yang-91-69/activities" target="_blank" class="nav-list-link">ZHIHU</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">asyncio中使用阻塞函数</h1><div class="post-info">2018年3月16日</div><div class="post-content"><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>最近在学习python的异步编程标准库asyncio，在学习期间，想到如果想要在asyncio中使用阻塞的函数调用，但是不阻塞事件循环的当前线程，应该怎么操作？<br><br>例如我想在asyncio中使用第三方阻塞调用库requests(当然现在有支持异步操作的aiohttp)，或者是想用一些费时的函数计算，亦或是进行io读写。</p>
<a id="more"></a>
<h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>在《流畅的python》中有这样一段话。</p>
<blockquote>
<p>函数(例如io读写，requests网络请求)阻塞了客户代码与asycio事件循环的唯一线程，因此在执行调用时，整个应用程序都会冻结。这个问题的解决方法是，使用事件循环对象的 <code>run_in_executor</code>方法。asyncio的事件循环在背后维护着一个<code>ThreadPoolExecutor</code>对象，我们可以调用<code>run_in_executor</code>方法，把可调用对象发给它执行。</p>
</blockquote>
<p>这样我们就知道了我们可以通过<code>run_in_executor</code>方法来新建一个线程来执行耗时函数。</p>
<h3 id="函数讲解"><a href="#函数讲解" class="headerlink" title="函数讲解"></a>函数讲解</h3><p>因为书中对<code>run_in_executor</code>函数的介绍很少，所以我们先查阅一下<a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.run_in_executor" target="_blank" rel="noopener">官方文档</a>来看一下<code>run_in_executor</code>函数的具体使用方法。</p>
<p>根据官方文档我们可以知道该方法返回一个协程<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AbstractEventLoop.run_in_executor(executor, func, *args)</span><br><span class="line">executor 参数应该是一个 Executor 实例。如果为 <span class="keyword">None</span>，则使用默认 executor。</span><br><span class="line">func 就是要执行的函数</span><br><span class="line">*args 就是传递给 func 的参数</span><br></pre></td></tr></table></figure></p>
<h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><p>下面我们就用一个简单的例子来演示一下如何使用，通过输出结果我们可以看出5个阻塞调用同时进行，在5秒后所有调用结束。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep, strftime</span><br><span class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</span><br><span class="line"></span><br><span class="line">executor = futures.ThreadPoolExecutor(max_workers=<span class="number">5</span>)</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">blocked_sleep</span><span class="params">(name, t)</span>:</span></span><br><span class="line">    print(strftime(<span class="string">'[%H:%M:%S]'</span>),end=<span class="string">' '</span>)</span><br><span class="line">    print(<span class="string">'sleep &#123;&#125; is running &#123;&#125;s'</span>.format(name, t))</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    <span class="keyword">await</span> loop.run_in_executor(executor, sleep, t)</span><br><span class="line">    print(strftime(<span class="string">'[%H:%M:%S]'</span>),end=<span class="string">' '</span>)</span><br><span class="line">    print(<span class="string">'sleep &#123;&#125; is end'</span>.format(name))</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    future = (blocked_sleep(i, i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">6</span>))</span><br><span class="line">    fs = asyncio.gather(*future)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> fs</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">results = loop.run_until_complete(main())</span><br><span class="line">print(<span class="string">'results: &#123;&#125;'</span>.format(results))</span><br></pre></td></tr></table></figure></p>
<p>输出结果是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[19:49:32] sleep 3 is running 3s</span><br><span class="line">[19:49:32] sleep 4 is running 4s</span><br><span class="line">[19:49:32] sleep 1 is running 1s</span><br><span class="line">[19:49:32] sleep 5 is running 5s</span><br><span class="line">[19:49:32] sleep 2 is running 2s</span><br><span class="line">[19:49:33] sleep 1 is end</span><br><span class="line">[19:49:34] sleep 2 is end</span><br><span class="line">[19:49:35] sleep 3 is end</span><br><span class="line">[19:49:36] sleep 4 is end</span><br><span class="line">[19:49:37] sleep 5 is end</span><br><span class="line">result: [1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure>
<p><code>strftime</code>函数是为了格式化输出当前时间，比较清楚的看到调用过程。<code>blocked_sleep</code>函数通过使用<code>run_in_executor</code>方法调用阻塞的sleep()函数。</p>
<p>在官网中有这样<a href="https://docs.python.org/3/library/asyncio-task.html#coroutines" target="_blank" rel="noopener">一段话</a> 调用协程不会使其中的代码运行，协程对象在被排定执行时间之前都不会进行任何操作。下面有两种基本的方式来启动它的运行:</p>
<ol>
<li>在另一个协程中调用 <code>await coroutine</code> 和 <code>yield from coroutine</code> (假定另一个协程已经在执行，即在事件循环中) </li>
<li>使用 <code>ensure_future</code> 函数或 <code>AbstractEventLoop.create_task</code> 方法来排定执行时间。 </li>
</ol>
<p>根据上面的函数讲解我们已经知道<code>run_in_executor</code>方法返回一个协程。因此我们在<code>blocked_sleep</code>函数中驱动他的执行。</p>
<p>在main函数中<code>future = (blocked_sleep(i, i) for i in range(1, 6))</code>我们产生一个生成器表达式，每个元素都是一个协程。我们将future传递给gather函数。</p>
<p>对于gather函数的使用方法如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">asyncio.gather(*coros_or_futures, loop=<span class="keyword">None</span>, return_exceptions=<span class="keyword">False</span>)</span><br><span class="line">你现在知道gather返回一个包含future对象结果的list即可</span><br></pre></td></tr></table></figure>
<p>python从3.5开始就引入了新的语法 async 和 await 但是之前因为使用yield from习惯了，所以下面来一个之前的版本。大致上和上面的例子一样，有兴趣可以看一下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep, strftime</span><br><span class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">blocked</span><span class="params">(t)</span>:</span></span><br><span class="line">    print(strftime(<span class="string">'[%H:%M:%S]'</span>),end=<span class="string">' '</span>)</span><br><span class="line">    print(<span class="string">'&#123;&#125; sleep:&#123;&#125;s....'</span>.format(t, t))</span><br><span class="line">    sleep(t)</span><br><span class="line">    print(strftime(<span class="string">'[%H:%M:%S]'</span>),end=<span class="string">' '</span>)</span><br><span class="line">    print(<span class="string">'&#123;&#125; finished'</span>.format(t))</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">    </span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">with</span> futures.ThreadPoolExecutor(max_workers=<span class="number">5</span>) <span class="keyword">as</span> executor:</span><br><span class="line">        loop = asyncio.get_event_loop()</span><br><span class="line">        future = [loop.run_in_executor(executor,blocked, i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">6</span>)]</span><br><span class="line">        fs = asyncio.wait(future)</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">yield</span> <span class="keyword">from</span> fs)</span><br><span class="line">        </span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">results, _ = loop.run_until_complete(main())</span><br><span class="line">print(<span class="string">'results: &#123;&#125;'</span>.format([result.result() <span class="keyword">for</span> result <span class="keyword">in</span> results]))</span><br></pre></td></tr></table></figure>
<p>输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[20:18:13] 1 sleep:1s....</span><br><span class="line">[20:18:13] 2 sleep:2s....</span><br><span class="line">[20:18:13] 3 sleep:3s....</span><br><span class="line">[20:18:13] 4 sleep:4s....</span><br><span class="line">[20:18:13] 5 sleep:5s....</span><br><span class="line">[20:18:14] 1 finished</span><br><span class="line">[20:18:15] 2 finished</span><br><span class="line">[20:18:16] 3 finished</span><br><span class="line">[20:18:17] 4 finished</span><br><span class="line">[20:18:18] 5 finished</span><br><span class="line">results: [3, 2, 1, 4, 5]</span><br></pre></td></tr></table></figure></p>
<p>在第二份代码里，我故意使用wait函数来等待任务结束，是为了记录一下不同的函数调用方法，和gather函数不同，wait函数需要传入一个list，并且返回两组Futures，(done, pending)。这就是为什么代码里使用 <code>results, _ = loop.run_until_complete(main())</code>的原因了。</p>
<p>下面是一个使用<code>asyncio.as_comleted</code>方法的例子，该方法返回一个协程迭代器。迭代时迭代器只返回已经完成的future。<a href="https://github.com/python/cpython/blob/3.6/Lib/asyncio/tasks.py#L412" target="_blank" rel="noopener">源码</a>中内部维护一个队列，每次迭代都从队列中返回已经完成的future的结果(result or exception)，可以注意到在输出结果中，7秒后，所以任务才完成。因为executor大小设置为5，每次只有5个线程在跑，所以在第一个block运行结束后，我们可以看到第6个block立即执行。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep, strftime</span><br><span class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">blocked</span><span class="params">(t)</span>:</span></span><br><span class="line">    print(strftime(<span class="string">'[%H:%M:%S]'</span>),end=<span class="string">' '</span>)</span><br><span class="line">    print(<span class="string">'&#123;&#125; sleep:&#123;&#125;s....'</span>.format(t, t))</span><br><span class="line">    sleep(t)</span><br><span class="line">    print(strftime(<span class="string">'[%H:%M:%S]'</span>),end=<span class="string">' '</span>)</span><br><span class="line">    print(<span class="string">'&#123;&#125; finished'</span>.format(t))</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">with</span> futures.ThreadPoolExecutor(max_workers=<span class="number">5</span>) <span class="keyword">as</span> executor:</span><br><span class="line">        loop = asyncio.get_event_loop()</span><br><span class="line">        future = [loop.run_in_executor(executor,blocked, i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">7</span>)]</span><br><span class="line">        fs = asyncio.as_completed(future)</span><br><span class="line">        results = []</span><br><span class="line">        <span class="keyword">for</span> f <span class="keyword">in</span> fs:</span><br><span class="line">            result = <span class="keyword">yield</span> <span class="keyword">from</span> f</span><br><span class="line">            results.append(result)</span><br><span class="line">        <span class="keyword">return</span> results</span><br><span class="line">  </span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">results= loop.run_until_complete(main())</span><br><span class="line">print(<span class="string">'results: &#123;&#125;'</span>.format(results))</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[13:42:39] 1 sleep:1s....</span><br><span class="line">[13:42:39] 2 sleep:2s....</span><br><span class="line">[13:42:39] 3 sleep:3s....</span><br><span class="line">[13:42:39] 4 sleep:4s....</span><br><span class="line">[13:42:39] 5 sleep:5s....</span><br><span class="line">[13:42:40] 1 finished</span><br><span class="line">[13:42:40] 6 sleep:6s....</span><br><span class="line">[13:42:41] 2 finished</span><br><span class="line">[13:42:42] 3 finished</span><br><span class="line">[13:42:43] 4 finished</span><br><span class="line">[13:42:44] 5 finished</span><br><span class="line">[13:42:46] 6 finished</span><br><span class="line">results: [1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在asyncio中调用阻塞函数时，需要使用asyncio维护的线程池来另开线程运行阻塞函数，防止阻塞事件循环所在的线程。</p>
<p>几个重要函数比较</p>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">传参</th>
<th style="text-align:left">返回值</th>
<th style="text-align:left">返回值顺序</th>
<th style="text-align:left"></th>
<th>函数意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>asyncio.gather</code></td>
<td style="text-align:left">可以传递多个协程或者Futures，函数会自动将协程包装成task，例如协程生成器。</td>
<td style="text-align:left">包含Futures结果的list</td>
<td style="text-align:left">按照原始顺序排列</td>
<td style="text-align:left"></td>
<td>注重收集结果，等待一堆Futures并按照顺序返回结果</td>
</tr>
<tr>
<td style="text-align:left"><code>asyncio.wait</code></td>
<td style="text-align:left">a list of futures</td>
<td style="text-align:left">返回两个Future集合 (done, pending)</td>
<td style="text-align:left">无序(暂定)</td>
<td style="text-align:left"></td>
<td>是一个协程等传给他的所有协程都运行完之后结束，并不直接返回结果</td>
</tr>
<tr>
<td style="text-align:left"><code>asyncio.as_completed</code></td>
<td style="text-align:left">a list of futures</td>
<td style="text-align:left">返回一个协程迭代器</td>
<td style="text-align:left">按照完成顺序</td>
<td style="text-align:left"></td>
<td>返回的迭代器每次迭代只返回已经完成的Futures</td>
</tr>
</tbody>
</table>
</div></article></div></main><footer><div class="paginator"><a href="/2018/03/17/apollo主题下使用gitment/" class="prev">上一篇</a><a href="/2018/03/15/python-学习笔记/" class="next">下一篇</a></div><div id="container"></div><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var gitment = new Gitment({
    id: 'Fri Mar 16 2018 19:11:23 GMT+0800',
    owner: 'yangsoon',
    repo: 'yangsoon.github.io',
    oauth: {
        client_id: 'c6e81705ee274d631d1d',
        client_secret: 'd2366443245bc5528fc5a73af235d9e23d14e33a',
    },
})
gitment.render('container')</script><div class="copyright"><p>© 2017 - 2018 <a href="https://yangsoon.github.io">yangs</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><!-- - LaTex--><script type="text/x-mathjax-config">MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});</script><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-124338187-2",'auto');ga('send','pageview');</script></body></html>