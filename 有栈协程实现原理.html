<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="robots" content="index,follow"/><meta property="og:type" content="website"/><meta name="google-site-verification" content="_OJuJrMAK0_lxr0--eH6RZyMOn2Mg_zY1hDyBBKU8fI"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-Y4TMBBH2RZ"></script><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-Y4TMBBH2RZ', {
                page_path: window.location.pathname,
              });
          </script><meta property="og:site_name" content="YangSoon"/><meta property="twitter:domain" content="yangsoon.github.io"/><meta name="twitter:creator" content="@yangsoonlx"/><meta name="description" content="YangSoon, Cloud Native Developer"/><meta property="og:description" content="YangSoon, Cloud Native Developer"/><meta name="twitter:description" content="YangSoon, Cloud Native Developer"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:image" content="https://yangsoon.github.io/api/social-image?id=091a74ac-4142-4f28-ba1d-5c9810ccc648"/><meta property="og:image" content="https://yangsoon.github.io/api/social-image?id=091a74ac-4142-4f28-ba1d-5c9810ccc648"/><link rel="canonical" href="https://yangsoon.github.io/有栈协程实现原理"/><meta property="og:url" content="https://yangsoon.github.io/有栈协程实现原理"/><meta property="twitter:url" content="https://yangsoon.github.io/有栈协程实现原理"/><link rel="alternate" type="application/rss+xml" href="https://yangsoon.github.io/feed" title="YangSoon"/><meta property="og:title" content="有栈协程实现原理"/><meta name="twitter:title" content="有栈协程实现原理"/><title>有栈协程实现原理</title><meta name="next-head-count" content="24"/><link rel="shortcut icon" href="/favicon.ico"/><link rel="icon" type="image/png" sizes="32x32" href="favicon.png"/><link rel="manifest" href="/manifest.json"/><link rel="preload" href="/_next/static/css/836d11bb8e359ad4.css" as="style"/><link rel="stylesheet" href="/_next/static/css/836d11bb8e359ad4.css" data-n-g=""/><link rel="preload" href="/_next/static/css/1d993c1b8c3f1e3a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/1d993c1b8c3f1e3a.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script defer="" src="/_next/static/chunks/358.0027340467b29549.js"></script><script src="/_next/static/chunks/webpack-d0f6f9fb604748c4.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-f08b69bdcc7bbb61.js" defer=""></script><script src="/_next/static/chunks/pages/_app-e341ab6855f9c9f4.js" defer=""></script><script src="/_next/static/chunks/446-7f8c1bd499453c43.js" defer=""></script><script src="/_next/static/chunks/642-47a19f0a55eb6073.js" defer=""></script><script src="/_next/static/chunks/pages/%5BpageId%5D-69b62fc61f7d7f72.js" defer=""></script><script src="/_next/static/WsfZtM41_p-Eb0XA4aeJC/_buildManifest.js" defer=""></script><script src="/_next/static/WsfZtM41_p-Eb0XA4aeJC/_ssgManifest.js" defer=""></script></head><body><script>
/** Inlined version of noflash.js from use-dark-mode */
;(function () {
  var storageKey = 'darkMode'
  var classNameDark = 'dark-mode'
  var classNameLight = 'light-mode'
  function setClassOnDocumentBody(darkMode) {
    document.body.classList.add(darkMode ? classNameDark : classNameLight)
    document.body.classList.remove(darkMode ? classNameLight : classNameDark)
  }
  var preferDarkQuery = '(prefers-color-scheme: dark)'
  var mql = window.matchMedia(preferDarkQuery)
  var supportsColorSchemeQuery = mql.media === preferDarkQuery
  var localStorageTheme = null
  try {
    localStorageTheme = localStorage.getItem(storageKey)
  } catch (err) {}
  var localStorageExists = localStorageTheme !== null
  if (localStorageExists) {
    localStorageTheme = JSON.parse(localStorageTheme)
  }
  // Determine the source of truth
  if (localStorageExists) {
    // source of truth from localStorage
    setClassOnDocumentBody(localStorageTheme)
  } else if (supportsColorSchemeQuery) {
    // source of truth from system
    setClassOnDocumentBody(mql.matches)
    localStorage.setItem(storageKey, mql.matches)
  } else {
    // source of truth from document.body
    var isDarkMode = document.body.classList.contains(classNameDark)
    localStorage.setItem(storageKey, JSON.stringify(isDarkMode))
  }
})();
</script><div id="__next"><div class="notion notion-app light-mode notion-block-091a74ac41424f28ba1d5c9810ccc648"><div class="notion-viewport"></div><div class="notion-frame"><header class="notion-header"><div class="notion-nav-header"><div class="breadcrumbs"><a class="breadcrumb" href="/"><div class="notion-page-icon-inline notion-page-icon-image"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27688%27%20height=%27689%27/%3e"/></span><img alt="yangsoon ‘s blog" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="icon notion-page-icon" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;background-size:cover;background-position:0% 0%;filter:blur(20px);background-image:url(&quot;data:image/webp;base64,UklGRmoAAABXRUJQVlA4IF4AAABQAgCdASoQABAABUB8JbACdH8AF6kqWZq7wgAA/tFZccfpD5SaLC06Ab1xNlhuQgaC2peDlG2wJ+PIWe8AtNjEYYN+9hybVKfEbmvVGYOWRzw8xmakIGSWE0zkkYAA&quot;)"/><noscript><img alt="yangsoon ‘s blog" src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F37907dd5-3c76-4966-a419-daa027a84972%2FIMG_2189.jpg?table=block&amp;id=72a66971-7cf6-42c2-a252-4439d99d8f44&amp;cache=v2" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%" class="icon notion-page-icon" loading="lazy"/></noscript></span></div><span class="title">yangsoon ‘s blog</span></a></div><div class="notion-nav-header-rhs breadcrumbs"><a href="/about" class="breadcrumb button">About</a><div class="breadcrumb button styles_hidden__7gYve"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="32" d="M256 48v48m0 320v48m147.08-355.08l-33.94 33.94M142.86 369.14l-33.94 33.94M464 256h-48m-320 0H48m355.08 147.08l-33.94-33.94M142.86 142.86l-33.94-33.94"></path><circle cx="256" cy="256" r="80" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="32"></circle></svg></div></div></div></header><div class="notion-page-scroller"><main class="notion-page notion-page-no-cover notion-page-has-icon notion-page-has-image-icon notion-full-page notion-small-text"><div class="notion-page-icon-hero notion-page-icon-image"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27300%27%20height=%27300%27/%3e"/></span><img alt="有栈协程实现原理" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="notion-page-icon" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;background-size:cover;background-position:0% 0%;filter:blur(20px);background-image:url(&quot;data:image/webp;base64,UklGRogAAABXRUJQVlA4IHwAAADQAgCdASoQABAABUB8JbACdLoBEgJYA3hwE060yiUAAPniKR3//rNoOA5ydw/LvYqgV0qR2DrsJmjDGyD2KmZqxz5/S3m+qLbmRvFHdFy9Ts/7z+ptWH5IOU9WRTwIRj6LWzl0y0iuMboS/pwOogpygAqWCKxnHeVh5dAA&quot;)"/><noscript><img alt="有栈协程实现原理" src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fefaf9256-833c-41b8-a88d-7466ca5ceeb9%2Fsrchttp___img.pconline.com.cn_images_nospd_upload_upc_tx_pcdlc_2108_16_c7_274750145_1629102176621.pngreferhttp___img.pconline.com.webp?table=block&amp;id=091a74ac-4142-4f28-ba1d-5c9810ccc648&amp;cache=v2" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%" class="notion-page-icon" loading="lazy"/></noscript></span></div><h1 class="notion-title"><b>有栈协程实现原理</b></h1><div class="notion-page-content notion-page-content-has-aside notion-page-content-has-toc"><article class="notion-page-content-inner"><div class="notion-text notion-block-fa1c33578d6649c7b61e4d3d69346323">本文主要讲解有栈协程的实现原理，以云风实现的coroutine为例。</div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-053a49205603423b9ade546274c449e8" data-id="053a49205603423b9ade546274c449e8"><span><div id="053a49205603423b9ade546274c449e8" class="notion-header-anchor"></div><a class="notion-hash-link" href="#053a49205603423b9ade546274c449e8" title="协程"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">协程</span></span></h3><div class="notion-text notion-block-57c53ccaff1b40e9bb07727965277060">关于协程的概念，在网上没有找到比较通俗的解释，下面就说说个人的理解，(有栈)协程可以理解为一个用户态下的线程，在用户态下进行线程（协程）的上下文切换。但是和传统的线程不同的是：线程是抢占式执行，当发生系统调用或者中断的时候，交由OS调度执行；而协程是通过yield主动让出cpu所有权，切换到其他协程执行。</div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-1b3e9d750f6245109d37cff48a0ef8b1" data-id="1b3e9d750f6245109d37cff48a0ef8b1"><span><div id="1b3e9d750f6245109d37cff48a0ef8b1" class="notion-header-anchor"></div><a class="notion-hash-link" href="#1b3e9d750f6245109d37cff48a0ef8b1" title="进程、线程"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">进程、线程</span></span></h3><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-0bf3a3cece50468aa7b47572bc7f1950" data-id="0bf3a3cece50468aa7b47572bc7f1950"><span><div id="0bf3a3cece50468aa7b47572bc7f1950" class="notion-header-anchor"></div><a class="notion-hash-link" href="#0bf3a3cece50468aa7b47572bc7f1950" title="进程地址空间"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">进程地址空间</span></span></h4><div class="notion-text notion-block-eaa93a3a20d54bc88b0616af7753d5df">一般来说一个进程的地址空间有这几个默认区域:</div><ol start="1" class="notion-list notion-list-numbered notion-block-c4b4cc2088084229b76eb2c220ea8819"><li>栈：栈用于维护函数调用的上下文，包括函数的参数，局部变量等等。</li></ol><ol start="2" class="notion-list notion-list-numbered notion-block-80e01be4edc742ac88dcd44c0022b938"><li>堆：用来容纳程序中动态分配的内存区域，当程序使用malloc和new分配的内存就来自于堆里</li></ol><ol start="3" class="notion-list notion-list-numbered notion-block-78c54cf6c4c345e5a965841a0c9215bd"><li>可执行文件映像。</li></ol><ol start="4" class="notion-list notion-list-numbered notion-block-582af19c48774609b669dea8e1fe3466"><li>保留区，是对内存中受到保护而禁止访问的内存区域的总称。</li></ol><div class="notion-text notion-block-674b8f34799a486a9368a3c70263d731">下图是linux下一个进程的典型内存布局: 在经典的操作系统中，栈总是 <b>向下增长</b> ，从高地址向低地址增长，其中栈顶指针存储在 <b>[E|R]SP</b> 寄存器中，而堆则总是 <b>向上增长</b> ，从低地址向高地址增长。</div><div class="notion-text notion-block-b44648ac613f4eae877cff22c079e520"></div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-ac6a02ffa1a94a4db2103f40fd667c84"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:480px;max-width:100%;flex-direction:column"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27619%27%20height=%27661%27/%3e"/></span><img alt="notion image" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover;background-size:cover;background-position:0% 0%;filter:blur(20px);background-image:url(&quot;data:image/webp;base64,UklGRqgAAABXRUJQVlA4WAoAAAAQAAAADgAADwAAQUxQSDMAAAARHyAQICSY8p9kIyKCEwph24quUQpJ5JPE5ymJL9O+pxDR/wkAiD1gnV7kohf50oNPhh0AVlA4IE4AAADwAQCdASoPABAABUB8JaQAAutGoKpVACAA/sbs09pMqec2+5VB8bhHjWHUUcPQUb/plDIax+e3PgpELzTyatlp7I8HBN6YPOS6tRGEwAA=&quot;)"/><noscript><img alt="notion image" src="https://www.notion.so/image/https%3A%2F%2Fuser-images.githubusercontent.com%2F29531394%2F69554356-a42f3380-0fdc-11ea-9cf6-21c7d4b62bcc.png?table=block&amp;id=ac6a02ff-a1a9-4a4d-b210-3f40fd667c84&amp;cache=v2" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover" loading="lazy"/></noscript></span></div></figure><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-7d7ba4e877a142acac74ecaeb6ba6c99" data-id="7d7ba4e877a142acac74ecaeb6ba6c99"><span><div id="7d7ba4e877a142acac74ecaeb6ba6c99" class="notion-header-anchor"></div><a class="notion-hash-link" href="#7d7ba4e877a142acac74ecaeb6ba6c99" title="栈的增长方式"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">栈的增长方式</span></span></h4><div class="notion-text notion-block-47b81bd6877c4a0cb71e414cb56d1665">栈在程序运行中具有举足轻重的地位，最重要的，栈保存了一个函数调用所需要维护的信息，这常常被称为<b>堆栈帧</b>，堆栈帧一般包括下面几方面内容：</div><ol start="1" class="notion-list notion-list-numbered notion-block-f2e65cac34494d0fbb72f1aa748b9ddb"><li>函数的返回地址和参数</li></ol><ol start="2" class="notion-list notion-list-numbered notion-block-12cfdaf214e047208af432f69336d87d"><li>临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量</li></ol><ol start="3" class="notion-list notion-list-numbered notion-block-010204f74312449e8d7b2c647fa7aca2"><li>保存的上下文：包括在函数调用前后需要保存不变的寄存器的值</li></ol><div class="notion-text notion-block-098d17c4973d4986a38b9bc724c172ef">一个函数的堆栈帧用 <b>[E|R]SP,[E|R]BP</b> ，这两个寄存器划定范围，<b>[E|R]SP</b>始终指向栈顶的位置称为栈指针寄存器，<b>[E|R]SP</b>指向堆栈帧的一个固定位置，<b>[E|R]SP</b> 又被称为帧指针，一般函数中的局部变量靠 <b>[E|R]SP</b> 加上偏移量寻找。</div><blockquote class="notion-quote notion-block-dff2befb112a460c9ed3df3e39f50182"><div>[E|R]SP表示esp或者rsp寄存器，esp表示32位x86架构下的栈指针寄存器，rsp表示64位x86架构下的栈指针寄存器，同理于[E|R]BP。 帧指针并不是必须的, x86-64过程中的栈帧通常有固定的大小，在调用过程中栈指针保持固定的位置，使得可以通过相对于栈指针的偏移量来访问数据^1。</div></blockquote><div class="notion-text notion-block-177caef2deb24f19ad1bb7f5a8bcf401">下面我们就简单讲解一下当程序调用一个简单的函数时，线程中的栈是如何增长的。假设有一个foo函数</div><pre class="notion-code"><div class="notion-code-copy"><div class="notion-code-copy-button"><svg fill="currentColor" viewBox="0 0 16 16" width="1em" version="1.1"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg></div></div><code class="language-c">int foo(int m, int n){
  int a = 0; // #i
  ....
}
</code></pre><div class="notion-text notion-block-09acbf6cf4224723bbeb4e4e916b7170">该函数对应的堆栈帧的内存空间如下所示，一个函数的堆栈帧增长过程是这样的：</div><ol start="1" class="notion-list notion-list-numbered notion-block-780e6ecab0414bf2bfb4d115c10097e2"><li>把所有或一部分参数加入栈中，如果有其他参数没有入栈，那么使用某些寄存器传递</li></ol><ol start="2" class="notion-list notion-list-numbered notion-block-91243b2448014c779e9ce5d05b98d66a"><li>把当前指令的下一条指令地址压入栈中</li></ol><ol start="3" class="notion-list notion-list-numbered notion-block-ba511ef4cd7449739aa9af7ee9d2483c"><li>跳转到函数体执行:</li><ol class="notion-list notion-list-numbered notion-block-ba511ef4cd7449739aa9af7ee9d2483c"><li>把[e|r]bp压入栈中，指向上一个函数堆栈帧中的帧指针的位置</li><li>保存调用前后需要保存不变的寄存器的值</li><li>将局部变量压入栈中</li><div class="notion-text notion-block-a3450908ce0548bab0e62b0ea6fc3813">...</div></ol></ol><div class="notion-text notion-block-01bc0475504f48d1b921a2cd8ca652f2">当函数调用返回之后，相应的函数堆栈帧也会弹出，弹出的流程不是本篇文章的重点，在此就不详细讲解，感兴趣的推荐看 <b>程序员的自我修养</b> 中讲解堆栈的部分。</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-7d97a16b9fcc435d9fb48e6453129f37"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:528px;max-width:100%;flex-direction:column"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27730%27%20height=%27595%27/%3e"/></span><img alt="notion image" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover;background-size:cover;background-position:0% 0%;filter:blur(20px);background-image:url(&quot;data:image/webp;base64,UklGRqQAAABXRUJQVlA4WAoAAAAQAAAADwAADAAAQUxQSD8AAAARL0AWYBqcxATqTKWICHw6MIQk2dU8g12HJxABflB4/jAZIaL/E8DF9P9xeHpvAwqMkj0LArxA8soLAbYnIAMAVlA4ID4AAACQAQCdASoQAA0ABUB8JaQAAxOugwAA/iP13arNx8635mco3NDCVXFs1PDCgj30VAFzg8swIJ4QlGbSAAAAAA==&quot;)"/><noscript><img alt="notion image" src="https://www.notion.so/image/https%3A%2F%2Fuser-images.githubusercontent.com%2F29531394%2F69641429-2847f080-109b-11ea-80fa-fab3c148dba6.png?table=block&amp;id=7d97a16b-9fcc-435d-9fb4-8e6453129f37&amp;cache=v2" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover" loading="lazy"/></noscript></span></div></figure><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-edfe5570b46948acbacee9ffe3650f54" data-id="edfe5570b46948acbacee9ffe3650f54"><span><div id="edfe5570b46948acbacee9ffe3650f54" class="notion-header-anchor"></div><a class="notion-hash-link" href="#edfe5570b46948acbacee9ffe3650f54" title="线程"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">线程</span></span></h4><div class="notion-text notion-block-9471b13e899c4902a3ee7c43b5b1bb4a">一个标准的线程由线程id、程序计数器(PC)、寄存器集合和栈组成。</div><div class="notion-text notion-block-5ab357cec62a4d0f87c684ead807b96c">每个线程类似一个独立进程，不同的是线程之间共享地址空间，能够访问到相同的数据。线程之间共享进程的内存空间(包括代码段、数据段、堆等)以及以下进程级的资源（如打开文件和信号）。</div><div class="notion-text notion-block-4bc00fd179fe43a3a5ca27d6c7abbfd0">一个经典的进程和线程的关系如下图所示：</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-6318cf5693de4904b90e0234105865a7"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:528px;max-width:100%;flex-direction:column"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27842%27%20height=%27595%27/%3e"/></span><img alt="notion image" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover;background-size:cover;background-position:0% 0%;filter:blur(20px);background-image:url(&quot;data:image/webp;base64,UklGRooAAABXRUJQVlA4WAoAAAAQAAAADwAACgAAQUxQSEsAAAARL6C2bRsWe+tJRARq9sEQkmRXg/D3nsCFJ5C+QCL4/jjfIaL/yV9ykyDW6NMgVtZVEGvWLBjvdX4dVLIIUEYbBsp1Pw2kKAngaAAAVlA4IBgAAAAwAQCdASoQAAsABUB8JaQAA3AA/vDmwAA=&quot;)"/><noscript><img alt="notion image" src="https://www.notion.so/image/https%3A%2F%2Fuser-images.githubusercontent.com%2F29531394%2F69556981-be6b1080-0fe0-11ea-8f46-9ef60c77f161.png?table=block&amp;id=6318cf56-93de-4904-b90e-0234105865a7&amp;cache=v2" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover" loading="lazy"/></noscript></span></div></figure><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-540d0eb1f3fc424fafa376e2181a02c3" data-id="540d0eb1f3fc424fafa376e2181a02c3"><span><div id="540d0eb1f3fc424fafa376e2181a02c3" class="notion-header-anchor"></div><a class="notion-hash-link" href="#540d0eb1f3fc424fafa376e2181a02c3" title="线程上下文切换"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">线程上下文切换</span></span></h4><div class="notion-text notion-block-b448464656324371b39d5eef692ceb67">假设有2个线程运行在一个处理器上，从运行一个线程(T1)切换到另一个线程(T2)时，一定会发生上下文切换。对于进程，我们需要将状态保存到进程控制块(PCB)中，现在我们需要一个或多个线程控制块(TCB)来保存每个线程的状态，但是和进程上下文切换相比，线程在进行上下文切换的时候<b>地址空间保持不变</b>(即不需要切换当前使用的页表)。一个拥有多线程的进程的地址空间，如下图所示，我们可以看到每个线程拥有有自己的栈。</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-d9deb8e740c74fe48eb0bfb752060fdd"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:432px;max-width:100%;flex-direction:column"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27476%27%20height=%27595%27/%3e"/></span><img alt="notion image" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover;background-size:cover;background-position:0% 0%;filter:blur(20px);background-image:url(&quot;data:image/webp;base64,UklGRtIAAABXRUJQVlA4WAoAAAAQAAAADAAADwAAQUxQSEYAAAARL0AWYBqcyBjqzqCICHxWMIhsq8o+KOAzCjRwaOC8/mH8Rojo/wR4GZK8clZVZ4w5GgQca63GWVX9tzHn3CEgr8iMy5YAVlA4IGYAAAAwAgCdASoNABAABUB8JaQAD4/QcnUXphhgAAD2diNmVipdFFv+rBSPpMFudUL0vfcYZAFBQiXBjqAn5fvJ2p+k19bq5xHrU0IrB8cU3QzbCEa5VGFa699BrcAXwwa3kf0ftOE4AAA=&quot;)"/><noscript><img alt="notion image" src="https://www.notion.so/image/https%3A%2F%2Fuser-images.githubusercontent.com%2F29531394%2F69641464-372ea300-109b-11ea-9946-b107ad6f85d5.png?table=block&amp;id=d9deb8e7-40c7-4fe4-8eb0-bfb752060fdd&amp;cache=v2" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover" loading="lazy"/></noscript></span></div></figure><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-d1ecda807514440c8c23535297a6a91b" data-id="d1ecda807514440c8c23535297a6a91b"><span><div id="d1ecda807514440c8c23535297a6a91b" class="notion-header-anchor"></div><a class="notion-hash-link" href="#d1ecda807514440c8c23535297a6a91b" title="实现协程的理论依据"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">实现协程的理论依据</span></span></h4><div class="notion-text notion-block-87aeecae78574a4fb90d3d7a8e945deb">有栈协程就是实现了一个用户态的线程，用户可以在堆上模拟出协程的栈空间，当需要进行协程上下文切换的时候，主线程只需要交换栈空间和恢复协程的一些相关的寄存器的状态就可以实现一个用户态的线程上下文切换，没有了从用户态转换到内核态的切换成本，协程的执行也就更加高效。</div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-bd7e22a3e682479d8bd88fb0d4527d45" data-id="bd7e22a3e682479d8bd88fb0d4527d45"><span><div id="bd7e22a3e682479d8bd88fb0d4527d45" class="notion-header-anchor"></div><a class="notion-hash-link" href="#bd7e22a3e682479d8bd88fb0d4527d45" title="ucontext"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">ucontext</span></span></h3><div class="notion-text notion-block-406e6a66b1dd4932aa083b88d489fe5e">我们参考的协程实现是云风大佬编写的coroutine，源码只有不到200行，很适合用来阅读学习。在这个版本的coroutine中，使用ucontext族函数实现。我们先来简单的看一下这个函数族的基本功能。该部分参考自博客<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://blog.csdn.net/qq910894904/article/details/41911175">^2</a>。</div><div class="notion-text notion-block-58990965bc3c41c89038a68734fb08a4">在类System V环境中,在头文件<code class="notion-inline-code">&lt; ucontext.h &gt; </code> 中定义了两个结构类型，<code class="notion-inline-code">mcontext_t</code> 和 <code class="notion-inline-code">ucontext_t</code>和四个函数<code class="notion-inline-code">getcontext()</code><span style="padding:0.5em"></span><code class="notion-inline-code">setcontext()</code><span style="padding:0.5em"></span><code class="notion-inline-code">makecontext()</code><span style="padding:0.5em"></span><code class="notion-inline-code">swapcontext()</code>.利用它们可以在一个进程中实现用户级的线程切换。
<code class="notion-inline-code">ucontext_t</code> 结构体定义如下:</div><pre class="notion-code"><div class="notion-code-copy"><div class="notion-code-copy-button"><svg fill="currentColor" viewBox="0 0 16 16" width="1em" version="1.1"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg></div></div><code class="language-c">typedef struct ucontext {
  struct ucontext *uc_link;
  sigset_t         uc_sigmask;
  stack_t          uc_stack;
  mcontext_t       uc_mcontext;
  ...
} ucontext_t;
</code></pre><div class="notion-text notion-block-2e2ce2950cf94c66aef68aba7cc8f4eb">当当前上下文(如使用 <code class="notion-inline-code">makecontext</code> 创建的上下文）运行终止时系统会恢复<code class="notion-inline-code">uc_link</code>指向的上下文；<code class="notion-inline-code">uc_sigmask</code>为该上下文中的阻塞信号集合；<code class="notion-inline-code">uc_stack</code>为该上下文中使用的栈；<code class="notion-inline-code">uc_mcontext</code>保存的上下文的特定机器表示，包括调用线程的特定寄存器等。</div><div class="notion-text notion-block-74685b96c1894b3badc8cb907e50cca5">下面讲解四个函数的作用，详细的函数使用方法参考man手册:</div><ol start="1" class="notion-list notion-list-numbered notion-block-4ceedf7979f24612bbc7dbe08c086a41"><li>初始化ucp结构体，将当前的上下文保存到ucp中</li><ol class="notion-list notion-list-numbered notion-block-4ceedf7979f24612bbc7dbe08c086a41"><pre class="notion-code"><div class="notion-code-copy"><div class="notion-code-copy-button"><svg fill="currentColor" viewBox="0 0 16 16" width="1em" version="1.1"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg></div></div><code class="language-c">int getcontext(ucontext_t *ucp);
</code></pre></ol></ol><ol start="2" class="notion-list notion-list-numbered notion-block-4800343331c14af9ad2a48c27e804153"><li>修改用户线程的上下文指向参数ucp，在调用makecontext之前必须调用getcontext初始化一个ucp，并且需要分配一个栈空间给初始化后的ucp，当上下文通过setcontext或者swapcontext激活后，就会紧接着调用第二个参数指向的函数func，参数argc代表 func所需的参数，在调用makecontext之前你需要初始化参数ucp-&gt;uc_link，这个参数表示func()执行之后，用户线程将要切换到ucp-&gt;uc_link所代表的上下文，其实是隐式的调用了setcontext函数。</li><ol class="notion-list notion-list-numbered notion-block-4800343331c14af9ad2a48c27e804153"><pre class="notion-code"><div class="notion-code-copy"><div class="notion-code-copy-button"><svg fill="currentColor" viewBox="0 0 16 16" width="1em" version="1.1"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg></div></div><code class="language-c">void makecontext(ucontext_t *ucp, void (*func)(), int argc, ...);
</code></pre></ol></ol><ol start="3" class="notion-list notion-list-numbered notion-block-6883e37afadd43e3b77dbc09077f8f45"><li>设置当前的上下文为ucp，setcontext的上下文ucp应该通过getcontext或者makecontext取得，如果调用成功则不返回。</li><ol class="notion-list notion-list-numbered notion-block-6883e37afadd43e3b77dbc09077f8f45"><pre class="notion-code"><div class="notion-code-copy"><div class="notion-code-copy-button"><svg fill="currentColor" viewBox="0 0 16 16" width="1em" version="1.1"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg></div></div><code class="language-c">int setcontext(const ucontext_t *ucp);
</code></pre></ol></ol><ol start="4" class="notion-list notion-list-numbered notion-block-b648ed22db76471c85073d30eed58cb6"><li>保存当前上下文到oucp结构体中，然后激活upc上下文。</li></ol><pre class="notion-code"><div class="notion-code-copy"><div class="notion-code-copy-button"><svg fill="currentColor" viewBox="0 0 16 16" width="1em" version="1.1"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg></div></div><code class="language-c">int swapcontext(ucontext_t *oucp, ucontext_t *ucp);
</code></pre><div class="notion-text notion-block-aab791afe9354ebd8e0b343ac6a544c3">写个简单的例子来看一下如何使用：</div><pre class="notion-code"><div class="notion-code-copy"><div class="notion-code-copy-button"><svg fill="currentColor" viewBox="0 0 16 16" width="1em" version="1.1"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg></div></div><code class="language-c">#include &lt;ucontext.h&gt;
#include &lt;stdio.h&gt;

int func(void *arg) {
  puts(&quot;this is func&quot;);
}

void coroutine_test() {
  char stack[1024 * 128];
  ucontext_t child, main;
  // 获取当前上下文
  getcontext(&amp;child);

  // 分配栈空间 uc_stack.ss_sp 指向栈顶
  child.uc_stack.ss_sp = stack;
  child.uc_stack.ss_size = sizeof(stack);
  child.uc_stack.ss_flags = 0;
  // 指定后继上下文
  child.uc_link = &amp;main;
  // child.uc_link = NULL;

  makecontext(&amp;child, (void (*)(void))func, 0);

  //切换到child上下文，保存当前上下文到main
  swapcontext(&amp;main, &amp;child);
  // 如果设置了后继上下文，func函数指向完后会返回此处 如果设置为NULL，就不会执行这一步
  puts(&quot;this is coroutine_test&quot;);
}

int main() {
  coroutine_test();
  return 0;
}
</code></pre><div class="notion-text notion-block-1144815eb4a44ff2a5109512fae5d994">程序的执行结果为：</div><pre class="notion-code"><div class="notion-code-copy"><div class="notion-code-copy-button"><svg fill="currentColor" viewBox="0 0 16 16" width="1em" version="1.1"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg></div></div><code class="language-c">this is func
this is coroutine_test
</code></pre><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-a538893ad10a47ca929792840ebf55d8" data-id="a538893ad10a47ca929792840ebf55d8"><span><div id="a538893ad10a47ca929792840ebf55d8" class="notion-header-anchor"></div><a class="notion-hash-link" href="#a538893ad10a47ca929792840ebf55d8" title="coroutine实现"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">coroutine实现</span></span></h3><div class="notion-text notion-block-ed19cb986f5b456796da5accf18c3c19">本文不打算详细讲解coroutine的代码实现，具体的实现细节大家可以参考文章<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://zhuanlan.zhihu.com/p/84935949">^3</a>,本文的代码注释也来自这篇文章，建议看完本节之后再阅读该文章来了解代码实现细节。通过学习了前几节讲到的基础知识，相信大家能够比较轻松的看懂协程代码的实现。本小节主要从整体的角度来讲解coroutine的实现。</div><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-a889aa77b74441b7bed54cf9c2c34b33" data-id="a889aa77b74441b7bed54cf9c2c34b33"><span><div id="a889aa77b74441b7bed54cf9c2c34b33" class="notion-header-anchor"></div><a class="notion-hash-link" href="#a889aa77b74441b7bed54cf9c2c34b33" title="coroutine例子"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">coroutine例子</span></span></h4><pre class="notion-code"><div class="notion-code-copy"><div class="notion-code-copy-button"><svg fill="currentColor" viewBox="0 0 16 16" width="1em" version="1.1"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg></div></div><code class="language-c">#include &quot;coroutine.h&quot;
#include &lt;stdio.h&gt;

struct args {
	int n;
};

static void
foo(struct schedule * S, void *ud) {
	struct args * arg = ud;
	int start = arg-&gt;n;
	int i;
	for (i=0;i&lt;5;i++) {
		printf(&quot;coroutine %d : %d\\n&quot;,coroutine_running(S) , start + i);
		// 切出当前协程
		coroutine_yield(S);
	}
}

static void
test(struct schedule *S) {
	struct args arg1 = { 0 };
	struct args arg2 = { 100 };

	// 创建两个协程
	int co1 = coroutine_new(S, foo, &amp;arg1);
	int co2 = coroutine_new(S, foo, &amp;arg2);
	printf(&quot;main start\\n&quot;);
	while (coroutine_status(S,co1) &amp;&amp; coroutine_status(S,co2)) {
		// 使用协程co1
		coroutine_resume(S,co1);
		// 使用协程co2
		coroutine_resume(S,co2);
	}
	printf(&quot;main end\\n&quot;);
}

int
main() {
	// 创建一个协程调度器
	struct schedule * S = coroutine_open();
	test(S);
	// 关闭协程调度器
	coroutine_close(S);
	return 0;
}
</code></pre><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-0a0ea7075068417ea78215ea90c4b74a" data-id="0a0ea7075068417ea78215ea90c4b74a"><span><div id="0a0ea7075068417ea78215ea90c4b74a" class="notion-header-anchor"></div><a class="notion-hash-link" href="#0a0ea7075068417ea78215ea90c4b74a" title="核心对象"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">核心对象</span></span></h4><ol start="1" class="notion-list notion-list-numbered notion-block-1b60ff742a974d4d9b6e3c0929a0e01d"><li><code class="notion-inline-code">struct schedule* S</code> 协程调度器</li><ol class="notion-list notion-list-numbered notion-block-1b60ff742a974d4d9b6e3c0929a0e01d"><pre class="notion-code"><div class="notion-code-copy"><div class="notion-code-copy-button"><svg fill="currentColor" viewBox="0 0 16 16" width="1em" version="1.1"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg></div></div><code class="language-c">struct schedule {
    char stack[STACK_SIZE]; // 运行时栈，此栈即是共享栈
    ucontext_t main; // 主协程的上下文
    int nco;        // 当前存活的协程个数
    int cap;        // 协程管理器的当前最大容量，即可以同时支持多少个协程。如果不够了，则进行2倍扩容
    int running;    // 正在运行的协程ID
    struct coroutine **co; // 一个一维数组，用于存放所有协程。其长度等于cap
};
</code></pre><div class="notion-text notion-block-2d319916c6e94233a006ffa456c0449f">调度器中包含协程运行时的共享栈stack，共享栈可以认为所有的协程在运行时用的都是同一块栈，当调用协程的时候，将自己的栈拷贝到共享栈即可。当协程切出时，将栈空间再复制出来。</div><div class="notion-text notion-block-5185e2e6ef9541b990affd45fe7c4397">还包括主协程上下文，可以认为是协程执行完毕之后回到的上下文。</div><div class="notion-text notion-block-82231d47d1ce4aa69e99c72c060971a1">以及一个一维数组，用来存放调度器包括的所有协程。</div></ol></ol><ol start="2" class="notion-list notion-list-numbered notion-block-7c6dbb6a6ce7494f94552e5ad0d02e31"><li><code class="notion-inline-code">coroutine</code>协程</li><ol class="notion-list notion-list-numbered notion-block-7c6dbb6a6ce7494f94552e5ad0d02e31"><pre class="notion-code"><div class="notion-code-copy"><div class="notion-code-copy-button"><svg fill="currentColor" viewBox="0 0 16 16" width="1em" version="1.1"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg></div></div><code class="language-c">struct coroutine {
    coroutine_func func; // 协程所用的函数
    void *ud;  // 协程参数
    ucontext_t ctx; // 协程上下文
    struct schedule * sch; // 该协程所属的调度器
    ptrdiff_t cap;   // 已经分配的内存大小
    ptrdiff_t size; // 当前协程运行时栈，保存起来后的大小
    int status; // 协程当前的状态
    char *stack; // 当前协程的保存起来的运行时栈
};
</code></pre><div class="notion-text notion-block-0f224d02df1444e7928249f90b6d5e12"><code class="notion-inline-code">coroutine</code>结构体包括协程需要执行的函数，协程自己的上下文，用于上下文切换，以及stack用来保存运行时栈。</div></ol></ol><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-11cad9c98bbb4e589da69a3881dd4f0e" data-id="11cad9c98bbb4e589da69a3881dd4f0e"><span><div id="11cad9c98bbb4e589da69a3881dd4f0e" class="notion-header-anchor"></div><a class="notion-hash-link" href="#11cad9c98bbb4e589da69a3881dd4f0e" title="协程状态"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">协程状态</span></span></h4><div class="notion-text notion-block-eb011bcac8294a89a740a355627be8ae">协程有4个状态，分别是READY、RUNNING、SUSPEND、DEAD这四个状态。状态转换如图所示：</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-cb8f8b157af84c619ee2dbacdee6064e"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:528px;max-width:100%;flex-direction:column"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27637%27%20height=%27554%27/%3e"/></span><img alt="notion image" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover;background-size:cover;background-position:0% 0%;filter:blur(20px);background-image:url(&quot;data:image/webp;base64,UklGRoYAAABXRUJQVlA4WAoAAAAQAAAADwAADQAAQUxQSEcAAAARL6CmbQMW9tuNiACzFwwiWXVzoICgoBlIdRD/pn7RENH/CWBtvvhm1Mw8pATiufpXwA9pgFNNhsQSiOfSWwZjQNKN8Wp2AQBWUDggGAAAADABAJ0BKhAADgAFQHwlpAADcAD+8ObAAA==&quot;)"/><noscript><img alt="notion image" src="https://www.notion.so/image/https%3A%2F%2Fuser-images.githubusercontent.com%2F29531394%2F69722195-7a4b4d80-1151-11ea-97e8-3c7c32c91046.png?table=block&amp;id=cb8f8b15-7af8-4c61-9ee2-dbacdee6064e&amp;cache=v2" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover" loading="lazy"/></noscript></span></div></figure><div class="notion-text notion-block-b868c37e5c044e43939c472f1dfbc992"><code class="notion-inline-code">coroutine_new</code>函数用来创建一个协程，协程进行状态转移的核心实现位于<code class="notion-inline-code">coroutine_resume</code>函数和<code class="notion-inline-code">coroutine_yield</code>函数中。</div><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-88c9e887db204241bf07c2dd44582ab6" data-id="88c9e887db204241bf07c2dd44582ab6"><span><div id="88c9e887db204241bf07c2dd44582ab6" class="notion-header-anchor"></div><a class="notion-hash-link" href="#88c9e887db204241bf07c2dd44582ab6" title="READY -&gt; RUNNING"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">READY -&gt; RUNNING</span></span></h4><div class="notion-text notion-block-cdcb3a7cbf51438686c7bc32e0966b73">我们现看一下从READY状态转移到RUNNING状态进行的操作，和我们上面讲ucontext举的例子一样。首先，我们初始化协程的上下文，将协程的栈空间指向调度器中的共享栈，uc_link参数设定为S-&gt;main，当执行完makecontext指定的函数之后就会返回到调用coroutine_resume函数的地方。</div><pre class="notion-code"><div class="notion-code-copy"><div class="notion-code-copy-button"><svg fill="currentColor" viewBox="0 0 16 16" width="1em" version="1.1"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg></div></div><code class="language-c">// coroutine_resume
switch(status) {
	case COROUTINE_READY:
	    //初始化ucontext_t结构体,将当前的上下文放到C-&gt;ctx里面
		getcontext(&amp;C-&gt;ctx);
		// 将当前协程的运行时栈的栈顶设置为S-&gt;stack，每个协程都这么设置，这就是所谓的共享栈。（注意，这里是栈顶）
		C-&gt;ctx.uc_stack.ss_sp = S-&gt;stack;
		C-&gt;ctx.uc_stack.ss_size = STACK_SIZE;
		C-&gt;ctx.uc_link = &amp;S-&gt;main; // 如果协程执行完，将切换到主协程中执行
		S-&gt;running = id;
		C-&gt;status = COROUTINE_RUNNING;

		// 设置执行C-&gt;ctx函数, 并将S作为参数传进去
		uintptr_t ptr = (uintptr_t)S;
		makecontext(&amp;C-&gt;ctx, (void (*)(void)) mainfunc, 2, (uint32_t)ptr, (uint32_t)(ptr&gt;&gt;32));

		// 将当前的上下文放入S-&gt;main中，并将C-&gt;ctx的上下文替换到当前上下文
		swapcontext(&amp;S-&gt;main, &amp;C-&gt;ctx);
		break;
</code></pre><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-24ebdf949fc94b7e9b1bc3639003386b" data-id="24ebdf949fc94b7e9b1bc3639003386b"><span><div id="24ebdf949fc94b7e9b1bc3639003386b" class="notion-header-anchor"></div><a class="notion-hash-link" href="#24ebdf949fc94b7e9b1bc3639003386b" title="RUNNING -&gt; SUSPEND"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">RUNNING -&gt; SUSPEND</span></span></h4><div class="notion-text notion-block-cd4a64fae1c14544b09586a35449f23d">当执行coroutine_yield函数之后，我们看到程序会首先保存当前协程的运行时栈，然后把协程的状态修改为挂起状态，并切换到主协程中。</div><pre class="notion-code"><div class="notion-code-copy"><div class="notion-code-copy-button"><svg fill="currentColor" viewBox="0 0 16 16" width="1em" version="1.1"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg></div></div><code class="language-c">void
coroutine_yield(struct schedule * S) {
	// 取出当前正在运行的协程
	int id = S-&gt;running;
	assert(id &gt;= 0);

	struct coroutine * C = S-&gt;co[id];
	assert((char *)&amp;C &gt; S-&gt;stack);

	// 将当前运行的协程的栈内容保存起来
	_save_stack(C,S-&gt;stack + STACK_SIZE);

	// 将当前栈的状态改为 挂起
	C-&gt;status = COROUTINE_SUSPEND;
	S-&gt;running = -1;

	// 所以这里可以看到，只能从协程切换到主协程中
	swapcontext(&amp;C-&gt;ctx , &amp;S-&gt;main);
}
</code></pre><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-ba4b1cea1dca4674afa81298753520d2" data-id="ba4b1cea1dca4674afa81298753520d2"><span><div id="ba4b1cea1dca4674afa81298753520d2" class="notion-header-anchor"></div><a class="notion-hash-link" href="#ba4b1cea1dca4674afa81298753520d2" title="SUSPEND -&gt; RUNNING"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">SUSPEND -&gt; RUNNING</span></span></h4><div class="notion-text notion-block-39186355e05b4c83b109ca7455af7e52">当从挂起状态恢复为执行状态时，会将协程的运行时栈拷贝到共享栈，并再次切换上下文回到调用coroutine_yield函数的地方。</div><pre class="notion-code"><div class="notion-code-copy"><div class="notion-code-copy-button"><svg fill="currentColor" viewBox="0 0 16 16" width="1em" version="1.1"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg></div></div><code class="language-c">	case COROUTINE_SUSPEND:
	    // 将协程所保存的栈的内容，拷贝到当前运行时栈中
		// 其中C-&gt;size在yield时有保存
		memcpy(S-&gt;stack + STACK_SIZE - C-&gt;size, C-&gt;stack, C-&gt;size);
		S-&gt;running = id;
		C-&gt;status = COROUTINE_RUNNING;
		swapcontext(&amp;S-&gt;main, &amp;C-&gt;ctx);
		break;
</code></pre><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-d0cc1bb5a9c44b9d83c3ccc5ac91f075" data-id="d0cc1bb5a9c44b9d83c3ccc5ac91f075"><span><div id="d0cc1bb5a9c44b9d83c3ccc5ac91f075" class="notion-header-anchor"></div><a class="notion-hash-link" href="#d0cc1bb5a9c44b9d83c3ccc5ac91f075" title="运行栈保存"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">运行栈保存</span></span></h4><div class="notion-text notion-block-423eda574a614363b7790ad78643c5d1">当执行coroutine_yield函数的时候，会发现该函数会调用<code class="notion-inline-code">_save_stack</code>将当前协程的栈保存起来，因为coroutine是基于共享栈的，所以协程的栈内容需要单独保存起来。这里有一个很trick的点，那就是当前协程的运行栈怎么保存起来，也就是如何获取协程的栈空间。</div><div class="notion-text notion-block-e3936f4119dc4a64b304ec3ef3bbe451">一开始我们会在初始化调度器的时候设置共享栈的大小，stack指向栈顶，为了降低内存的占用，我们保存协程栈的时候不会直接保存一份和共享栈一样大小的栈空间，这时候我们需要找到该协程的栈顶位置。</div><div class="notion-text notion-block-30e6db8cecd8472f8de73f1ad30ef808">下面代码的实现非常巧妙，他声明了一个局部变量dummy，而dummy的地址就是栈顶位置，大家可以参考上面讲的foo函数栈增长部分，相信你一定也能想到。</div><pre class="notion-code"><div class="notion-code-copy"><div class="notion-code-copy-button"><svg fill="currentColor" viewBox="0 0 16 16" width="1em" version="1.1"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg></div></div><code class="language-c">static void
_save_stack(struct coroutine *C, char *top) {
	// 这个dummy很关键，是求取整个栈的关键
	// 这个非常经典，涉及到linux的内存分布，栈是从高地址向低地址扩展，因此
	// S-&gt;stack + STACK_SIZE就是运行时栈的栈底
	// dummy，此时在栈中，肯定是位于最底的位置的，即栈顶
	// top - &amp;dummy 即整个栈的容量
	char dummy = 0;
	assert(top - &amp;dummy &lt;= STACK_SIZE);
	if (C-&gt;cap &lt; top - &amp;dummy) {
		free(C-&gt;stack);
		C-&gt;cap = top-&amp;dummy;
		C-&gt;stack = malloc(C-&gt;cap);
	}
	C-&gt;size = top - &amp;dummy;
	memcpy(C-&gt;stack, &amp;dummy, C-&gt;size);
}
</code></pre><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-bcd91fbed7b742e5817adde056786718" data-id="bcd91fbed7b742e5817adde056786718"><span><div id="bcd91fbed7b742e5817adde056786718" class="notion-header-anchor"></div><a class="notion-hash-link" href="#bcd91fbed7b742e5817adde056786718" title="goroutine实现"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">goroutine实现</span></span></h3><div class="notion-text notion-block-fd04136b3fca4e06b4201acb1f1e4c9b">golang语言中的goroutine也是一个有栈协程，但是和本文讲到的coroutine还是有很大不同，首先golang有自己的协程调度器，而且golang的协程是抢占式执行的，关于golang的协程要写的东西还是太多了，得再开一篇文章讨论，大家可以阅读下面的文章有个深入的了解。</div><div class="notion-text notion-block-6a98cd374a7a4f2593e72bbc8b6b2112"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://zboya.github.io/post/go_scheduler/#%E6%B7%B1%E5%85%A5golang-runtime%E7%9A%84%E8%B0%83%E5%BA%A6">深入golang-runtime的调度</a></div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-e90453a625724b13a863fb9614226ac9" data-id="e90453a625724b13a863fb9614226ac9"><span><div id="e90453a625724b13a863fb9614226ac9" class="notion-header-anchor"></div><a class="notion-hash-link" href="#e90453a625724b13a863fb9614226ac9" title="参考文献"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">参考文献</span></span></h3><ol start="1" class="notion-list notion-list-numbered notion-block-2abd488133d445c28ba094dae3f3020f"><li><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://book.douban.com/subject/19973015/">Operating Systems</a></li></ol><ol start="2" class="notion-list notion-list-numbered notion-block-2b57403171304de5b0a6a34c9ab0c10a"><li><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://book.douban.com/subject/3652388/">程序员的自我修养</a></li></ol><div class="notion-blank notion-block-5ae9dad79b53445aa1e675637ffe93d0"> </div></article><aside class="notion-aside"><div class="notion-aside-table-of-contents"><div class="notion-aside-table-of-contents-header">Table of Contents</div><nav class="notion-table-of-contents"><a href="#053a49205603423b9ade546274c449e8" class="notion-table-of-contents-item notion-table-of-contents-item-indent-level-0"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">协程</span></a><a href="#1b3e9d750f6245109d37cff48a0ef8b1" class="notion-table-of-contents-item notion-table-of-contents-item-indent-level-0"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">进程、线程</span></a><a href="#0bf3a3cece50468aa7b47572bc7f1950" class="notion-table-of-contents-item notion-table-of-contents-item-indent-level-1"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:16px">进程地址空间</span></a><a href="#7d7ba4e877a142acac74ecaeb6ba6c99" class="notion-table-of-contents-item notion-table-of-contents-item-indent-level-1"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:16px">栈的增长方式</span></a><a href="#edfe5570b46948acbacee9ffe3650f54" class="notion-table-of-contents-item notion-table-of-contents-item-indent-level-1"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:16px">线程</span></a><a href="#540d0eb1f3fc424fafa376e2181a02c3" class="notion-table-of-contents-item notion-table-of-contents-item-indent-level-1"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:16px">线程上下文切换</span></a><a href="#d1ecda807514440c8c23535297a6a91b" class="notion-table-of-contents-item notion-table-of-contents-item-indent-level-1"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:16px">实现协程的理论依据</span></a><a href="#bd7e22a3e682479d8bd88fb0d4527d45" class="notion-table-of-contents-item notion-table-of-contents-item-indent-level-0"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">ucontext</span></a><a href="#a538893ad10a47ca929792840ebf55d8" class="notion-table-of-contents-item notion-table-of-contents-item-indent-level-0"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">coroutine实现</span></a><a href="#a889aa77b74441b7bed54cf9c2c34b33" class="notion-table-of-contents-item notion-table-of-contents-item-indent-level-1"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:16px">coroutine例子</span></a><a href="#0a0ea7075068417ea78215ea90c4b74a" class="notion-table-of-contents-item notion-table-of-contents-item-indent-level-1"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:16px">核心对象</span></a><a href="#11cad9c98bbb4e589da69a3881dd4f0e" class="notion-table-of-contents-item notion-table-of-contents-item-indent-level-1"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:16px">协程状态</span></a><a href="#88c9e887db204241bf07c2dd44582ab6" class="notion-table-of-contents-item notion-table-of-contents-item-indent-level-1"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:16px">READY -&gt; RUNNING</span></a><a href="#24ebdf949fc94b7e9b1bc3639003386b" class="notion-table-of-contents-item notion-table-of-contents-item-indent-level-1"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:16px">RUNNING -&gt; SUSPEND</span></a><a href="#ba4b1cea1dca4674afa81298753520d2" class="notion-table-of-contents-item notion-table-of-contents-item-indent-level-1"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:16px">SUSPEND -&gt; RUNNING</span></a><a href="#d0cc1bb5a9c44b9d83c3ccc5ac91f075" class="notion-table-of-contents-item notion-table-of-contents-item-indent-level-1"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:16px">运行栈保存</span></a><a href="#bcd91fbed7b742e5817adde056786718" class="notion-table-of-contents-item notion-table-of-contents-item-indent-level-0"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">goroutine实现</span></a><a href="#e90453a625724b13a863fb9614226ac9" class="notion-table-of-contents-item notion-table-of-contents-item-indent-level-0"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">参考文献</span></a></nav></div></aside></div><div class="styles_comments__YEupF"><div><p>Loading Comments...</p></div></div></main><footer class="styles_footer__RBpyk"><div class="styles_copyright__nhL_k">Copyright 2022 <!-- -->yangsoon</div><div class="styles_settings__GyEhi"></div><div class="styles_social__ptL3p"><a class="styles_github__0JN7a" href="https://yangsoon.github.io" title="YangSoon @yangsoon.github.io" rel="noopener noreferrer"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M8 3.293l6 6V13.5a1.5 1.5 0 01-1.5 1.5h-9A1.5 1.5 0 012 13.5V9.293l6-6zm5-.793V6l-2-2V2.5a.5.5 0 01.5-.5h1a.5.5 0 01.5.5z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M7.293 1.5a1 1 0 011.414 0l6.647 6.646a.5.5 0 01-.708.708L8 2.207 1.354 8.854a.5.5 0 11-.708-.708L7.293 1.5z" clip-rule="evenodd"></path></svg></a><a class="styles_github__0JN7a" href="https://github.com/yangsoon" title="GitHub @yangsoon" target="_blank" rel="noopener noreferrer"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 496 512" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg></a><a class="styles_zhihu__Z7IC7" href="https://zhihu.com/people/yangsoon" title="Zhihu @yangsoon" target="_blank" rel="noopener noreferrer"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 640 512" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M170.54 148.13v217.54l23.43.01 7.71 26.37 42.01-26.37h49.53V148.13H170.54zm97.75 193.93h-27.94l-27.9 17.51-5.08-17.47-11.9-.04V171.75h72.82v170.31zm-118.46-94.39H97.5c1.74-27.1 2.2-51.59 2.2-73.46h51.16s1.97-22.56-8.58-22.31h-88.5c3.49-13.12 7.87-26.66 13.12-40.67 0 0-24.07 0-32.27 21.57-3.39 8.9-13.21 43.14-30.7 78.12 5.89-.64 25.37-1.18 36.84-22.21 2.11-5.89 2.51-6.66 5.14-14.53h28.87c0 10.5-1.2 66.88-1.68 73.44H20.83c-11.74 0-15.56 23.62-15.56 23.62h65.58C66.45 321.1 42.83 363.12 0 396.34c20.49 5.85 40.91-.93 51-9.9 0 0 22.98-20.9 35.59-69.25l53.96 64.94s7.91-26.89-1.24-39.99c-7.58-8.92-28.06-33.06-36.79-41.81L87.9 311.95c4.36-13.98 6.99-27.55 7.87-40.67h61.65s-.09-23.62-7.59-23.62v.01zm412.02-1.6c20.83-25.64 44.98-58.57 44.98-58.57s-18.65-14.8-27.38-4.06c-6 8.15-36.83 48.2-36.83 48.2l19.23 14.43zm-150.09-59.09c-9.01-8.25-25.91 2.13-25.91 2.13s39.52 55.04 41.12 57.45l19.46-13.73s-25.67-37.61-34.66-45.86h-.01zM640 258.35c-19.78 0-130.91.93-131.06.93v-101c4.81 0 12.42-.4 22.85-1.2 40.88-2.41 70.13-4 87.77-4.81 0 0 12.22-27.19-.59-33.44-3.07-1.18-23.17 4.58-23.17 4.58s-165.22 16.49-232.36 18.05c1.6 8.82 7.62 17.08 15.78 19.55 13.31 3.48 22.69 1.7 49.15.89 24.83-1.6 43.68-2.43 56.51-2.43v99.81H351.41s2.82 22.31 25.51 22.85h107.94v70.92c0 13.97-11.19 21.99-24.48 21.12-14.08.11-26.08-1.15-41.69-1.81 1.99 3.97 6.33 14.39 19.31 21.84 9.88 4.81 16.17 6.57 26.02 6.57 29.56 0 45.67-17.28 44.89-45.31v-73.32h122.36c9.68 0 8.7-23.78 8.7-23.78l.03-.01z"></path></svg></a><a class="styles_twitter__3YoqL" href="https://twitter.com/yangsoonlx" title="Twitter @yangsoonlx" target="_blank" rel="noopener noreferrer"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"></path></svg></a></div></footer></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"site":{"domain":"yangsoon.github.io","name":"YangSoon","rootNotionPageId":"72a669717cf642c2a2524439d99d8f44","rootNotionSpaceId":null,"description":"YangSoon, Cloud Native Developer"},"recordMap":{"block":{"091a74ac-4142-4f28-ba1d-5c9810ccc648":{"role":"reader","value":{"id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","version":108,"type":"page","properties":{"title":[["有栈协程实现原理",[["b"]]]]},"content":["fa1c3357-8d66-49c7-b61e-4d3d69346323","053a4920-5603-423b-9ade-546274c449e8","57c53cca-ff1b-40e9-bb07-727965277060","1b3e9d75-0f62-4510-9d37-cff48a0ef8b1","0bf3a3ce-ce50-468a-a7b4-7572bc7f1950","eaa93a3a-20d5-4bc8-8b06-16af7753d5df","c4b4cc20-8808-4229-b76e-b2c220ea8819","80e01be4-edc7-42ac-88dc-d44c0022b938","78c54cf6-c4c3-45e5-a965-841a0c9215bd","582af19c-4877-4609-b669-dea8e1fe3466","674b8f34-799a-486a-9368-a3c70263d731","b44648ac-613f-4eae-877c-ff22c079e520","ac6a02ff-a1a9-4a4d-b210-3f40fd667c84","7d7ba4e8-77a1-42ac-ac74-ecaeb6ba6c99","47b81bd6-877c-4a0c-b71e-414cb56d1665","f2e65cac-3449-4d0f-bb72-f1aa748b9ddb","12cfdaf2-14e0-4720-8af4-32f69336d87d","010204f7-4312-449e-8d7b-2c647fa7aca2","098d17c4-973d-4986-a38b-9bc724c172ef","dff2befb-112a-460c-9ed3-df3e39f50182","177caef2-deb2-4f19-ad1b-b7f5a8bcf401","c0225528-1c15-4ded-a5d6-1d7434d2916f","09acbf6c-f422-4723-bbeb-4e4e916b7170","780e6eca-b041-4bf2-bfb4-d115c10097e2","91243b24-4801-4c77-9e9c-e5d05b98d66a","ba511ef4-cd74-4973-9aa9-af7ee9d2483c","01bc0475-504f-48d1-b921-a2cd8ca652f2","7d97a16b-9fcc-435d-9fb4-8e6453129f37","edfe5570-b469-48ac-bace-e9ffe3650f54","9471b13e-899c-4902-a3ee-7c43b5b1bb4a","5ab357ce-c62a-4d0f-87c6-84ead807b96c","4bc00fd1-79fe-43a3-a5ca-27d6c7abbfd0","6318cf56-93de-4904-b90e-0234105865a7","540d0eb1-f3fc-424f-afa3-76e2181a02c3","b4484646-5632-4371-b39d-5eef692ceb67","d9deb8e7-40c7-4fe4-8eb0-bfb752060fdd","d1ecda80-7514-440c-8c23-535297a6a91b","87aeecae-7857-4a4f-b90d-3d7a8e945deb","bd7e22a3-e682-479d-8bd8-8fb0d4527d45","406e6a66-b1dd-4932-aa08-3b88d489fe5e","58990965-bc3c-41c8-9038-a68734fb08a4","1e2d64d1-197b-40f1-a1a0-46c22195ca4a","2e2ce295-0cf9-4c66-aef6-8aba7cc8f4eb","74685b96-c189-4b3b-adc8-cb907e50cca5","4ceedf79-79f2-4612-bbc7-dbe08c086a41","48003433-31c1-4af9-ad2a-48c27e804153","6883e37a-fadd-43e3-b77d-bc09077f8f45","b648ed22-db76-471c-8507-3d30eed58cb6","172b9e94-4813-42c1-a44c-e31a10bf2967","aab791af-e935-4ebd-8e0b-343ac6a544c3","6a9228c8-f496-44c6-803a-5399ed9b0246","1144815e-b4a4-4ff2-a510-9512fae5d994","a695fe60-b955-4d1a-8858-45e37c881bf6","a538893a-d10a-47ca-9297-92840ebf55d8","ed19cb98-6f5b-4567-96da-5accf18c3c19","a889aa77-b744-41b7-bed5-4cf9c2c34b33","8ad58dab-92fc-4d99-8018-7e885a163486","0a0ea707-5068-417e-a782-15ea90c4b74a","1b60ff74-2a97-4d4d-9b6e-3c0929a0e01d","7c6dbb6a-6ce7-494f-9455-2e5ad0d02e31","11cad9c9-8bbb-4e58-9da6-9a3881dd4f0e","eb011bca-c829-4a89-a740-a355627be8ae","cb8f8b15-7af8-4c61-9ee2-dbacdee6064e","b868c37e-5c04-4e43-939c-472f1dfbc992","88c9e887-db20-4241-bf07-c2dd44582ab6","cdcb3a7c-bf51-4386-86c7-bc32e0966b73","b42e961a-ffb3-43c8-8756-dac03c1d84b0","24ebdf94-9fc9-4b7e-9b1b-c3639003386b","cd4a64fa-e1c1-4544-b095-86a35449f23d","419483df-3da3-4239-b638-85cb1d11c714","ba4b1cea-1dca-4674-afa8-1298753520d2","39186355-e05b-4c83-b109-ca7455af7e52","e6f45e9c-f5c2-4893-a08c-2ba13bd4ee46","d0cc1bb5-a9c4-4b9d-83c3-ccc5ac91f075","423eda57-4a61-4363-b779-0ad78643c5d1","e3936f41-19dc-4a64-b304-ec3ef3bbe451","30e6db8c-ecd8-472f-8de7-3f1ad30ef808","1f4a13e5-bb6f-48bb-85e6-dbe68007b3bc","bcd91fbe-d7b7-42e5-817a-dde056786718","fd04136b-3fca-4e06-b420-1acb1f1e4c9b","6a98cd37-4a7a-4f25-93e7-2bbc8b6b2112","e90453a6-2572-4b13-a863-fb9614226ac9","2abd4881-33d4-45c2-8ba0-94dae3f3020f","2b574031-7130-4de5-b0a6-a34c9ab0c10a","5ae9dad7-9b53-445a-a1e6-75637ffe93d0"],"format":{"page_icon":"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/efaf9256-833c-41b8-a88d-7466ca5ceeb9/srchttp___img.pconline.com.cn_images_nospd_upload_upc_tx_pcdlc_2108_16_c7_274750145_1629102176621.pngreferhttp___img.pconline.com.webp","page_small_text":true},"created_time":1661556701547,"last_edited_time":1666627560000,"parent_id":"72a66971-7cf6-42c2-a252-4439d99d8f44","parent_table":"block","alive":true,"file_ids":["efaf9256-833c-41b8-a88d-7466ca5ceeb9"],"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"72a66971-7cf6-42c2-a252-4439d99d8f44":{"role":"reader","value":{"id":"72a66971-7cf6-42c2-a252-4439d99d8f44","version":501,"type":"page","properties":{"title":[["yangsoon ‘s blog"]]},"content":["8a139bd3-c29e-4248-b950-43841f1b0076","aa1ab112-6a1c-4700-b31c-a9658b6a18af","23b11c7c-8146-4639-912c-14406e078331","ceb8c970-ebd0-4bb1-bd23-c481ed7fefab","b80b3335-c73f-4e47-a39b-3021b4dc650a","02130a54-428f-4e4b-861c-dcbed7945c3b","020410cb-b4a6-4c00-921d-9145fcf35569","091a74ac-4142-4f28-ba1d-5c9810ccc648","0648cf9f-653b-4a40-8c78-52e3a3add115","46b5fd4b-3050-41cb-90ba-45cf6db1e56a","1807cc1c-60f4-47ca-8eb7-99bbef34b28b","1d187551-eeba-418f-a731-1c36497feb57","82aad922-cb77-4452-81bf-56f4e8e5a408"],"format":{"page_icon":"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/37907dd5-3c76-4966-a419-daa027a84972/IMG_2189.jpg","page_full_width":false,"page_small_text":false,"copied_from_pointer":{"id":"bd32b787-e471-49f3-8941-174a9c6846b6","table":"block","spaceId":"bb9288f4-efb5-417f-bf44-1a79fa04feb1"}},"permissions":[{"role":"editor","type":"user_permission","user_id":"d1805983-7869-451d-bf8b-64135a5d4ee7"},{"role":"reader","type":"public_permission","added_timestamp":1660963691744,"allow_duplicate":false}],"created_time":1660961589760,"last_edited_time":1666627680000,"parent_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6","parent_table":"space","alive":true,"copied_from":"bd32b787-e471-49f3-8941-174a9c6846b6","file_ids":["63e89fe9-f5cd-4414-be0e-53d91aa54fc3","37907dd5-3c76-4966-a419-daa027a84972"],"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"fa1c3357-8d66-49c7-b61e-4d3d69346323":{"role":"reader","value":{"id":"fa1c3357-8d66-49c7-b61e-4d3d69346323","version":20,"type":"text","properties":{"title":[["本文主要讲解有栈协程的实现原理，以云风实现的coroutine为例。"]]},"created_time":1661556706145,"last_edited_time":1661556720000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"053a4920-5603-423b-9ade-546274c449e8":{"role":"reader","value":{"id":"053a4920-5603-423b-9ade-546274c449e8","version":2,"type":"sub_header","properties":{"title":[["协程"]]},"created_time":1661556706146,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"57c53cca-ff1b-40e9-bb07-727965277060":{"role":"reader","value":{"id":"57c53cca-ff1b-40e9-bb07-727965277060","version":46,"type":"text","properties":{"title":[["关于协程的概念，在网上没有找到比较通俗的解释，下面就说说个人的理解，(有栈)协程可以理解为一个用户态下的线程，在用户态下进行线程（协程）的上下文切换。但是和传统的线程不同的是：线程是抢占式执行，当发生系统调用或者中断的时候，交由OS调度执行；而协程是通过yield主动让出cpu所有权，切换到其他协程执行。"]]},"created_time":1661556706146,"last_edited_time":1661559060000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"1b3e9d75-0f62-4510-9d37-cff48a0ef8b1":{"role":"reader","value":{"id":"1b3e9d75-0f62-4510-9d37-cff48a0ef8b1","version":2,"type":"sub_header","properties":{"title":[["进程、线程"]]},"created_time":1661556706146,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"0bf3a3ce-ce50-468a-a7b4-7572bc7f1950":{"role":"reader","value":{"id":"0bf3a3ce-ce50-468a-a7b4-7572bc7f1950","version":2,"type":"sub_sub_header","properties":{"title":[["进程地址空间"]]},"created_time":1661556706146,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"eaa93a3a-20d5-4bc8-8b06-16af7753d5df":{"role":"reader","value":{"id":"eaa93a3a-20d5-4bc8-8b06-16af7753d5df","version":2,"type":"text","properties":{"title":[["一般来说一个进程的地址空间有这几个默认区域:"]]},"created_time":1661556706146,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"c4b4cc20-8808-4229-b76e-b2c220ea8819":{"role":"reader","value":{"id":"c4b4cc20-8808-4229-b76e-b2c220ea8819","version":2,"type":"numbered_list","properties":{"title":[["栈：栈用于维护函数调用的上下文，包括函数的参数，局部变量等等。"]]},"created_time":1661556706146,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"80e01be4-edc7-42ac-88dc-d44c0022b938":{"role":"reader","value":{"id":"80e01be4-edc7-42ac-88dc-d44c0022b938","version":2,"type":"numbered_list","properties":{"title":[["堆：用来容纳程序中动态分配的内存区域，当程序使用malloc和new分配的内存就来自于堆里"]]},"created_time":1661556706147,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"78c54cf6-c4c3-45e5-a965-841a0c9215bd":{"role":"reader","value":{"id":"78c54cf6-c4c3-45e5-a965-841a0c9215bd","version":2,"type":"numbered_list","properties":{"title":[["可执行文件映像。"]]},"created_time":1661556706147,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"582af19c-4877-4609-b669-dea8e1fe3466":{"role":"reader","value":{"id":"582af19c-4877-4609-b669-dea8e1fe3466","version":2,"type":"numbered_list","properties":{"title":[["保留区，是对内存中受到保护而禁止访问的内存区域的总称。"]]},"created_time":1661556706147,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"674b8f34-799a-486a-9368-a3c70263d731":{"role":"reader","value":{"id":"674b8f34-799a-486a-9368-a3c70263d731","version":2,"type":"text","properties":{"title":[["下图是linux下一个进程的典型内存布局: 在经典的操作系统中，栈总是 "],["向下增长",[["b"]]],[" ，从高地址向低地址增长，其中栈顶指针存储在 "],["[E|R]SP",[["b"]]],[" 寄存器中，而堆则总是 "],["向上增长",[["b"]]],[" ，从低地址向高地址增长。"]]},"created_time":1661556706147,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"b44648ac-613f-4eae-877c-ff22c079e520":{"role":"reader","value":{"id":"b44648ac-613f-4eae-877c-ff22c079e520","version":2,"type":"text","properties":{"title":[[""]]},"created_time":1661556706147,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"ac6a02ff-a1a9-4a4d-b210-3f40fd667c84":{"role":"reader","value":{"id":"ac6a02ff-a1a9-4a4d-b210-3f40fd667c84","version":6,"type":"image","properties":{"source":[["https://user-images.githubusercontent.com/29531394/69554356-a42f3380-0fdc-11ea-9cf6-21c7d4b62bcc.png"]]},"format":{"block_width":480,"block_height":320,"block_full_width":false,"block_page_width":false},"created_time":1661556706147,"last_edited_time":1661559060000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"7d7ba4e8-77a1-42ac-ac74-ecaeb6ba6c99":{"role":"reader","value":{"id":"7d7ba4e8-77a1-42ac-ac74-ecaeb6ba6c99","version":2,"type":"sub_sub_header","properties":{"title":[["栈的增长方式"]]},"created_time":1661556706147,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"47b81bd6-877c-4a0c-b71e-414cb56d1665":{"role":"reader","value":{"id":"47b81bd6-877c-4a0c-b71e-414cb56d1665","version":2,"type":"text","properties":{"title":[["栈在程序运行中具有举足轻重的地位，最重要的，栈保存了一个函数调用所需要维护的信息，这常常被称为"],["堆栈帧",[["b"]]],["，堆栈帧一般包括下面几方面内容："]]},"created_time":1661556706147,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"f2e65cac-3449-4d0f-bb72-f1aa748b9ddb":{"role":"reader","value":{"id":"f2e65cac-3449-4d0f-bb72-f1aa748b9ddb","version":2,"type":"numbered_list","properties":{"title":[["函数的返回地址和参数"]]},"created_time":1661556706148,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"12cfdaf2-14e0-4720-8af4-32f69336d87d":{"role":"reader","value":{"id":"12cfdaf2-14e0-4720-8af4-32f69336d87d","version":2,"type":"numbered_list","properties":{"title":[["临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量"]]},"created_time":1661556706148,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"010204f7-4312-449e-8d7b-2c647fa7aca2":{"role":"reader","value":{"id":"010204f7-4312-449e-8d7b-2c647fa7aca2","version":2,"type":"numbered_list","properties":{"title":[["保存的上下文：包括在函数调用前后需要保存不变的寄存器的值"]]},"created_time":1661556706148,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"098d17c4-973d-4986-a38b-9bc724c172ef":{"role":"reader","value":{"id":"098d17c4-973d-4986-a38b-9bc724c172ef","version":2,"type":"text","properties":{"title":[["一个函数的堆栈帧用 "],["[E|R]SP,[E|R]BP",[["b"]]],[" ，这两个寄存器划定范围，"],["[E|R]SP",[["b"]]],["始终指向栈顶的位置称为栈指针寄存器，"],["[E|R]SP",[["b"]]],["指向堆栈帧的一个固定位置，"],["[E|R]SP",[["b"]]],[" 又被称为帧指针，一般函数中的局部变量靠 "],["[E|R]SP",[["b"]]],[" 加上偏移量寻找。"]]},"created_time":1661556706148,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"dff2befb-112a-460c-9ed3-df3e39f50182":{"role":"reader","value":{"id":"dff2befb-112a-460c-9ed3-df3e39f50182","version":2,"type":"quote","properties":{"title":[["[E|R]SP表示esp或者rsp寄存器，esp表示32位x86架构下的栈指针寄存器，rsp表示64位x86架构下的栈指针寄存器，同理于[E|R]BP。 帧指针并不是必须的, x86-64过程中的栈帧通常有固定的大小，在调用过程中栈指针保持固定的位置，使得可以通过相对于栈指针的偏移量来访问数据^1。"]]},"created_time":1661556706148,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"177caef2-deb2-4f19-ad1b-b7f5a8bcf401":{"role":"reader","value":{"id":"177caef2-deb2-4f19-ad1b-b7f5a8bcf401","version":2,"type":"text","properties":{"title":[["下面我们就简单讲解一下当程序调用一个简单的函数时，线程中的栈是如何增长的。假设有一个foo函数"]]},"created_time":1661556706148,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"c0225528-1c15-4ded-a5d6-1d7434d2916f":{"role":"reader","value":{"id":"c0225528-1c15-4ded-a5d6-1d7434d2916f","version":4,"type":"code","properties":{"title":[["int foo(int m, int n){\n  int a = 0; // #i\n  ....\n}\n"]],"language":[["C"]]},"format":{"code_wrap":true},"created_time":1661556706148,"last_edited_time":1661556720000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"09acbf6c-f422-4723-bbeb-4e4e916b7170":{"role":"reader","value":{"id":"09acbf6c-f422-4723-bbeb-4e4e916b7170","version":2,"type":"text","properties":{"title":[["该函数对应的堆栈帧的内存空间如下所示，一个函数的堆栈帧增长过程是这样的："]]},"created_time":1661556706148,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"780e6eca-b041-4bf2-bfb4-d115c10097e2":{"role":"reader","value":{"id":"780e6eca-b041-4bf2-bfb4-d115c10097e2","version":2,"type":"numbered_list","properties":{"title":[["把所有或一部分参数加入栈中，如果有其他参数没有入栈，那么使用某些寄存器传递"]]},"created_time":1661556706149,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"91243b24-4801-4c77-9e9c-e5d05b98d66a":{"role":"reader","value":{"id":"91243b24-4801-4c77-9e9c-e5d05b98d66a","version":2,"type":"numbered_list","properties":{"title":[["把当前指令的下一条指令地址压入栈中"]]},"created_time":1661556706149,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"ba511ef4-cd74-4973-9aa9-af7ee9d2483c":{"role":"reader","value":{"id":"ba511ef4-cd74-4973-9aa9-af7ee9d2483c","version":2,"type":"numbered_list","properties":{"title":[["跳转到函数体执行:"]]},"content":["d80d2234-5b60-47e0-be22-6992f853518b","2c91bb50-8e9a-4374-859e-70ad71d8258f","f4a104b3-6025-4cca-a61d-bcc93a4d8889","a3450908-ce05-48ba-b0e6-2b0ea6fc3813"],"created_time":1661556706149,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"d80d2234-5b60-47e0-be22-6992f853518b":{"role":"reader","value":{"id":"d80d2234-5b60-47e0-be22-6992f853518b","version":2,"type":"numbered_list","properties":{"title":[["把[e|r]bp压入栈中，指向上一个函数堆栈帧中的帧指针的位置"]]},"created_time":1661556706149,"last_edited_time":1661556660000,"parent_id":"ba511ef4-cd74-4973-9aa9-af7ee9d2483c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"2c91bb50-8e9a-4374-859e-70ad71d8258f":{"role":"reader","value":{"id":"2c91bb50-8e9a-4374-859e-70ad71d8258f","version":2,"type":"numbered_list","properties":{"title":[["保存调用前后需要保存不变的寄存器的值"]]},"created_time":1661556706149,"last_edited_time":1661556660000,"parent_id":"ba511ef4-cd74-4973-9aa9-af7ee9d2483c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"f4a104b3-6025-4cca-a61d-bcc93a4d8889":{"role":"reader","value":{"id":"f4a104b3-6025-4cca-a61d-bcc93a4d8889","version":2,"type":"numbered_list","properties":{"title":[["将局部变量压入栈中"]]},"created_time":1661556706149,"last_edited_time":1661556660000,"parent_id":"ba511ef4-cd74-4973-9aa9-af7ee9d2483c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"a3450908-ce05-48ba-b0e6-2b0ea6fc3813":{"role":"reader","value":{"id":"a3450908-ce05-48ba-b0e6-2b0ea6fc3813","version":2,"type":"text","properties":{"title":[["..."]]},"created_time":1661556706149,"last_edited_time":1661556660000,"parent_id":"ba511ef4-cd74-4973-9aa9-af7ee9d2483c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"01bc0475-504f-48d1-b921-a2cd8ca652f2":{"role":"reader","value":{"id":"01bc0475-504f-48d1-b921-a2cd8ca652f2","version":2,"type":"text","properties":{"title":[["当函数调用返回之后，相应的函数堆栈帧也会弹出，弹出的流程不是本篇文章的重点，在此就不详细讲解，感兴趣的推荐看 "],["程序员的自我修养",[["b"]]],[" 中讲解堆栈的部分。"]]},"created_time":1661556706149,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"7d97a16b-9fcc-435d-9fb4-8e6453129f37":{"role":"reader","value":{"id":"7d97a16b-9fcc-435d-9fb4-8e6453129f37","version":4,"type":"image","properties":{"source":[["https://user-images.githubusercontent.com/29531394/69641429-2847f080-109b-11ea-80fa-fab3c148dba6.png"]]},"format":{"block_width":528,"block_height":320,"block_full_width":false,"block_page_width":false},"created_time":1661556706149,"last_edited_time":1661557500000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"edfe5570-b469-48ac-bace-e9ffe3650f54":{"role":"reader","value":{"id":"edfe5570-b469-48ac-bace-e9ffe3650f54","version":2,"type":"sub_sub_header","properties":{"title":[["线程"]]},"created_time":1661556706149,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"9471b13e-899c-4902-a3ee-7c43b5b1bb4a":{"role":"reader","value":{"id":"9471b13e-899c-4902-a3ee-7c43b5b1bb4a","version":2,"type":"text","properties":{"title":[["一个标准的线程由线程id、程序计数器(PC)、寄存器集合和栈组成。"]]},"created_time":1661556706150,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"5ab357ce-c62a-4d0f-87c6-84ead807b96c":{"role":"reader","value":{"id":"5ab357ce-c62a-4d0f-87c6-84ead807b96c","version":2,"type":"text","properties":{"title":[["每个线程类似一个独立进程，不同的是线程之间共享地址空间，能够访问到相同的数据。线程之间共享进程的内存空间(包括代码段、数据段、堆等)以及以下进程级的资源（如打开文件和信号）。"]]},"created_time":1661556706150,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"4bc00fd1-79fe-43a3-a5ca-27d6c7abbfd0":{"role":"reader","value":{"id":"4bc00fd1-79fe-43a3-a5ca-27d6c7abbfd0","version":2,"type":"text","properties":{"title":[["一个经典的进程和线程的关系如下图所示："]]},"created_time":1661556706150,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"6318cf56-93de-4904-b90e-0234105865a7":{"role":"reader","value":{"id":"6318cf56-93de-4904-b90e-0234105865a7","version":4,"type":"image","properties":{"source":[["https://user-images.githubusercontent.com/29531394/69556981-be6b1080-0fe0-11ea-8f46-9ef60c77f161.png"]]},"format":{"block_width":528,"block_height":320,"block_full_width":false,"block_page_width":false},"created_time":1661556706150,"last_edited_time":1661557500000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"540d0eb1-f3fc-424f-afa3-76e2181a02c3":{"role":"reader","value":{"id":"540d0eb1-f3fc-424f-afa3-76e2181a02c3","version":2,"type":"sub_sub_header","properties":{"title":[["线程上下文切换"]]},"created_time":1661556706150,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"b4484646-5632-4371-b39d-5eef692ceb67":{"role":"reader","value":{"id":"b4484646-5632-4371-b39d-5eef692ceb67","version":2,"type":"text","properties":{"title":[["假设有2个线程运行在一个处理器上，从运行一个线程(T1)切换到另一个线程(T2)时，一定会发生上下文切换。对于进程，我们需要将状态保存到进程控制块(PCB)中，现在我们需要一个或多个线程控制块(TCB)来保存每个线程的状态，但是和进程上下文切换相比，线程在进行上下文切换的时候"],["地址空间保持不变",[["b"]]],["(即不需要切换当前使用的页表)。一个拥有多线程的进程的地址空间，如下图所示，我们可以看到每个线程拥有有自己的栈。"]]},"created_time":1661556706150,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"d9deb8e7-40c7-4fe4-8eb0-bfb752060fdd":{"role":"reader","value":{"id":"d9deb8e7-40c7-4fe4-8eb0-bfb752060fdd","version":4,"type":"image","properties":{"source":[["https://user-images.githubusercontent.com/29531394/69641464-372ea300-109b-11ea-9946-b107ad6f85d5.png"]]},"format":{"block_width":432,"block_height":320,"block_full_width":false,"block_page_width":false},"created_time":1661556706150,"last_edited_time":1661557500000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"d1ecda80-7514-440c-8c23-535297a6a91b":{"role":"reader","value":{"id":"d1ecda80-7514-440c-8c23-535297a6a91b","version":2,"type":"sub_sub_header","properties":{"title":[["实现协程的理论依据"]]},"created_time":1661556706150,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"87aeecae-7857-4a4f-b90d-3d7a8e945deb":{"role":"reader","value":{"id":"87aeecae-7857-4a4f-b90d-3d7a8e945deb","version":2,"type":"text","properties":{"title":[["有栈协程就是实现了一个用户态的线程，用户可以在堆上模拟出协程的栈空间，当需要进行协程上下文切换的时候，主线程只需要交换栈空间和恢复协程的一些相关的寄存器的状态就可以实现一个用户态的线程上下文切换，没有了从用户态转换到内核态的切换成本，协程的执行也就更加高效。"]]},"created_time":1661556706150,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"bd7e22a3-e682-479d-8bd8-8fb0d4527d45":{"role":"reader","value":{"id":"bd7e22a3-e682-479d-8bd8-8fb0d4527d45","version":2,"type":"sub_header","properties":{"title":[["ucontext"]]},"created_time":1661556706150,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"406e6a66-b1dd-4932-aa08-3b88d489fe5e":{"role":"reader","value":{"id":"406e6a66-b1dd-4932-aa08-3b88d489fe5e","version":2,"type":"text","properties":{"title":[["我们参考的协程实现是云风大佬编写的coroutine，源码只有不到200行，很适合用来阅读学习。在这个版本的coroutine中，使用ucontext族函数实现。我们先来简单的看一下这个函数族的基本功能。该部分参考自博客"],["^2",[["a","https://blog.csdn.net/qq910894904/article/details/41911175"]]],["。"]]},"created_time":1661556706150,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"58990965-bc3c-41c8-9038-a68734fb08a4":{"role":"reader","value":{"id":"58990965-bc3c-41c8-9038-a68734fb08a4","version":2,"type":"text","properties":{"title":[["在类System V环境中,在头文件"],["\u003c ucontext.h \u003e ",[["c"]]],[" 中定义了两个结构类型，"],["mcontext_t",[["c"]]],[" 和 "],["ucontext_t",[["c"]]],["和四个函数"],["getcontext()",[["c"]]],[","],["setcontext()",[["c"]]],[","],["makecontext()",[["c"]]],[","],["swapcontext()",[["c"]]],[".利用它们可以在一个进程中实现用户级的线程切换。\n"],["ucontext_t",[["c"]]],[" 结构体定义如下:"]]},"created_time":1661556706151,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"1e2d64d1-197b-40f1-a1a0-46c22195ca4a":{"role":"reader","value":{"id":"1e2d64d1-197b-40f1-a1a0-46c22195ca4a","version":4,"type":"code","properties":{"title":[["typedef struct ucontext {\n  struct ucontext *uc_link;\n  sigset_t         uc_sigmask;\n  stack_t          uc_stack;\n  mcontext_t       uc_mcontext;\n  ...\n} ucontext_t;\n"]],"language":[["C"]]},"format":{"code_wrap":true},"created_time":1661556706151,"last_edited_time":1661556720000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"2e2ce295-0cf9-4c66-aef6-8aba7cc8f4eb":{"role":"reader","value":{"id":"2e2ce295-0cf9-4c66-aef6-8aba7cc8f4eb","version":2,"type":"text","properties":{"title":[["当当前上下文(如使用 "],["makecontext",[["c"]]],[" 创建的上下文）运行终止时系统会恢复"],["uc_link",[["c"]]],["指向的上下文；"],["uc_sigmask",[["c"]]],["为该上下文中的阻塞信号集合；"],["uc_stack",[["c"]]],["为该上下文中使用的栈；"],["uc_mcontext",[["c"]]],["保存的上下文的特定机器表示，包括调用线程的特定寄存器等。"]]},"created_time":1661556706151,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"74685b96-c189-4b3b-adc8-cb907e50cca5":{"role":"reader","value":{"id":"74685b96-c189-4b3b-adc8-cb907e50cca5","version":2,"type":"text","properties":{"title":[["下面讲解四个函数的作用，详细的函数使用方法参考man手册:"]]},"created_time":1661556706151,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"4ceedf79-79f2-4612-bbc7-dbe08c086a41":{"role":"reader","value":{"id":"4ceedf79-79f2-4612-bbc7-dbe08c086a41","version":2,"type":"numbered_list","properties":{"title":[["初始化ucp结构体，将当前的上下文保存到ucp中"]]},"content":["712b2725-8458-4e61-8bfd-cd393cd19ba6"],"created_time":1661556706151,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"712b2725-8458-4e61-8bfd-cd393cd19ba6":{"role":"reader","value":{"id":"712b2725-8458-4e61-8bfd-cd393cd19ba6","version":4,"type":"code","properties":{"title":[["int getcontext(ucontext_t *ucp);\n"]],"language":[["C"]]},"format":{"code_wrap":true},"created_time":1661556706151,"last_edited_time":1661556720000,"parent_id":"4ceedf79-79f2-4612-bbc7-dbe08c086a41","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"48003433-31c1-4af9-ad2a-48c27e804153":{"role":"reader","value":{"id":"48003433-31c1-4af9-ad2a-48c27e804153","version":2,"type":"numbered_list","properties":{"title":[["修改用户线程的上下文指向参数ucp，在调用makecontext之前必须调用getcontext初始化一个ucp，并且需要分配一个栈空间给初始化后的ucp，当上下文通过setcontext或者swapcontext激活后，就会紧接着调用第二个参数指向的函数func，参数argc代表 func所需的参数，在调用makecontext之前你需要初始化参数ucp-\u003euc_link，这个参数表示func()执行之后，用户线程将要切换到ucp-\u003euc_link所代表的上下文，其实是隐式的调用了setcontext函数。"]]},"content":["204cc5a0-7432-4697-9a9b-28b730ac42a4"],"created_time":1661556706151,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"204cc5a0-7432-4697-9a9b-28b730ac42a4":{"role":"reader","value":{"id":"204cc5a0-7432-4697-9a9b-28b730ac42a4","version":4,"type":"code","properties":{"title":[["void makecontext(ucontext_t *ucp, void (*func)(), int argc, ...);\n"]],"language":[["C"]]},"format":{"code_wrap":true},"created_time":1661556706151,"last_edited_time":1661556720000,"parent_id":"48003433-31c1-4af9-ad2a-48c27e804153","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"6883e37a-fadd-43e3-b77d-bc09077f8f45":{"role":"reader","value":{"id":"6883e37a-fadd-43e3-b77d-bc09077f8f45","version":2,"type":"numbered_list","properties":{"title":[["设置当前的上下文为ucp，setcontext的上下文ucp应该通过getcontext或者makecontext取得，如果调用成功则不返回。"]]},"content":["d6969ec0-5153-4171-8273-f46bad22111a"],"created_time":1661556706152,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"d6969ec0-5153-4171-8273-f46bad22111a":{"role":"reader","value":{"id":"d6969ec0-5153-4171-8273-f46bad22111a","version":4,"type":"code","properties":{"title":[["int setcontext(const ucontext_t *ucp);\n"]],"language":[["C"]]},"format":{"code_wrap":true},"created_time":1661556706152,"last_edited_time":1661556720000,"parent_id":"6883e37a-fadd-43e3-b77d-bc09077f8f45","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"b648ed22-db76-471c-8507-3d30eed58cb6":{"role":"reader","value":{"id":"b648ed22-db76-471c-8507-3d30eed58cb6","version":2,"type":"numbered_list","properties":{"title":[["保存当前上下文到oucp结构体中，然后激活upc上下文。"]]},"created_time":1661556706152,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"172b9e94-4813-42c1-a44c-e31a10bf2967":{"role":"reader","value":{"id":"172b9e94-4813-42c1-a44c-e31a10bf2967","version":4,"type":"code","properties":{"title":[["int swapcontext(ucontext_t *oucp, ucontext_t *ucp);\n"]],"language":[["C"]]},"format":{"code_wrap":true},"created_time":1661556706152,"last_edited_time":1661556780000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"aab791af-e935-4ebd-8e0b-343ac6a544c3":{"role":"reader","value":{"id":"aab791af-e935-4ebd-8e0b-343ac6a544c3","version":2,"type":"text","properties":{"title":[["写个简单的例子来看一下如何使用："]]},"created_time":1661556706152,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"6a9228c8-f496-44c6-803a-5399ed9b0246":{"role":"reader","value":{"id":"6a9228c8-f496-44c6-803a-5399ed9b0246","version":4,"type":"code","properties":{"title":[["#include \u003cucontext.h\u003e\n#include \u003cstdio.h\u003e\n\nint func(void *arg) {\n  puts(\"this is func\");\n}\n\nvoid coroutine_test() {\n  char stack[1024 * 128];\n  ucontext_t child, main;\n  // 获取当前上下文\n  getcontext(\u0026child);\n\n  // 分配栈空间 uc_stack.ss_sp 指向栈顶\n  child.uc_stack.ss_sp = stack;\n  child.uc_stack.ss_size = sizeof(stack);\n  child.uc_stack.ss_flags = 0;\n  // 指定后继上下文\n  child.uc_link = \u0026main;\n  // child.uc_link = NULL;\n\n  makecontext(\u0026child, (void (*)(void))func, 0);\n\n  //切换到child上下文，保存当前上下文到main\n  swapcontext(\u0026main, \u0026child);\n  // 如果设置了后继上下文，func函数指向完后会返回此处 如果设置为NULL，就不会执行这一步\n  puts(\"this is coroutine_test\");\n}\n\nint main() {\n  coroutine_test();\n  return 0;\n}\n"]],"language":[["C"]]},"format":{"code_wrap":true},"created_time":1661556706152,"last_edited_time":1661556780000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"1144815e-b4a4-4ff2-a510-9512fae5d994":{"role":"reader","value":{"id":"1144815e-b4a4-4ff2-a510-9512fae5d994","version":2,"type":"text","properties":{"title":[["程序的执行结果为："]]},"created_time":1661556706152,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"a695fe60-b955-4d1a-8858-45e37c881bf6":{"role":"reader","value":{"id":"a695fe60-b955-4d1a-8858-45e37c881bf6","version":4,"type":"code","properties":{"title":[["this is func\nthis is coroutine_test\n"]],"language":[["C"]]},"format":{"code_wrap":true},"created_time":1661556706152,"last_edited_time":1661556780000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"a538893a-d10a-47ca-9297-92840ebf55d8":{"role":"reader","value":{"id":"a538893a-d10a-47ca-9297-92840ebf55d8","version":2,"type":"sub_header","properties":{"title":[["coroutine实现"]]},"created_time":1661556706152,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"ed19cb98-6f5b-4567-96da-5accf18c3c19":{"role":"reader","value":{"id":"ed19cb98-6f5b-4567-96da-5accf18c3c19","version":2,"type":"text","properties":{"title":[["本文不打算详细讲解coroutine的代码实现，具体的实现细节大家可以参考文章"],["^3",[["a","https://zhuanlan.zhihu.com/p/84935949"]]],[",本文的代码注释也来自这篇文章，建议看完本节之后再阅读该文章来了解代码实现细节。通过学习了前几节讲到的基础知识，相信大家能够比较轻松的看懂协程代码的实现。本小节主要从整体的角度来讲解coroutine的实现。"]]},"created_time":1661556706152,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"a889aa77-b744-41b7-bed5-4cf9c2c34b33":{"role":"reader","value":{"id":"a889aa77-b744-41b7-bed5-4cf9c2c34b33","version":2,"type":"sub_sub_header","properties":{"title":[["coroutine例子"]]},"created_time":1661556706152,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"8ad58dab-92fc-4d99-8018-7e885a163486":{"role":"reader","value":{"id":"8ad58dab-92fc-4d99-8018-7e885a163486","version":4,"type":"code","properties":{"title":[["#include \"coroutine.h\"\n#include \u003cstdio.h\u003e\n\nstruct args {\n\tint n;\n};\n\nstatic void\nfoo(struct schedule * S, void *ud) {\n\tstruct args * arg = ud;\n\tint start = arg-\u003en;\n\tint i;\n\tfor (i=0;i\u003c5;i++) {\n\t\tprintf(\"coroutine %d : %d\\\\n\",coroutine_running(S) , start + i);\n\t\t// 切出当前协程\n\t\tcoroutine_yield(S);\n\t}\n}\n\nstatic void\ntest(struct schedule *S) {\n\tstruct args arg1 = { 0 };\n\tstruct args arg2 = { 100 };\n\n\t// 创建两个协程\n\tint co1 = coroutine_new(S, foo, \u0026arg1);\n\tint co2 = coroutine_new(S, foo, \u0026arg2);\n\tprintf(\"main start\\\\n\");\n\twhile (coroutine_status(S,co1) \u0026\u0026 coroutine_status(S,co2)) {\n\t\t// 使用协程co1\n\t\tcoroutine_resume(S,co1);\n\t\t// 使用协程co2\n\t\tcoroutine_resume(S,co2);\n\t}\n\tprintf(\"main end\\\\n\");\n}\n\nint\nmain() {\n\t// 创建一个协程调度器\n\tstruct schedule * S = coroutine_open();\n\ttest(S);\n\t// 关闭协程调度器\n\tcoroutine_close(S);\n\treturn 0;\n}\n"]],"language":[["C"]]},"format":{"code_wrap":true},"created_time":1661556706152,"last_edited_time":1661556780000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"0a0ea707-5068-417e-a782-15ea90c4b74a":{"role":"reader","value":{"id":"0a0ea707-5068-417e-a782-15ea90c4b74a","version":2,"type":"sub_sub_header","properties":{"title":[["核心对象"]]},"created_time":1661556706152,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"1b60ff74-2a97-4d4d-9b6e-3c0929a0e01d":{"role":"reader","value":{"id":"1b60ff74-2a97-4d4d-9b6e-3c0929a0e01d","version":2,"type":"numbered_list","properties":{"title":[["struct schedule* S",[["c"]]],[" 协程调度器"]]},"content":["5d12a6bb-198f-4a3a-87f1-03e678ce4680","2d319916-c6e9-4233-a006-ffa456c0449f","5185e2e6-ef95-41b9-90af-fd45fe7c4397","82231d47-d1ce-4aa6-9e99-c72c060971a1"],"created_time":1661556706153,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"5d12a6bb-198f-4a3a-87f1-03e678ce4680":{"role":"reader","value":{"id":"5d12a6bb-198f-4a3a-87f1-03e678ce4680","version":4,"type":"code","properties":{"title":[["struct schedule {\n    char stack[STACK_SIZE]; // 运行时栈，此栈即是共享栈\n    ucontext_t main; // 主协程的上下文\n    int nco;        // 当前存活的协程个数\n    int cap;        // 协程管理器的当前最大容量，即可以同时支持多少个协程。如果不够了，则进行2倍扩容\n    int running;    // 正在运行的协程ID\n    struct coroutine **co; // 一个一维数组，用于存放所有协程。其长度等于cap\n};\n"]],"language":[["C"]]},"format":{"code_wrap":true},"created_time":1661556706153,"last_edited_time":1661556780000,"parent_id":"1b60ff74-2a97-4d4d-9b6e-3c0929a0e01d","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"2d319916-c6e9-4233-a006-ffa456c0449f":{"role":"reader","value":{"id":"2d319916-c6e9-4233-a006-ffa456c0449f","version":2,"type":"text","properties":{"title":[["调度器中包含协程运行时的共享栈stack，共享栈可以认为所有的协程在运行时用的都是同一块栈，当调用协程的时候，将自己的栈拷贝到共享栈即可。当协程切出时，将栈空间再复制出来。"]]},"created_time":1661556706153,"last_edited_time":1661556660000,"parent_id":"1b60ff74-2a97-4d4d-9b6e-3c0929a0e01d","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"5185e2e6-ef95-41b9-90af-fd45fe7c4397":{"role":"reader","value":{"id":"5185e2e6-ef95-41b9-90af-fd45fe7c4397","version":2,"type":"text","properties":{"title":[["还包括主协程上下文，可以认为是协程执行完毕之后回到的上下文。"]]},"created_time":1661556706153,"last_edited_time":1661556660000,"parent_id":"1b60ff74-2a97-4d4d-9b6e-3c0929a0e01d","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"82231d47-d1ce-4aa6-9e99-c72c060971a1":{"role":"reader","value":{"id":"82231d47-d1ce-4aa6-9e99-c72c060971a1","version":2,"type":"text","properties":{"title":[["以及一个一维数组，用来存放调度器包括的所有协程。"]]},"created_time":1661556706153,"last_edited_time":1661556660000,"parent_id":"1b60ff74-2a97-4d4d-9b6e-3c0929a0e01d","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"7c6dbb6a-6ce7-494f-9455-2e5ad0d02e31":{"role":"reader","value":{"id":"7c6dbb6a-6ce7-494f-9455-2e5ad0d02e31","version":2,"type":"numbered_list","properties":{"title":[["coroutine",[["c"]]],["协程"]]},"content":["59526aa9-cd87-41cc-9f7a-1b0312caa9d7","0f224d02-df14-44e7-9282-49f90b6d5e12"],"created_time":1661556706153,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"59526aa9-cd87-41cc-9f7a-1b0312caa9d7":{"role":"reader","value":{"id":"59526aa9-cd87-41cc-9f7a-1b0312caa9d7","version":4,"type":"code","properties":{"title":[["struct coroutine {\n    coroutine_func func; // 协程所用的函数\n    void *ud;  // 协程参数\n    ucontext_t ctx; // 协程上下文\n    struct schedule * sch; // 该协程所属的调度器\n    ptrdiff_t cap;   // 已经分配的内存大小\n    ptrdiff_t size; // 当前协程运行时栈，保存起来后的大小\n    int status; // 协程当前的状态\n    char *stack; // 当前协程的保存起来的运行时栈\n};\n"]],"language":[["C"]]},"format":{"code_wrap":true},"created_time":1661556706153,"last_edited_time":1661556780000,"parent_id":"7c6dbb6a-6ce7-494f-9455-2e5ad0d02e31","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"0f224d02-df14-44e7-9282-49f90b6d5e12":{"role":"reader","value":{"id":"0f224d02-df14-44e7-9282-49f90b6d5e12","version":2,"type":"text","properties":{"title":[["coroutine",[["c"]]],["结构体包括协程需要执行的函数，协程自己的上下文，用于上下文切换，以及stack用来保存运行时栈。"]]},"created_time":1661556706153,"last_edited_time":1661556660000,"parent_id":"7c6dbb6a-6ce7-494f-9455-2e5ad0d02e31","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"11cad9c9-8bbb-4e58-9da6-9a3881dd4f0e":{"role":"reader","value":{"id":"11cad9c9-8bbb-4e58-9da6-9a3881dd4f0e","version":2,"type":"sub_sub_header","properties":{"title":[["协程状态"]]},"created_time":1661556706153,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"eb011bca-c829-4a89-a740-a355627be8ae":{"role":"reader","value":{"id":"eb011bca-c829-4a89-a740-a355627be8ae","version":2,"type":"text","properties":{"title":[["协程有4个状态，分别是READY、RUNNING、SUSPEND、DEAD这四个状态。状态转换如图所示："]]},"created_time":1661556706153,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"cb8f8b15-7af8-4c61-9ee2-dbacdee6064e":{"role":"reader","value":{"id":"cb8f8b15-7af8-4c61-9ee2-dbacdee6064e","version":4,"type":"image","properties":{"source":[["https://user-images.githubusercontent.com/29531394/69722195-7a4b4d80-1151-11ea-97e8-3c7c32c91046.png"]]},"format":{"block_width":528,"block_height":320,"block_full_width":false,"block_page_width":false},"created_time":1661556706154,"last_edited_time":1661557500000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"b868c37e-5c04-4e43-939c-472f1dfbc992":{"role":"reader","value":{"id":"b868c37e-5c04-4e43-939c-472f1dfbc992","version":2,"type":"text","properties":{"title":[["coroutine_new",[["c"]]],["函数用来创建一个协程，协程进行状态转移的核心实现位于"],["coroutine_resume",[["c"]]],["函数和"],["coroutine_yield",[["c"]]],["函数中。"]]},"created_time":1661556706154,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"88c9e887-db20-4241-bf07-c2dd44582ab6":{"role":"reader","value":{"id":"88c9e887-db20-4241-bf07-c2dd44582ab6","version":2,"type":"sub_sub_header","properties":{"title":[["READY -\u003e RUNNING"]]},"created_time":1661556706154,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"cdcb3a7c-bf51-4386-86c7-bc32e0966b73":{"role":"reader","value":{"id":"cdcb3a7c-bf51-4386-86c7-bc32e0966b73","version":2,"type":"text","properties":{"title":[["我们现看一下从READY状态转移到RUNNING状态进行的操作，和我们上面讲ucontext举的例子一样。首先，我们初始化协程的上下文，将协程的栈空间指向调度器中的共享栈，uc_link参数设定为S-\u003emain，当执行完makecontext指定的函数之后就会返回到调用coroutine_resume函数的地方。"]]},"created_time":1661556706154,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"b42e961a-ffb3-43c8-8756-dac03c1d84b0":{"role":"reader","value":{"id":"b42e961a-ffb3-43c8-8756-dac03c1d84b0","version":4,"type":"code","properties":{"title":[["// coroutine_resume\nswitch(status) {\n\tcase COROUTINE_READY:\n\t    //初始化ucontext_t结构体,将当前的上下文放到C-\u003ectx里面\n\t\tgetcontext(\u0026C-\u003ectx);\n\t\t// 将当前协程的运行时栈的栈顶设置为S-\u003estack，每个协程都这么设置，这就是所谓的共享栈。（注意，这里是栈顶）\n\t\tC-\u003ectx.uc_stack.ss_sp = S-\u003estack;\n\t\tC-\u003ectx.uc_stack.ss_size = STACK_SIZE;\n\t\tC-\u003ectx.uc_link = \u0026S-\u003emain; // 如果协程执行完，将切换到主协程中执行\n\t\tS-\u003erunning = id;\n\t\tC-\u003estatus = COROUTINE_RUNNING;\n\n\t\t// 设置执行C-\u003ectx函数, 并将S作为参数传进去\n\t\tuintptr_t ptr = (uintptr_t)S;\n\t\tmakecontext(\u0026C-\u003ectx, (void (*)(void)) mainfunc, 2, (uint32_t)ptr, (uint32_t)(ptr\u003e\u003e32));\n\n\t\t// 将当前的上下文放入S-\u003emain中，并将C-\u003ectx的上下文替换到当前上下文\n\t\tswapcontext(\u0026S-\u003emain, \u0026C-\u003ectx);\n\t\tbreak;\n"]],"language":[["C"]]},"format":{"code_wrap":true},"created_time":1661556706154,"last_edited_time":1661556780000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"24ebdf94-9fc9-4b7e-9b1b-c3639003386b":{"role":"reader","value":{"id":"24ebdf94-9fc9-4b7e-9b1b-c3639003386b","version":2,"type":"sub_sub_header","properties":{"title":[["RUNNING -\u003e SUSPEND"]]},"created_time":1661556706154,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"cd4a64fa-e1c1-4544-b095-86a35449f23d":{"role":"reader","value":{"id":"cd4a64fa-e1c1-4544-b095-86a35449f23d","version":2,"type":"text","properties":{"title":[["当执行coroutine_yield函数之后，我们看到程序会首先保存当前协程的运行时栈，然后把协程的状态修改为挂起状态，并切换到主协程中。"]]},"created_time":1661556706154,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"419483df-3da3-4239-b638-85cb1d11c714":{"role":"reader","value":{"id":"419483df-3da3-4239-b638-85cb1d11c714","version":4,"type":"code","properties":{"title":[["void\ncoroutine_yield(struct schedule * S) {\n\t// 取出当前正在运行的协程\n\tint id = S-\u003erunning;\n\tassert(id \u003e= 0);\n\n\tstruct coroutine * C = S-\u003eco[id];\n\tassert((char *)\u0026C \u003e S-\u003estack);\n\n\t// 将当前运行的协程的栈内容保存起来\n\t_save_stack(C,S-\u003estack + STACK_SIZE);\n\n\t// 将当前栈的状态改为 挂起\n\tC-\u003estatus = COROUTINE_SUSPEND;\n\tS-\u003erunning = -1;\n\n\t// 所以这里可以看到，只能从协程切换到主协程中\n\tswapcontext(\u0026C-\u003ectx , \u0026S-\u003emain);\n}\n"]],"language":[["C"]]},"format":{"code_wrap":true},"created_time":1661556706154,"last_edited_time":1661556780000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"ba4b1cea-1dca-4674-afa8-1298753520d2":{"role":"reader","value":{"id":"ba4b1cea-1dca-4674-afa8-1298753520d2","version":2,"type":"sub_sub_header","properties":{"title":[["SUSPEND -\u003e RUNNING"]]},"created_time":1661556706154,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"39186355-e05b-4c83-b109-ca7455af7e52":{"role":"reader","value":{"id":"39186355-e05b-4c83-b109-ca7455af7e52","version":2,"type":"text","properties":{"title":[["当从挂起状态恢复为执行状态时，会将协程的运行时栈拷贝到共享栈，并再次切换上下文回到调用coroutine_yield函数的地方。"]]},"created_time":1661556706154,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"e6f45e9c-f5c2-4893-a08c-2ba13bd4ee46":{"role":"reader","value":{"id":"e6f45e9c-f5c2-4893-a08c-2ba13bd4ee46","version":4,"type":"code","properties":{"title":[["\tcase COROUTINE_SUSPEND:\n\t    // 将协程所保存的栈的内容，拷贝到当前运行时栈中\n\t\t// 其中C-\u003esize在yield时有保存\n\t\tmemcpy(S-\u003estack + STACK_SIZE - C-\u003esize, C-\u003estack, C-\u003esize);\n\t\tS-\u003erunning = id;\n\t\tC-\u003estatus = COROUTINE_RUNNING;\n\t\tswapcontext(\u0026S-\u003emain, \u0026C-\u003ectx);\n\t\tbreak;\n"]],"language":[["C"]]},"format":{"code_wrap":true},"created_time":1661556706154,"last_edited_time":1661556780000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"d0cc1bb5-a9c4-4b9d-83c3-ccc5ac91f075":{"role":"reader","value":{"id":"d0cc1bb5-a9c4-4b9d-83c3-ccc5ac91f075","version":2,"type":"sub_sub_header","properties":{"title":[["运行栈保存"]]},"created_time":1661556706154,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"423eda57-4a61-4363-b779-0ad78643c5d1":{"role":"reader","value":{"id":"423eda57-4a61-4363-b779-0ad78643c5d1","version":2,"type":"text","properties":{"title":[["当执行coroutine_yield函数的时候，会发现该函数会调用"],["_save_stack",[["c"]]],["将当前协程的栈保存起来，因为coroutine是基于共享栈的，所以协程的栈内容需要单独保存起来。这里有一个很trick的点，那就是当前协程的运行栈怎么保存起来，也就是如何获取协程的栈空间。"]]},"created_time":1661556706155,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"e3936f41-19dc-4a64-b304-ec3ef3bbe451":{"role":"reader","value":{"id":"e3936f41-19dc-4a64-b304-ec3ef3bbe451","version":2,"type":"text","properties":{"title":[["一开始我们会在初始化调度器的时候设置共享栈的大小，stack指向栈顶，为了降低内存的占用，我们保存协程栈的时候不会直接保存一份和共享栈一样大小的栈空间，这时候我们需要找到该协程的栈顶位置。"]]},"created_time":1661556706155,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"30e6db8c-ecd8-472f-8de7-3f1ad30ef808":{"role":"reader","value":{"id":"30e6db8c-ecd8-472f-8de7-3f1ad30ef808","version":2,"type":"text","properties":{"title":[["下面代码的实现非常巧妙，他声明了一个局部变量dummy，而dummy的地址就是栈顶位置，大家可以参考上面讲的foo函数栈增长部分，相信你一定也能想到。"]]},"created_time":1661556706155,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"1f4a13e5-bb6f-48bb-85e6-dbe68007b3bc":{"role":"reader","value":{"id":"1f4a13e5-bb6f-48bb-85e6-dbe68007b3bc","version":4,"type":"code","properties":{"title":[["static void\n_save_stack(struct coroutine *C, char *top) {\n\t// 这个dummy很关键，是求取整个栈的关键\n\t// 这个非常经典，涉及到linux的内存分布，栈是从高地址向低地址扩展，因此\n\t// S-\u003estack + STACK_SIZE就是运行时栈的栈底\n\t// dummy，此时在栈中，肯定是位于最底的位置的，即栈顶\n\t// top - \u0026dummy 即整个栈的容量\n\tchar dummy = 0;\n\tassert(top - \u0026dummy \u003c= STACK_SIZE);\n\tif (C-\u003ecap \u003c top - \u0026dummy) {\n\t\tfree(C-\u003estack);\n\t\tC-\u003ecap = top-\u0026dummy;\n\t\tC-\u003estack = malloc(C-\u003ecap);\n\t}\n\tC-\u003esize = top - \u0026dummy;\n\tmemcpy(C-\u003estack, \u0026dummy, C-\u003esize);\n}\n"]],"language":[["C"]]},"format":{"code_wrap":true},"created_time":1661556706155,"last_edited_time":1661556780000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"bcd91fbe-d7b7-42e5-817a-dde056786718":{"role":"reader","value":{"id":"bcd91fbe-d7b7-42e5-817a-dde056786718","version":2,"type":"sub_header","properties":{"title":[["goroutine实现"]]},"created_time":1661556706155,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"fd04136b-3fca-4e06-b420-1acb1f1e4c9b":{"role":"reader","value":{"id":"fd04136b-3fca-4e06-b420-1acb1f1e4c9b","version":2,"type":"text","properties":{"title":[["golang语言中的goroutine也是一个有栈协程，但是和本文讲到的coroutine还是有很大不同，首先golang有自己的协程调度器，而且golang的协程是抢占式执行的，关于golang的协程要写的东西还是太多了，得再开一篇文章讨论，大家可以阅读下面的文章有个深入的了解。"]]},"created_time":1661556706155,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"6a98cd37-4a7a-4f25-93e7-2bbc8b6b2112":{"role":"reader","value":{"id":"6a98cd37-4a7a-4f25-93e7-2bbc8b6b2112","version":2,"type":"text","properties":{"title":[["深入golang-runtime的调度",[["a","https://zboya.github.io/post/go_scheduler/#%E6%B7%B1%E5%85%A5golang-runtime%E7%9A%84%E8%B0%83%E5%BA%A6"]]]]},"created_time":1661556706155,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"e90453a6-2572-4b13-a863-fb9614226ac9":{"role":"reader","value":{"id":"e90453a6-2572-4b13-a863-fb9614226ac9","version":2,"type":"sub_header","properties":{"title":[["参考文献"]]},"created_time":1661556706155,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"2abd4881-33d4-45c2-8ba0-94dae3f3020f":{"role":"reader","value":{"id":"2abd4881-33d4-45c2-8ba0-94dae3f3020f","version":2,"type":"numbered_list","properties":{"title":[["Operating Systems",[["a","https://book.douban.com/subject/19973015/"]]]]},"created_time":1661556706155,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"2b574031-7130-4de5-b0a6-a34c9ab0c10a":{"role":"reader","value":{"id":"2b574031-7130-4de5-b0a6-a34c9ab0c10a","version":2,"type":"numbered_list","properties":{"title":[["程序员的自我修养",[["a","https://book.douban.com/subject/3652388/"]]]]},"created_time":1661556706155,"last_edited_time":1661556660000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"5ae9dad7-9b53-445a-a1e6-75637ffe93d0":{"role":"reader","value":{"id":"5ae9dad7-9b53-445a-a1e6-75637ffe93d0","version":3,"type":"text","created_time":1666627560000,"last_edited_time":1666627560000,"parent_id":"091a74ac-4142-4f28-ba1d-5c9810ccc648","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"dd2baae1-8900-4073-854b-bdde392d5b36":{"role":"reader","value":{"id":"dd2baae1-8900-4073-854b-bdde392d5b36","version":67,"type":"page","properties":{"title":[["About"]]},"content":["e34dbc42-98d0-4e1d-ad9e-dc6631aa7273","36cdda23-4789-4ff5-8d18-99142f89bec4","770dde4e-b74e-4848-8b48-8b1ce3c111ea","2ca1f27b-da43-46f8-b8c0-ef3e05e583d9"],"format":{"page_icon":"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0dba7a3b-a420-477f-a184-076421f71ce6/external-author-literature-flaticons-lineal-color-flat-icons-2.png"},"permissions":[{"role":"editor","type":"user_permission","user_id":"d1805983-7869-451d-bf8b-64135a5d4ee7"},{"role":"reader","type":"public_permission","added_timestamp":1666532032810}],"created_time":1666531980000,"last_edited_time":1666625040000,"parent_id":"314bb437-f8b5-44ca-a749-b2b1413baa58","parent_table":"block","alive":true,"file_ids":["5349e794-a695-40dd-8bb5-4ea012d8b3f0","0dba7a3b-a420-477f-a184-076421f71ce6"],"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"314bb437-f8b5-44ca-a749-b2b1413baa58":{"role":"reader","value":{"id":"314bb437-f8b5-44ca-a749-b2b1413baa58","version":5,"type":"column","content":["dd2baae1-8900-4073-854b-bdde392d5b36"],"format":{"column_ratio":0.5},"created_time":1666625040000,"last_edited_time":1666625040000,"parent_id":"82aad922-cb77-4452-81bf-56f4e8e5a408","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"82aad922-cb77-4452-81bf-56f4e8e5a408":{"role":"reader","value":{"id":"82aad922-cb77-4452-81bf-56f4e8e5a408","version":5,"type":"column_list","content":["314bb437-f8b5-44ca-a749-b2b1413baa58","c7c8db4e-2a84-4461-9042-c0ccd0c86b7a"],"created_time":1666625040000,"last_edited_time":1666625040000,"parent_id":"72a66971-7cf6-42c2-a252-4439d99d8f44","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}},"e34dbc42-98d0-4e1d-ad9e-dc6631aa7273":{"role":"reader","value":{"id":"e34dbc42-98d0-4e1d-ad9e-dc6631aa7273","version":385,"type":"text","properties":{"title":[["你好呀！欢迎访问我的博客，我是 yangsoon，一名从事 Paas 开发的程序员，一直想写一些不一样的文章，不过一直在当鸽子…"]]},"created_time":1666624500000,"last_edited_time":1666624920000,"parent_id":"dd2baae1-8900-4073-854b-bdde392d5b36","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","last_edited_by_table":"notion_user","last_edited_by_id":"d1805983-7869-451d-bf8b-64135a5d4ee7","space_id":"fe0e4127-6cf7-4d6d-8491-aa23773532f6"}}},"collection":{},"collection_view":{},"notion_user":{},"collection_query":{},"signed_urls":{},"preview_images":{"notion.so/image/s3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fefaf9256-833c-41b8-a88d-7466ca5ceeb9%2Fsrchttp___img.pconline.com.cn_images_nospd_upload_upc_tx_pcdlc_2108_16_c7_274750145_1629102176621.pngreferhttp___img.pconline.com.webp":{"originalWidth":300,"originalHeight":300,"dataURIBase64":"data:image/webp;base64,UklGRogAAABXRUJQVlA4IHwAAADQAgCdASoQABAABUB8JbACdLoBEgJYA3hwE060yiUAAPniKR3//rNoOA5ydw/LvYqgV0qR2DrsJmjDGyD2KmZqxz5/S3m+qLbmRvFHdFy9Ts/7z+ptWH5IOU9WRTwIRj6LWzl0y0iuMboS/pwOogpygAqWCKxnHeVh5dAA"},"notion.so/image/s3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F37907dd5-3c76-4966-a419-daa027a84972%2FIMG_2189.jpg":{"originalWidth":688,"originalHeight":689,"dataURIBase64":"data:image/webp;base64,UklGRmoAAABXRUJQVlA4IF4AAABQAgCdASoQABAABUB8JbACdH8AF6kqWZq7wgAA/tFZccfpD5SaLC06Ab1xNlhuQgaC2peDlG2wJ+PIWe8AtNjEYYN+9hybVKfEbmvVGYOWRzw8xmakIGSWE0zkkYAA"},"notion.so/image/user-images.githubusercontent.com%2F29531394%2F69554356-a42f3380-0fdc-11ea-9cf6-21c7d4b62bcc.png":{"originalWidth":619,"originalHeight":661,"dataURIBase64":"data:image/webp;base64,UklGRqgAAABXRUJQVlA4WAoAAAAQAAAADgAADwAAQUxQSDMAAAARHyAQICSY8p9kIyKCEwph24quUQpJ5JPE5ymJL9O+pxDR/wkAiD1gnV7kohf50oNPhh0AVlA4IE4AAADwAQCdASoPABAABUB8JaQAAutGoKpVACAA/sbs09pMqec2+5VB8bhHjWHUUcPQUb/plDIax+e3PgpELzTyatlp7I8HBN6YPOS6tRGEwAA="},"notion.so/image/user-images.githubusercontent.com%2F29531394%2F69641429-2847f080-109b-11ea-80fa-fab3c148dba6.png":{"originalWidth":730,"originalHeight":595,"dataURIBase64":"data:image/webp;base64,UklGRqQAAABXRUJQVlA4WAoAAAAQAAAADwAADAAAQUxQSD8AAAARL0AWYBqcxATqTKWICHw6MIQk2dU8g12HJxABflB4/jAZIaL/E8DF9P9xeHpvAwqMkj0LArxA8soLAbYnIAMAVlA4ID4AAACQAQCdASoQAA0ABUB8JaQAAxOugwAA/iP13arNx8635mco3NDCVXFs1PDCgj30VAFzg8swIJ4QlGbSAAAAAA=="},"notion.so/image/user-images.githubusercontent.com%2F29531394%2F69556981-be6b1080-0fe0-11ea-8f46-9ef60c77f161.png":{"originalWidth":842,"originalHeight":595,"dataURIBase64":"data:image/webp;base64,UklGRooAAABXRUJQVlA4WAoAAAAQAAAADwAACgAAQUxQSEsAAAARL6C2bRsWe+tJRARq9sEQkmRXg/D3nsCFJ5C+QCL4/jjfIaL/yV9ykyDW6NMgVtZVEGvWLBjvdX4dVLIIUEYbBsp1Pw2kKAngaAAAVlA4IBgAAAAwAQCdASoQAAsABUB8JaQAA3AA/vDmwAA="},"notion.so/image/user-images.githubusercontent.com%2F29531394%2F69641464-372ea300-109b-11ea-9946-b107ad6f85d5.png":{"originalWidth":476,"originalHeight":595,"dataURIBase64":"data:image/webp;base64,UklGRtIAAABXRUJQVlA4WAoAAAAQAAAADAAADwAAQUxQSEYAAAARL0AWYBqcyBjqzqCICHxWMIhsq8o+KOAzCjRwaOC8/mH8Rojo/wR4GZK8clZVZ4w5GgQca63GWVX9tzHn3CEgr8iMy5YAVlA4IGYAAAAwAgCdASoNABAABUB8JaQAD4/QcnUXphhgAAD2diNmVipdFFv+rBSPpMFudUL0vfcYZAFBQiXBjqAn5fvJ2p+k19bq5xHrU0IrB8cU3QzbCEa5VGFa699BrcAXwwa3kf0ftOE4AAA="},"notion.so/image/user-images.githubusercontent.com%2F29531394%2F69722195-7a4b4d80-1151-11ea-97e8-3c7c32c91046.png":{"originalWidth":637,"originalHeight":554,"dataURIBase64":"data:image/webp;base64,UklGRoYAAABXRUJQVlA4WAoAAAAQAAAADwAADQAAQUxQSEcAAAARL6CmbQMW9tuNiACzFwwiWXVzoICgoBlIdRD/pn7RENH/CWBtvvhm1Mw8pATiufpXwA9pgFNNhsQSiOfSWwZjQNKN8Wp2AQBWUDggGAAAADABAJ0BKhAADgAFQHwlpAADcAD+8ObAAA=="},"notion.so/image/s3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F0dba7a3b-a420-477f-a184-076421f71ce6%2Fexternal-author-literature-flaticons-lineal-color-flat-icons-2.png":{"originalWidth":344,"originalHeight":344,"dataURIBase64":"data:image/webp;base64,UklGRgYBAABXRUJQVlA4WAoAAAAQAAAADwAADwAAQUxQSGAAAAARL6CgbRsWl9HdiYhAnmc4imRbdeaDAN5Dkv1HAwEBD8a/mHwREf2fAP63E2jmRgdIbnpB/gWVSd/6Y4jXqi+6eE3ZklXrpoCg4wOI+mqBoH6rOwu2rPaQ1QuIagk06x1WUDgggAAAAHACAJ0BKhAAEAAFQHwlsAJ0R/+LWgkUM4NVd5AA/rtbZbCprBwJYTawRmnxqObC6UoHxQOAyP45DLubktnwStm7LKtJSL6WMCqMYDO8enIhkQosGTqWt/7Q+0BPJrbirZZnq7LoBuu3p27kJfYvstk8am+7iRUU424iZ9A45gAA"}}},"pageId":"091a74ac-4142-4f28-ba1d-5c9810ccc648"},"__N_SSG":true},"page":"/[pageId]","query":{"pageId":"有栈协程实现原理"},"buildId":"WsfZtM41_p-Eb0XA4aeJC","isFallback":false,"dynamicIds":[3358],"gsp":true,"scriptLoader":[]}</script></body></html>