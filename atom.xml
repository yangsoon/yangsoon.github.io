<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yangsoon</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yangsoon.github.io/"/>
  <updated>2018-04-12T14:49:05.877Z</updated>
  <id>https://yangsoon.github.io/</id>
  
  <author>
    <name>yangs</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python Tricks</title>
    <link href="https://yangsoon.github.io/2018/04/07/Python-Tricks/"/>
    <id>https://yangsoon.github.io/2018/04/07/Python-Tricks/</id>
    <published>2018-04-07T14:33:30.000Z</published>
    <updated>2018-04-12T14:49:05.877Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>发现了<a href="https://github.com/brennerm/PyTricks" target="_blank" rel="noopener">PyTricks</a>这个仓库，教你写出更优雅的python代码。不定期更新</p><a id="more"></a><h2 id="元组和字典的解包"><a href="#元组和字典的解包" class="headerlink" title="元组和字典的解包"></a>元组和字典的解包</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">produce</span><span class="params">(a, b)</span>:</span></div><div class="line">    print(a*b)</div><div class="line">argument1 = (<span class="number">1</span>, <span class="number">2</span>)</div><div class="line">argument2 =&#123;<span class="string">'a'</span>:<span class="number">1</span>, <span class="string">'b'</span>:<span class="number">2</span>&#125;</div><div class="line"></div><div class="line">produce(*argument1)</div><div class="line">produce(**argument2)</div></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2</div><div class="line">2</div></pre></td></tr></table></figure><h2 id="不使用if-else实现一个计算器"><a href="#不使用if-else实现一个计算器" class="headerlink" title="不使用if else实现一个计算器"></a>不使用if else实现一个计算器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> operator</div><div class="line"></div><div class="line">ops = &#123;</div><div class="line">    <span class="string">'+'</span>: operator.add,</div><div class="line">    <span class="string">'-'</span>: operator.sub,</div><div class="line">    <span class="string">'*'</span>: operator.mul,</div><div class="line">    <span class="string">'/'</span>: operator.truediv</div><div class="line">&#125;</div><div class="line"></div><div class="line">x = input(<span class="string">"Enter an operator [OPTIONS: +, -, *, /]: "</span>)</div><div class="line">y = int(input(<span class="string">"x:"</span>))</div><div class="line">z = int(input(<span class="string">"y:"</span>))</div><div class="line"></div><div class="line">print(ops[x](y,z))</div></pre></td></tr></table></figure><h2 id="使用运算符进行链式比较"><a href="#使用运算符进行链式比较" class="headerlink" title="使用运算符进行链式比较"></a>使用运算符进行链式比较</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = <span class="number">10</span></div><div class="line">print(<span class="number">1</span> &lt; a &lt; <span class="number">50</span>)</div><div class="line">print(<span class="number">10</span> == a &lt; <span class="number">20</span>)</div></pre></td></tr></table></figure><h2 id="优雅的更新字典"><a href="#优雅的更新字典" class="headerlink" title="优雅的更新字典"></a>优雅的更新字典</h2><p>当我们想再字典里更新值时 会先判断字典里是否存在key，但使用<code>dict.setdefault</code>, <code>dict.get</code> 和 <code>collections.defaultdict</code> 会使代码简洁干净</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">d = &#123;&#125;</div><div class="line">d.setdefault(<span class="string">'a'</span>, []).append(<span class="number">1</span>)</div><div class="line"><span class="comment"># 当字典中不存在key时 返回默认值 0</span></div><div class="line">d[<span class="string">'b'</span>] = d.get(<span class="string">'b'</span>, <span class="number">0</span>) + <span class="number">1</span></div><div class="line">print(d)</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</div><div class="line">d = defaultdict(list)</div><div class="line">d[<span class="string">'a'</span>].append(<span class="number">1</span>)</div><div class="line">print(d)</div></pre></td></tr></table></figure><h2 id="使用内置的sorted-函数和key参数对字典的值进行排序"><a href="#使用内置的sorted-函数和key参数对字典的值进行排序" class="headerlink" title="使用内置的sorted()函数和key参数对字典的值进行排序"></a>使用内置的sorted()函数和key参数对字典的值进行排序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">d = &#123;<span class="string">'apple'</span>: <span class="number">10</span>, <span class="string">'orange'</span>: <span class="number">20</span>, <span class="string">'banana'</span>: <span class="number">5</span>, <span class="string">'rotten tomato'</span>: <span class="number">1</span>&#125;</div><div class="line">print(sorted(d.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>]))</div><div class="line">print(sorted(d, key=d.get))</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</div><div class="line">print(sorted(d.items(), key=itemgetter(<span class="number">1</span>)))</div></pre></td></tr></table></figure><h2 id="交换字典里的键和值"><a href="#交换字典里的键和值" class="headerlink" title="交换字典里的键和值"></a>交换字典里的键和值</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">_dict = &#123;<span class="string">"one"</span>: <span class="number">1</span>, <span class="string">"two"</span>: <span class="number">2</span>&#125;</div><div class="line">reversed_dict = &#123;v: k <span class="keyword">for</span> k, v <span class="keyword">in</span> _dict.items()&#125;</div><div class="line">print(reversed_dict)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;发现了&lt;a href=&quot;https://github.com/brennerm/PyTricks&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PyTricks&lt;/a&gt;这个仓库，教你写出更优雅的python代码。不定期更新&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>tornado异步编程</title>
    <link href="https://yangsoon.github.io/2018/03/19/tornado%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    <id>https://yangsoon.github.io/2018/03/19/tornado异步编程/</id>
    <published>2018-03-19T09:47:00.000Z</published>
    <updated>2018-03-21T08:50:44.112Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>记录一下使用tornado进行异步编程的简单代码，如果你看过我之前写的关于asyncio的<a href="/2018/03/16/asyncio-初探/">文章</a>你会发现使用tornado和使用asyncio的模式大致上一样。talk is easy, show you the code。下面的demo大部分都来自<a href="http://www.tornadoweb.org/en/stable/" target="_blank" rel="noopener">官方文档</a>,部分进行了修改。</p><a id="more"></a><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><h4 id="1-同步网络请求"><a href="#1-同步网络请求" class="headerlink" title="1. 同步网络请求"></a>1. 同步网络请求</h4><p>第一个demo是使用tornado进行同步编程的例子，这里是为了和下面的异步版本进行比较，我们使用tornado自带的同步网络请求来进行测试。例子很简单，没有什么要说明的，其中结果显示，使用了一个回调函数，请求结束后会调用回调函数，输出结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> tornado.httpclient <span class="keyword">import</span> HTTPClient</div><div class="line"><span class="keyword">from</span> time <span class="keyword">import</span> strftime</div><div class="line"></div><div class="line">urls = [</div><div class="line">    <span class="string">'http://163.com'</span>,</div><div class="line">    <span class="string">'http://baidu.com'</span></div><div class="line">]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sync_fetch</span><span class="params">(url ,callback)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handler_result</span><span class="params">(response)</span>:</span></div><div class="line">        callback(response)</div><div class="line">    </div><div class="line">    http_client = HTTPClient()</div><div class="line">    http_client.fetch(url, callback=handler_result)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sync_fetch_callback</span><span class="params">(response)</span>:</span></div><div class="line">    print(strftime(<span class="string">'[%H:%M:%S]'</span>),end=<span class="string">' '</span>)</div><div class="line">    print(<span class="string">'url:&#123;&#125; state:&#123;&#125; time:&#123;&#125;'</span>.format(</div><div class="line">        response.request.url, response.code, response.request_time))</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</div><div class="line">        sync_fetch(url, sync_fetch_callback)</div></pre></td></tr></table></figure><p>输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[16:11:43] url:http://163.com state:200 time:0.15146231651306152</div><div class="line">[16:11:43] url:http://baidu.com state:200 time:0.06663918495178223</div></pre></td></tr></table></figure></p><h4 id="2-异步网络请求"><a href="#2-异步网络请求" class="headerlink" title="2.异步网络请求"></a>2.异步网络请求</h4><p>下面的demo的一个异步版本，使用了tornado自带的<code>AsyncHTTPClient</code>，<code>fetch</code>方法是一个协程函数，和asyncio一样，协程函数需要用<code>@gen.coroutine</code>装饰，使用yield等待请求结果返回。但是不会阻塞主线程，其中<code>yield list</code>会并行等待list中的元素。<code>tornado.ioloop.IOLoop.current()</code>会获取到当前的事件循环对象，<code>loop.run_sync(main)</code>会在main执行完成后，关闭事件循环。是不是和asyncio和很像，有没有，有没有？通过和上面的输出结果对比，可以发现因为访问baidu更快，所以最先输出访问baidu的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> tornado</div><div class="line"><span class="keyword">from</span> tornado <span class="keyword">import</span> gen</div><div class="line"><span class="keyword">from</span> time <span class="keyword">import</span> strftime</div><div class="line"><span class="keyword">from</span> tornado.httpclient <span class="keyword">import</span> AsyncHTTPClient</div><div class="line"></div><div class="line">urls = [</div><div class="line">    <span class="string">'http://163.com'</span>,</div><div class="line">    <span class="string">'http://baidu.com'</span></div><div class="line">]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">format_print</span><span class="params">(response)</span>:</span></div><div class="line">    print(strftime(<span class="string">'[%H:%M:%S]'</span>),end=<span class="string">' '</span>)</div><div class="line">    print(<span class="string">'url:&#123;&#125; state:&#123;&#125; time:&#123;&#125;'</span>.format(</div><div class="line">        response.request.url, response.code, response.request_time))</div><div class="line"></div><div class="line"><span class="meta">@gen.coroutine</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">async_fetch</span><span class="params">(url)</span>:</span></div><div class="line">    http_client = AsyncHTTPClient()</div><div class="line">    res = <span class="keyword">yield</span> http_client.fetch(url)</div><div class="line">    format_print(res)</div><div class="line"></div><div class="line"><span class="meta">@gen.coroutine</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">yield</span> [async_fetch(url) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    loop = tornado.ioloop.IOLoop.current()</div><div class="line">    loop.run_sync(main)</div></pre></td></tr></table></figure><p>输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[16:13:16] url:http://baidu.com state:200 time:0.06943202018737793</div><div class="line">[16:13:16] url:http://163.com state:200 time:0.15732026100158691</div></pre></td></tr></table></figure></p><h4 id="3-经典demo"><a href="#3-经典demo" class="headerlink" title="3. 经典demo"></a>3. 经典demo</h4><p>为什么说是经典demo呢，因为之前的asyncio中的demo都是使用阻塞或者非阻塞的sleep函数来模拟实际的函数操作。和asyncio一样，tornado提供了不阻塞的sleep函数 <code>gen.sleep</code>。下面的例子和之前asyncio中的例子基本一样，所以就不进行说明了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> time <span class="keyword">import</span> strftime</div><div class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop</div><div class="line"><span class="keyword">from</span> tornado <span class="keyword">import</span> gen</div><div class="line"></div><div class="line"><span class="meta">@gen.coroutine</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">noblock_sleep</span><span class="params">(t)</span>:</span></div><div class="line">    print(strftime(<span class="string">'[%H:%M:%S]'</span>), end=<span class="string">' '</span>)</div><div class="line">    print(<span class="string">'func &#123;&#125; is running &#123;&#125;s'</span>.format(t, t))</div><div class="line">    <span class="keyword">yield</span> gen.sleep(t)</div><div class="line">    print(strftime(<span class="string">'[%H:%M:%S]'</span>), end=<span class="string">' '</span>)</div><div class="line">    print(<span class="string">'func &#123;&#125; is finished'</span>.format(t))</div><div class="line"></div><div class="line"><span class="meta">@gen.coroutine</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">yield</span> [noblock_sleep(t) <span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">6</span>)]</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    loop = IOLoop.current()</div><div class="line">    loop.run_sync(main)</div></pre></td></tr></table></figure><p>输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[16:24:12] func 1 is running 1s</div><div class="line">[16:24:12] func 2 is running 2s</div><div class="line">[16:24:12] func 3 is running 3s</div><div class="line">[16:24:12] func 4 is running 4s</div><div class="line">[16:24:12] func 5 is running 5s</div><div class="line">[16:24:13] func 1 is finished</div><div class="line">[16:24:14] func 2 is finished</div><div class="line">[16:24:15] func 3 is finished</div><div class="line">[16:24:16] func 4 is finished</div><div class="line">[16:24:17] func 5 is finished</div></pre></td></tr></table></figure></p><h4 id="4-在tornado中使用阻塞函数"><a href="#4-在tornado中使用阻塞函数" class="headerlink" title="4. 在tornado中使用阻塞函数"></a>4. 在tornado中使用阻塞函数</h4><p>没错，和asyncio一样，tornado提供了<code>loop.run_in_executor</code>执行阻塞操作。直接看代码就好，下面就不赘述了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> tornado <span class="keyword">import</span> gen</div><div class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep, strftime</div><div class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</div><div class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</div><div class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">blocked</span><span class="params">(t)</span>:</span></div><div class="line">    print(strftime(<span class="string">'[%H:%M:%S]'</span>), end=<span class="string">' '</span>)</div><div class="line">    print(<span class="string">'func &#123;&#125; is running &#123;&#125;s'</span>.format(t, t))</div><div class="line">    sleep(t)</div><div class="line">    print(strftime(<span class="string">'[%H:%M:%S]'</span>), end=<span class="string">' '</span>)</div><div class="line">    print(<span class="string">'func &#123;&#125; is end'</span>.format(t))</div><div class="line">    <span class="keyword">return</span> t</div><div class="line"></div><div class="line"><span class="meta">@gen.coroutine</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">5</span>) <span class="keyword">as</span> executor:</div><div class="line">        loop = IOLoop.current()</div><div class="line">        results = <span class="keyword">yield</span> [loop.run_in_executor(executor, blocked, t) <span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">6</span>)]</div><div class="line">        <span class="keyword">return</span> results</div><div class="line">        </div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    loop = IOLoop.current()</div><div class="line">    results = loop.run_sync(main)</div><div class="line">    print(<span class="string">'results:&#123;&#125;'</span>.format(results))</div></pre></td></tr></table></figure><p>输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[16:29:15] func 1 is running 1s</div><div class="line">[16:29:15] func 2 is running 2s</div><div class="line">[16:29:15] func 3 is running 3s</div><div class="line">[16:29:15] func 4 is running 4s</div><div class="line">[16:29:15] func 5 is running 5s</div><div class="line">[16:29:16] func 1 is end</div><div class="line">[16:29:17] func 2 is end</div><div class="line">[16:29:18] func 3 is end</div><div class="line">[16:29:19] func 4 is end</div><div class="line">[16:29:20] func 5 is end</div><div class="line">results:[1, 2, 3, 4, 5]</div></pre></td></tr></table></figure></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>这里只是简单的列出一些tornado代码，之后会开始试着阅读一下源码，近期频繁写文章，逼着自己忙一些吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;记录一下使用tornado进行异步编程的简单代码，如果你看过我之前写的关于asyncio的&lt;a href=&quot;/2018/03/16/asyncio-初探/&quot;&gt;文章&lt;/a&gt;你会发现使用tornado和使用asyncio的模式大致上一样。talk is easy, show you the code。下面的demo大部分都来自&lt;a href=&quot;http://www.tornadoweb.org/en/stable/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档&lt;/a&gt;,部分进行了修改。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>apollo主题下使用gitment</title>
    <link href="https://yangsoon.github.io/2018/03/17/apollo%E4%B8%BB%E9%A2%98%E4%B8%8B%E4%BD%BF%E7%94%A8gitment/"/>
    <id>https://yangsoon.github.io/2018/03/17/apollo主题下使用gitment/</id>
    <published>2018-03-17T11:55:18.000Z</published>
    <updated>2018-03-20T10:21:58.812Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前一直没在blog下添加评论系统，多说貌似不干了，偶然间发现了<a href="https://github.com/imsun/gitment" target="_blank" rel="noopener">gitment</a>，它是一款基于GitHub Issues 的评论系统，同时有完整的 Markdown / GFM 和代码高亮支持。感觉不错，就添加到blog下了。</p><a id="more"></a><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="1-注册-OAuth-Application"><a href="#1-注册-OAuth-Application" class="headerlink" title="1. 注册 OAuth Application"></a>1. 注册 OAuth Application</h4><p><a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">点击此处</a> 来注册一个新的 OAuth Application。其他内容可以随意填写，但要确保填入正确的 callback URL(一般是评论页面对应的域名) 你会得到一个 client ID 和一个 client secret，这个将被用于之后的用户登录。</p><h4 id="2-引入Gitment"><a href="#2-引入Gitment" class="headerlink" title="2. 引入Gitment"></a>2. 引入Gitment</h4><p>因为使用的是apollo主题，所以我们先配置 <code>_config.yml</code> 文件。只需要添加几行代码就行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># Comment</div><div class="line"># e.g disqus: seansun</div><div class="line">disqus:</div><div class="line">duoshuo:</div><div class="line">gitment:</div><div class="line">    enable: true</div><div class="line">    owner: yangsoon</div><div class="line">    repo: yangsoon.github.io</div><div class="line">    client_id: ************</div><div class="line">    client_secret: ************</div></pre></td></tr></table></figure><p>下面我们修改 <code>/themes/apollo/layout/partial</code> 目录下的 <code>comment.jade</code> 文件, 在末尾加入就行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> theme.gitment.enable</div><div class="line">    - <span class="keyword">var</span> date = page.date</div><div class="line">    #container</div><div class="line">    link(rel=<span class="string">'stylesheet'</span>, href=<span class="string">'https://imsun.github.io/gitment/style/default.css'</span>)</div><div class="line">    script(src=<span class="string">'https://imsun.github.io/gitment/dist/gitment.browser.js'</span>)</div><div class="line">    script.</div><div class="line">        <span class="keyword">var</span> gitment = <span class="keyword">new</span> Gitment(&#123;</div><div class="line">            id: <span class="string">'#&#123;date&#125;'</span>,</div><div class="line">            owner: <span class="string">'#&#123;theme.gitment.owner&#125;'</span>,</div><div class="line">            repo: <span class="string">'#&#123;theme.gitment.repo&#125;'</span>,</div><div class="line">            oauth: &#123;</div><div class="line">                client_id: <span class="string">'#&#123;theme.gitment.client_id&#125;'</span>,</div><div class="line">                client_secret: <span class="string">'#&#123;theme.gitment.client_secret&#125;'</span>,</div><div class="line">            &#125;,</div><div class="line">        &#125;)</div><div class="line">        gitment.render(<span class="string">'container'</span>)</div></pre></td></tr></table></figure><p>之后将静态页面提交到github上查看就行了，一些细节还是看看官方文档吧。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote><p><a href="https://imsun.net/posts/gitment-introduction/" target="_blank" rel="noopener">https://imsun.net/posts/gitment-introduction/</a><br><a href="https://github.com/imsun/gitment/issues/118" target="_blank" rel="noopener">https://github.com/imsun/gitment/issues/118</a><br><a href="https://wf94.github.io/2017/04/14/Use-Gitment-In-Hexo/" target="_blank" rel="noopener">https://wf94.github.io/2017/04/14/Use-Gitment-In-Hexo/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;之前一直没在blog下添加评论系统，多说貌似不干了，偶然间发现了&lt;a href=&quot;https://github.com/imsun/gitment&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gitment&lt;/a&gt;，它是一款基于GitHub Issues 的评论系统，同时有完整的 Markdown / GFM 和代码高亮支持。感觉不错，就添加到blog下了。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>asyncio中使用阻塞函数</title>
    <link href="https://yangsoon.github.io/2018/03/16/asyncio-%E5%88%9D%E6%8E%A2/"/>
    <id>https://yangsoon.github.io/2018/03/16/asyncio-初探/</id>
    <published>2018-03-16T11:11:23.000Z</published>
    <updated>2018-03-19T09:49:04.983Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>最近在学习python的异步编程标准库asyncio，在学习期间，想到如果想要在asyncio中使用阻塞的函数调用，但是不阻塞事件循环的当前线程，应该怎么操作？<br><br>例如我想在asyncio中使用第三方阻塞调用库requests(当然现在有支持异步操作的aiohttp)，或者是想用一些费时的函数计算，亦或是进行io读写。</p><a id="more"></a><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>在《流畅的python》中有这样一段话。</p><blockquote><p>函数(例如io读写，requests网络请求)阻塞了客户代码与asycio事件循环的唯一线程，因此在执行调用时，整个应用程序都会冻结。这个问题的解决方法是，使用事件循环对象的 <code>run_in_executor</code>方法。asyncio的事件循环在背后维护着一个<code>ThreadPoolExecutor</code>对象，我们可以调用<code>run_in_executor</code>方法，把可调用对象发给它执行。</p></blockquote><p>这样我们就知道了我们可以通过<code>run_in_executor</code>方法来新建一个线程来执行耗时函数。</p><h3 id="函数讲解"><a href="#函数讲解" class="headerlink" title="函数讲解"></a>函数讲解</h3><p>因为书中对<code>run_in_executor</code>函数的介绍很少，所以我们先查阅一下<a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.run_in_executor" target="_blank" rel="noopener">官方文档</a>来看一下<code>run_in_executor</code>函数的具体使用方法。</p><p>根据官方文档我们可以知道该方法返回一个协程<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">AbstractEventLoop.run_in_executor(executor, func, *args)</div><div class="line">executor 参数应该是一个 Executor 实例。如果为 <span class="keyword">None</span>，则使用默认 executor。</div><div class="line">func 就是要执行的函数</div><div class="line">*args 就是传递给 func 的参数</div></pre></td></tr></table></figure></p><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><p>下面我们就用一个简单的例子来演示一下如何使用，通过输出结果我们可以看出5个阻塞调用同时进行，在5秒后所有调用结束。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep, strftime</div><div class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</div><div class="line"></div><div class="line">executor = futures.ThreadPoolExecutor(max_workers=<span class="number">5</span>)</div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">blocked_sleep</span><span class="params">(name, t)</span>:</span></div><div class="line">    print(strftime(<span class="string">'[%H:%M:%S]'</span>),end=<span class="string">' '</span>)</div><div class="line">    print(<span class="string">'sleep &#123;&#125; is running &#123;&#125;s'</span>.format(name, t))</div><div class="line">    loop = asyncio.get_event_loop()</div><div class="line">    <span class="keyword">await</span> loop.run_in_executor(executor, sleep, t)</div><div class="line">    print(strftime(<span class="string">'[%H:%M:%S]'</span>),end=<span class="string">' '</span>)</div><div class="line">    print(<span class="string">'sleep &#123;&#125; is end'</span>.format(name))</div><div class="line">    <span class="keyword">return</span> t</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    future = (blocked_sleep(i, i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">6</span>))</div><div class="line">    fs = asyncio.gather(*future)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">await</span> fs</div><div class="line"></div><div class="line">loop = asyncio.get_event_loop()</div><div class="line">results = loop.run_until_complete(main())</div><div class="line">print(<span class="string">'results: &#123;&#125;'</span>.format(results))</div></pre></td></tr></table></figure></p><p>输出结果是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[19:49:32] sleep 3 is running 3s</div><div class="line">[19:49:32] sleep 4 is running 4s</div><div class="line">[19:49:32] sleep 1 is running 1s</div><div class="line">[19:49:32] sleep 5 is running 5s</div><div class="line">[19:49:32] sleep 2 is running 2s</div><div class="line">[19:49:33] sleep 1 is end</div><div class="line">[19:49:34] sleep 2 is end</div><div class="line">[19:49:35] sleep 3 is end</div><div class="line">[19:49:36] sleep 4 is end</div><div class="line">[19:49:37] sleep 5 is end</div><div class="line">result: [1, 2, 3, 4, 5]</div></pre></td></tr></table></figure><p><code>strftime</code>函数是为了格式化输出当前时间，比较清楚的看到调用过程。<code>blocked_sleep</code>函数通过使用<code>run_in_executor</code>方法调用阻塞的sleep()函数。</p><p>在官网中有这样<a href="https://docs.python.org/3/library/asyncio-task.html#coroutines" target="_blank" rel="noopener">一段话</a> 调用协程不会使其中的代码运行，协程对象在被排定执行时间之前都不会进行任何操作。下面有两种基本的方式来启动它的运行:</p><ol><li>在另一个协程中调用 <code>await coroutine</code> 和 <code>yield from coroutine</code> (假定另一个协程已经在执行，即在事件循环中) </li><li>使用 <code>ensure_future</code> 函数或 <code>AbstractEventLoop.create_task</code> 方法来排定执行时间。 </li></ol><p>根据上面的函数讲解我们已经知道<code>run_in_executor</code>方法返回一个协程。因此我们在<code>blocked_sleep</code>函数中驱动他的执行。</p><p>在main函数中<code>future = (blocked_sleep(i, i) for i in range(1, 6))</code>我们产生一个生成器表达式，每个元素都是一个协程。我们将future传递给gather函数。</p><p>对于gather函数的使用方法如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">asyncio.gather(*coros_or_futures, loop=<span class="keyword">None</span>, return_exceptions=<span class="keyword">False</span>)</div><div class="line">你现在知道gather返回一个包含future对象结果的list即可</div></pre></td></tr></table></figure><p>python从3.5开始就引入了新的语法 async 和 await 但是之前因为使用yield from习惯了，所以下面来一个之前的版本。大致上和上面的例子一样，有兴趣可以看一下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep, strftime</div><div class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">blocked</span><span class="params">(t)</span>:</span></div><div class="line">    print(strftime(<span class="string">'[%H:%M:%S]'</span>),end=<span class="string">' '</span>)</div><div class="line">    print(<span class="string">'&#123;&#125; sleep:&#123;&#125;s....'</span>.format(t, t))</div><div class="line">    sleep(t)</div><div class="line">    print(strftime(<span class="string">'[%H:%M:%S]'</span>),end=<span class="string">' '</span>)</div><div class="line">    print(<span class="string">'&#123;&#125; finished'</span>.format(t))</div><div class="line">    <span class="keyword">return</span> t</div><div class="line">    </div><div class="line"><span class="meta">@asyncio.coroutine</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">with</span> futures.ThreadPoolExecutor(max_workers=<span class="number">5</span>) <span class="keyword">as</span> executor:</div><div class="line">        loop = asyncio.get_event_loop()</div><div class="line">        future = [loop.run_in_executor(executor,blocked, i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">6</span>)]</div><div class="line">        fs = asyncio.wait(future)</div><div class="line">        <span class="keyword">return</span> (<span class="keyword">yield</span> <span class="keyword">from</span> fs)</div><div class="line">        </div><div class="line">loop = asyncio.get_event_loop()</div><div class="line">results, _ = loop.run_until_complete(main())</div><div class="line">print(<span class="string">'results: &#123;&#125;'</span>.format([result.result() <span class="keyword">for</span> result <span class="keyword">in</span> results]))</div></pre></td></tr></table></figure><p>输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[20:18:13] 1 sleep:1s....</div><div class="line">[20:18:13] 2 sleep:2s....</div><div class="line">[20:18:13] 3 sleep:3s....</div><div class="line">[20:18:13] 4 sleep:4s....</div><div class="line">[20:18:13] 5 sleep:5s....</div><div class="line">[20:18:14] 1 finished</div><div class="line">[20:18:15] 2 finished</div><div class="line">[20:18:16] 3 finished</div><div class="line">[20:18:17] 4 finished</div><div class="line">[20:18:18] 5 finished</div><div class="line">results: [3, 2, 1, 4, 5]</div></pre></td></tr></table></figure></p><p>在第二份代码里，我故意使用wait函数来等待任务结束，是为了记录一下不同的函数调用方法，和gather函数不同，wait函数需要传入一个list，并且返回两组Futures，(done, pending)。这就是为什么代码里使用 <code>results, _ = loop.run_until_complete(main())</code>的原因了。</p><p>下面是一个使用<code>asyncio.as_comleted</code>方法的例子，该方法返回一个协程迭代器。迭代时迭代器只返回已经完成的future。<a href="https://github.com/python/cpython/blob/3.6/Lib/asyncio/tasks.py#L412" target="_blank" rel="noopener">源码</a>中内部维护一个队列，每次迭代都从队列中返回已经完成的future的结果(result or exception)，可以注意到在输出结果中，7秒后，所以任务才完成。因为executor大小设置为5，每次只有5个线程在跑，所以在第一个block运行结束后，我们可以看到第6个block立即执行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep, strftime</div><div class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">blocked</span><span class="params">(t)</span>:</span></div><div class="line">    print(strftime(<span class="string">'[%H:%M:%S]'</span>),end=<span class="string">' '</span>)</div><div class="line">    print(<span class="string">'&#123;&#125; sleep:&#123;&#125;s....'</span>.format(t, t))</div><div class="line">    sleep(t)</div><div class="line">    print(strftime(<span class="string">'[%H:%M:%S]'</span>),end=<span class="string">' '</span>)</div><div class="line">    print(<span class="string">'&#123;&#125; finished'</span>.format(t))</div><div class="line">    <span class="keyword">return</span> t</div><div class="line"></div><div class="line"><span class="meta">@asyncio.coroutine</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">with</span> futures.ThreadPoolExecutor(max_workers=<span class="number">5</span>) <span class="keyword">as</span> executor:</div><div class="line">        loop = asyncio.get_event_loop()</div><div class="line">        future = [loop.run_in_executor(executor,blocked, i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">7</span>)]</div><div class="line">        fs = asyncio.as_completed(future)</div><div class="line">        results = []</div><div class="line">        <span class="keyword">for</span> f <span class="keyword">in</span> fs:</div><div class="line">            result = <span class="keyword">yield</span> <span class="keyword">from</span> f</div><div class="line">            results.append(result)</div><div class="line">        <span class="keyword">return</span> results</div><div class="line">  </div><div class="line">loop = asyncio.get_event_loop()</div><div class="line">results= loop.run_until_complete(main())</div><div class="line">print(<span class="string">'results: &#123;&#125;'</span>.format(results))</div></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[13:42:39] 1 sleep:1s....</div><div class="line">[13:42:39] 2 sleep:2s....</div><div class="line">[13:42:39] 3 sleep:3s....</div><div class="line">[13:42:39] 4 sleep:4s....</div><div class="line">[13:42:39] 5 sleep:5s....</div><div class="line">[13:42:40] 1 finished</div><div class="line">[13:42:40] 6 sleep:6s....</div><div class="line">[13:42:41] 2 finished</div><div class="line">[13:42:42] 3 finished</div><div class="line">[13:42:43] 4 finished</div><div class="line">[13:42:44] 5 finished</div><div class="line">[13:42:46] 6 finished</div><div class="line">results: [1, 2, 3, 4, 5, 6]</div></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在asyncio中调用阻塞函数时，需要使用asyncio维护的线程池来另开线程运行阻塞函数，防止阻塞事件循环所在的线程。</p><p>几个重要函数比较</p><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">传参</th><th style="text-align:left">返回值</th><th style="text-align:left">返回值顺序</th><th style="text-align:left"></th><th>函数意义</th></tr></thead><tbody><tr><td style="text-align:left"><code>asyncio.gather</code></td><td style="text-align:left">可以传递多个协程或者Futures，函数会自动将协程包装成task，例如协程生成器。</td><td style="text-align:left">包含Futures结果的list</td><td style="text-align:left">按照原始顺序排列</td><td style="text-align:left"></td><td>注重收集结果，等待一堆Futures并按照顺序返回结果</td></tr><tr><td style="text-align:left"><code>asyncio.wait</code></td><td style="text-align:left">a list of futures</td><td style="text-align:left">返回两个Future集合 (done, pending)</td><td style="text-align:left">无序(暂定)</td><td style="text-align:left"></td><td>是一个协程等传给他的所有协程都运行完之后结束，并不直接返回结果</td></tr><tr><td style="text-align:left"><code>asyncio.as_completed</code></td><td style="text-align:left">a list of futures</td><td style="text-align:left">返回一个协程迭代器</td><td style="text-align:left">按照完成顺序</td><td style="text-align:left"></td><td>返回的迭代器每次迭代只返回已经完成的Futures</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;p&gt;最近在学习python的异步编程标准库asyncio，在学习期间，想到如果想要在asyncio中使用阻塞的函数调用，但是不阻塞事件循环的当前线程，应该怎么操作？&lt;br&gt;&lt;br&gt;例如我想在asyncio中使用第三方阻塞调用库requests(当然现在有支持异步操作的aiohttp)，或者是想用一些费时的函数计算，亦或是进行io读写。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python 学习笔记</title>
    <link href="https://yangsoon.github.io/2018/03/15/python-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://yangsoon.github.io/2018/03/15/python-学习笔记/</id>
    <published>2018-03-15T06:24:46.000Z</published>
    <updated>2018-03-16T12:28:19.467Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>最近重新翻开《流畅的python》再一次阅读的感受和第一次看的时候又大不相同。用jupyter notebook记录了一下。<a href="https://github.com/yangsoon/python-notebooks" target="_blank" rel="noopener">地址在这</a></p><div class="tip"><br>不用点开<br></div><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;最近重新翻开《流畅的python》再一次阅读的感受和第一次看的时候又大不相同。用jupyter notebook记录了一下。&lt;a href=&quot;https://github.com/yangsoon/python-notebooks&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;地址在这&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;tip&quot;&gt;&lt;br&gt;不用点开&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>学习linux/unix系统编程手册-编译代码</title>
    <link href="https://yangsoon.github.io/2018/03/15/%E5%AD%A6%E4%B9%A0linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C-%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81/"/>
    <id>https://yangsoon.github.io/2018/03/15/学习linux系统编程手册-编译代码/</id>
    <published>2018-03-15T06:22:38.000Z</published>
    <updated>2018-03-18T12:18:03.768Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>发现每次写文章都要加个前言来瞎扯一波，最近在找实习，之前以为大四上就比较无聊了，后来发现大四下更无聊，不过也有时间来学一些自己喜欢的东西，但是经常会学着学着就打开抖音看小姐姐了，这样不行不行… 所以就要求自己争取每周都能写几篇文章来记录都学了什么。上学期的时候买了一本《linux/unix系统编程手册》里面有相应的demo代码，于是想编译一下，没错我在终端里输入了 <code>gcc demo.c</code> 。结果可想而知报了一大推错。这篇文章是小白记录文，大神就不用看了。</p><a id="more"></a><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><h4 id="1-gcc-I"><a href="#1-gcc-I" class="headerlink" title="1. gcc -I"></a>1. <code>gcc -I</code></h4><p>执行<code>gcc demo.c</code>之后，会出现这样的报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">seek_io.c:4:22: 致命错误：tlpi_hdr.h：没有那个文件或目录</div><div class="line"> #include &quot;tlpi_hdr.h&quot;</div><div class="line">                      ^</div><div class="line">编译中断。</div></pre></td></tr></table></figure><p>因为没有指定头文件<code>tlpi_hdr.h</code>的路径，所以编译器无法找到指定的头文件，所以我们需要给gcc指定对应的头文件所在路径。当然可以修改源码，用相对/绝对路径调用头文件。但是这样显然不好，如果任何文件位置发生变化，都要再次修改源码。</p><p>gcc有-I这个选项，可以把include “…”包含的文件路径放在-I后面。于是做了如下修改：</p><p>执行 <code>gcc -I /home/vagrant/project/tlpi-dist/lib demo.c</code>但是还是报错:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/tmp/ccj4Ei8K.o：在函数‘main’中：</div><div class="line">seek_io.c:(.text+0x46)：对‘usageErr’未定义的引用</div><div class="line">seek_io.c:(.text+0x80)：对‘errExit’未定义的引用</div><div class="line">seek_io.c:(.text+0x125)：对‘getLong’未定义的引用</div><div class="line">seek_io.c:(.text+0x165)：对‘errExit’未定义的引用</div><div class="line">seek_io.c:(.text+0x194)：对‘errExit’未定义的引用</div><div class="line">collect2: 错误：ld 返回 1</div></pre></td></tr></table></figure><h4 id="2-链接"><a href="#2-链接" class="headerlink" title="2. 链接"></a>2. 链接</h4><p>之后在网上查阅资料才知道，出现这种情况的原因，主要是C/C++编译为obj文件的时候并不需要函数的具体实现，只要有函数的原型即可。但是在链接为可执行文件的时候就必须要具体的实现了。如果错误是未声明的引用，那就是找不到函数的原型。</p><p>下面简单的说一下gcc编译流程 1. 预处理阶段 2. 编译阶段 3. 汇编阶段 4. 链接阶段</p><p>问题就出现在链接阶段，程序中没有定义一系列函数的实现，所以会报出上面的错误。函数库一般分为静态库和动态库两种。静态库是指编译链接时，把库文件的代码全部加入到可执行文件中，因此生成的文件比较大，但在运行时也就不再需要库文件了。其后缀名一般为”.a”。动态库与之相反，在编译链接时并没有把库文件的代码加入到可执行文件中，而是在程序执行时由运行时链接文件加载库，这样可以节省系统的开销。动态库一般后缀名为”.so”。</p><p>这时候就需要我们指定函数库的位置。很高兴，tlpi帮我们打包好了。所以继续修改:</p><p><code>gcc -I /home/vagrant/project/tlpi-dist/lib demo.c /home/vagrant/project/tlpi-dist/libtlpi.a</code> </p><p>至此我们可以编译demo.c代码了，但是每次都要输入一堆路径，确实有些烦，为了能在各处写代码，还不用输入一大堆路径，我就写了一个简单的shell脚本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">export TLPI_PATH="/home/vagrant/project/tlpi-dist"</div><div class="line">function glink()&#123;</div><div class="line">    if [ $# -ne 1 ]</div><div class="line">    then</div><div class="line">      echo "请输入一个程序名"</div><div class="line">      return</div><div class="line">    else</div><div class="line">      name=$1</div><div class="line">      echo "gcc -I $&#123;TLPI_PATH&#125;/lib $1 $&#123;TLPI_PATH&#125;/libtlpi.a -o $&#123;name%.*&#125;.o"</div><div class="line">      gcc -I $&#123;TLPI_PATH&#125;/lib $1 $&#123;TLPI_PATH&#125;/libtlpi.a -o $&#123;name%.*&#125;.o</div><div class="line">    fi</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>打开<code>.zshrc</code>或者<code>.bashrc</code>文件，加入上面的代码，<code>TLPI_PATH</code>填上你自己的文件路径，之后执行<code>source .zshrc</code>或者<code>source .bashrc</code>。然后可以用 <code>glink demo.c</code>来编译自己的代码。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote><p><a href="http://www.cnblogs.com/xbf9xbf/p/4755458.html" target="_blank" rel="noopener">http://www.cnblogs.com/xbf9xbf/p/4755458.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;发现每次写文章都要加个前言来瞎扯一波，最近在找实习，之前以为大四上就比较无聊了，后来发现大四下更无聊，不过也有时间来学一些自己喜欢的东西，但是经常会学着学着就打开抖音看小姐姐了，这样不行不行… 所以就要求自己争取每周都能写几篇文章来记录都学了什么。上学期的时候买了一本《linux/unix系统编程手册》里面有相应的demo代码，于是想编译一下，没错我在终端里输入了 &lt;code&gt;gcc demo.c&lt;/code&gt; 。结果可想而知报了一大推错。这篇文章是小白记录文，大神就不用看了。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一个简单的telegram-bot</title>
    <link href="https://yangsoon.github.io/2017/12/18/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84telegram-bot/"/>
    <id>https://yangsoon.github.io/2017/12/18/一个简单的telegram-bot/</id>
    <published>2017-12-18T09:43:08.000Z</published>
    <updated>2018-02-21T13:39:48.522Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这篇文章是简单的介绍一下如何创建一个telegram-bot，下面我就以创建一个<a href="http://www.gamersky.com/" target="_blank" rel="noopener">游民星空</a> 囧图查看机器人为例，其中bot是基于<a href="https://github.com/python-telegram-bot/python-telegram-bot" target="_blank" rel="noopener">python-telegram-bot</a>来构建，<a href="https://github.com/yangsoon/funny-bot" target="_blank" rel="noopener">源码地址</a>在这。</p><p><div class="tip"><br>如果对telegram-bot不了解，请先查看 <a href="/2017/11/21/telegram-bots-for-developers/">《写给开发者的telegram-bots介绍文档》</a><br></div><br><a id="more"></a></p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol><li>首先你需要通过BotFather，新建一个bot，获得唯一的authorization token。</li><li>开始撸代码</li></ol><h3 id="初始化你的bot"><a href="#初始化你的bot" class="headerlink" title="初始化你的bot"></a>初始化你的bot</h3><p>这里我们使用了一个用python写好的库，帮助我们创建bot，你可以查看他的文档来进行其他的骚操作。</p><p><code>main.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding : utf-8 -*-</span></div><div class="line"><span class="comment"># -*- coding : utf-8 -*-</span></div><div class="line"><span class="keyword">import</span> telegram</div><div class="line"><span class="keyword">import</span> json</div><div class="line"><span class="keyword">import</span> logging</div><div class="line"><span class="keyword">from</span> commands <span class="keyword">import</span> start, remove, get_list, \</div><div class="line">    change_page, get_photo, FilterTypes, FilterKey</div><div class="line"><span class="keyword">from</span> telegram.ext <span class="keyword">import</span> CommandHandler, CallbackQueryHandler, \</div><div class="line">    Updater, MessageHandler</div><div class="line"></div><div class="line"><span class="keyword">with</span> (open(<span class="string">'token.conf'</span>, <span class="string">'r'</span>)) <span class="keyword">as</span> f:</div><div class="line">    token = json.loads(f.read())[<span class="string">'token'</span>]</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">error_callback</span><span class="params">(bot, update, error)</span>:</span></div><div class="line">    <span class="keyword">raise</span> error</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FunnyPhoto</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        logging.basicConfig(</div><div class="line">            format=<span class="string">'%(asctime)s - %(name)s - %(levelname)s - %(message)s'</span>, level=logging.INFO)</div><div class="line">        self.updater = Updater(token=token)</div><div class="line">        self.dispatcher = self.updater.dispatcher</div><div class="line">        self.begin()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">begin</span><span class="params">(self)</span>:</span></div><div class="line">        filter_types = FilterTypes()</div><div class="line">        filter_key = FilterKey()</div><div class="line">        start_handler = CommandHandler(<span class="string">'start'</span>, start)</div><div class="line">        types_handler = MessageHandler(filter_types, get_list)</div><div class="line">        key_handler = MessageHandler(filter_key, get_photo)</div><div class="line">        self.dispatcher.add_handler(start_handler)</div><div class="line">        self.dispatcher.add_handler(CallbackQueryHandler(change_page))</div><div class="line">        self.dispatcher.add_handler(types_handler)</div><div class="line">        self.dispatcher.add_handler(key_handler)</div><div class="line">        self.dispatcher.add_handler(CommandHandler(<span class="string">'remove'</span>, remove))</div><div class="line">        self.dispatcher.add_error_handler(error_callback)</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    bot = FunnyPhoto()</div><div class="line">    bot.updater.start_polling()</div><div class="line">    bot.updater.idle()</div></pre></td></tr></table></figure><p>首先我们需要之前在botfather里获取的token，然后写在配置文件中。注意千万别写在源码中，配置文件也要记得ignore，之前大疆因为password闹了一个很大的笑话。在这里logging模块是为了格式化输出日志。下面就介绍一下Updater和Dispatcher，Updater类不断从telegram中获取新的更新，并将它们转发给Dispatcher类。如果你创建了一个Updater对象，它将为您创建一个Dispatcher并将它们与一个Queue关联起来。然后你可以在Dispatcher中注册不同类型的处理程序，它将根据您注册的处理程序对Updater获取的更新进行排序，并将它们传递给你定义的回调函数。</p><p>当你在终端输入<code>python3 main.py</code>，回车后，updater就开始监听你的bot获取的消息。</p><h3 id="命令处理"><a href="#命令处理" class="headerlink" title="命令处理"></a>命令处理</h3><p>如  <code>main.py</code> 所示，bot若想对相应的命令或消息进行处理，首先要通过  <code>telegram.ext</code> 引入 <code>CommandHandler</code>、<code>MessageHandler</code>。传入指定的命令或消息处理函数来创建handler对象。并通过 <code>dispatcher.add_handler</code> 进行全局注册。</p><h3 id="开心一刻"><a href="#开心一刻" class="headerlink" title="开心一刻"></a>开心一刻</h3><p>其实之前一直有这样一个想法，感觉平时生活中发生了好多有意思的事情，如果能够把这些事情记录下来，一定是个很宝贵的财富。</p><p>昨天我，阿宾，祥哥去爬了紫金山，松神去参加了徒步50公里的活动。结果今天我们的双腿不出意外的十分酸爽。于是有了下面的对话。</p><p>松神：腿好酸呀！现在腿里都是酒精。</p><p>祥哥：什么酒精，明明是乳糖。</p><p>我和阿宾：…. 是乳酸好不好！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;这篇文章是简单的介绍一下如何创建一个telegram-bot，下面我就以创建一个&lt;a href=&quot;http://www.gamersky.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;游民星空&lt;/a&gt; 囧图查看机器人为例，其中bot是基于&lt;a href=&quot;https://github.com/python-telegram-bot/python-telegram-bot&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;python-telegram-bot&lt;/a&gt;来构建，&lt;a href=&quot;https://github.com/yangsoon/funny-bot&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;源码地址&lt;/a&gt;在这。&lt;/p&gt;
&lt;p&gt;&lt;div class=&quot;tip&quot;&gt;&lt;br&gt;如果对telegram-bot不了解，请先查看 &lt;a href=&quot;/2017/11/21/telegram-bots-for-developers/&quot;&gt;《写给开发者的telegram-bots介绍文档》&lt;/a&gt;&lt;br&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="telegram-bots" scheme="https://yangsoon.github.io/tags/telegram-bots/"/>
    
  </entry>
  
  <entry>
    <title>杂记</title>
    <link href="https://yangsoon.github.io/2017/12/16/%E6%9D%82%E8%AE%B0/"/>
    <id>https://yangsoon.github.io/2017/12/16/杂记/</id>
    <published>2017-12-16T14:12:09.000Z</published>
    <updated>2017-12-18T09:40:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近看了一些其他博主的blog，发现和他们的一些技术文章相比，我似乎更喜欢看他们的一些和平常生活有关的文章。那些生活中琐碎的小事，对我来说都格外的有意思。感觉那是生活中非常美好的部分。之前在其他账号上断断续续写过一些blog，现在换了一个账号，希望这个账号能够让我坚持写下去。说是blog，可能看的人也就只有我和一些意外打开的人了吧。对我来说，写blog就是写给以后的自己，不要忘记曾经的努力和美好吧。<br><a id="more"></a></p><h2 id="劳动节-4-29-5-2"><a href="#劳动节-4-29-5-2" class="headerlink" title="劳动节(4.29-5.2)"></a>劳动节(4.29-5.2)</h2><p>因为到年底了，所以就回顾一下这一年里的发生的比较有意义的事情。在劳动节的时候，和刘鑫一起去了大连玩。比较有意义的是，这次是我第一次坐飞机。坐上飞机之后，像一个孩子一样，不断的探头看地上的风景。因为坐在了靠近过道的位置，离窗户比较远，搞得坐在旁边的情侣很尴尬。哈哈..<br>在大连留下深刻印象的就是星海广场的海鸥，第一次给海鸥喂食，这个小生灵让我感到了生命的美好。下面的图片就是海鸥在夺取食物。<br><img src="http://ww1.sinaimg.cn/large/006r0i4lgy1fmizw73nhsj31w02io7ow.jpg" style="width: 50%; height: 50%"><br>按照行程，我们在大连玩一天就坐船去烟台的蓬莱岛，结果坐的轮船又给了我另一个惊喜。<br><img src="http://ww1.sinaimg.cn/large/006r0i4lgy1fmj03tdi2lj34zs1woqv5.jpg"><br>没错就是这样一个超大的轮船，有点震撼。之后的两天就是在烟台的蓬莱逛逛。没有什么好说的了，但是在烟台的时候在蓬莱的民宿住了一晚，感觉挺不错的，虽然是在别人的家里住，但是环境非常干净，还可以在他们家里吃饭，阿姨做的汤感觉很鲜嫩，没有海鲜的腥味，对于像我这样万年不吃鱼的人来说感觉非常的美味。但是阿姨韭菜馅的馄饨是几个意思..</p><h2 id="6月-7月"><a href="#6月-7月" class="headerlink" title="6月-7月"></a>6月-7月</h2><p>基本上大三已经结束了，这个暑假，对一些人比较重要。那就是要参加外校的夏令营。如果能够获得外校的入营资格，并能获得录取资格，那就表明大四基本上可以轻轻松松的度过了。但是一些学校的入营资格又迟迟不发布，所以我们这些人就整天人心惶惶的等待结果。我们即将开始大四生活，就说明学长就要离开南理工了，所以就想送送之前关系一直很好的C学长(保到清华)，在他走的那天，帮他办了些无关紧要的事情，最后很不好意思的蹭了W学长(保到中科院)一顿饭，吃饭的时候，C学长和他女票(保到北航)传授了一些夏令营面试经验，嘻嘻。<br>一般夏令营开始都在7月份，所以放假到等结果这段时间，我一直宅在宿舍里复习一些专业基础知识，在这段时间里，我们在宿舍里吃了一顿火锅，哈哈，用祥哥的脸盆装的菜，之后被子上都是火锅味，最后强行用花露水掩盖住了味道。<br>到了7月，很幸运的能够获得北航的入营资格，结果也获得了录取资格，刘鑫正好也在北京实习，在出结果那天她请假过来陪我，晚上松神去网吧happy，我和刘鑫在海淀区骑着单车乱逛，后来骑到了清华，去清华里逛了一会，晚上11点多才回到宾馆。洗洗睡睡，第二天，需要选择导师，我就直接选了mail联系过的老师，然后就回家了。</p><blockquote><p>写的脖子比较累，明早还要爬山，有空继续写吧</p></blockquote><p>回家之后，因为过几天还要去中科院网络中心参加夏令营，在家里就当做中转，休息了几天。回家之后，家里竟然开了一家万达。嘻嘻，以后在家里又多了一个能够乱逛的地方，也可以在家里看到IMAX了。<br>在中科院的几天活动中，先听了两天讲座，期间豪哥过来陪我，我们又去鸟巢逛了一圈，记得上一次我们来鸟巢的时候还是高一学竞赛，我们都不由得感叹时间过得飞快。在网络中心的时候，很荣幸的参观了网络中心的机房，还在那里看到了国家域名总节点。<br><img src="http://ww1.sinaimg.cn/large/006r0i4lgy1fmjsk5v1a0j31w02io4d7.jpg" style="width: 50%; height: 50%"><br>在结束面试，笔试之后，中心为我们举办了晚会。晚餐是麦当劳，还有很多零食，水果。中心确实不错。晚会举办的很愉快，我和祥哥都参加了一些中场活动，祥哥还参加了你画我猜的游戏。就这样7月就过去了。</p><h2 id="8月"><a href="#8月" class="headerlink" title="8月"></a>8月</h2><p>8月都在学车，准备寒假再考科二，认识一群很社会的人(哈哈!)。其实都是一些刚上大学的人，感觉j就像回到了高中，和健哥瞎扯的那个时光。</p><h2 id="9月"><a href="#9月" class="headerlink" title="9月"></a>9月</h2><p>9月，妈妈因为之前的病，去济南复查，因为检查结果需要一周的时间才能出来。那一周过得挺煎熬的，黑色的九月。可能当面临一些事情的时候，感觉一些外在的东西都是无所谓的了。<br>刘鑫准备考研了，可能是我给的压力太大了，感觉很对不起她。</p><h2 id="12月"><a href="#12月" class="headerlink" title="12月"></a>12月</h2><p>到了现在写blog的时间点了，考研的马上就要迎来了解放的时候了。祝愿他们心想事成。上面说过爬山的事情，今天天气很好，没想到爬紫金山这么快。爬过泰山之后，爬这样的山感觉就轻松很多。现在到了年底了，越来越意识到自己学到的东西那么少，那么浅。现在一直在补基础的知识，最近在看<a href="https://book.douban.com/subject/3652388/" target="_blank" rel="noopener">《程序员的修养》</a>可能听起来名字很怪，但是感觉这是今年看到的第二本好书了，里面的内容真的需要每个程序员都要掌握。在知乎上看到了一个问题 2017年你又点满了哪些技能树？唉，问问自己感觉真的没学到什么知识。以后要对一年的学习做个基本的规划，计算机一定要与时俱进呀。</p><p>今年4月份的时候吧，在学校拍了这样一张照片。一位老爷爷在吹萨克斯，一位老奶奶在一旁看着，虽然不知道他们是什么关系，但是这样的画面感觉很美好。记得刘鑫曾经说我唱歌好听，希望以后能够每天都唱给她听，再见，即将逝去的17年。<br><img src="http://ww1.sinaimg.cn/large/006r0i4lgy1fmjt7cg6ncj31w02iox6p.jpg" style="width: 50%; height: 50%"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近看了一些其他博主的blog，发现和他们的一些技术文章相比，我似乎更喜欢看他们的一些和平常生活有关的文章。那些生活中琐碎的小事，对我来说都格外的有意思。感觉那是生活中非常美好的部分。之前在其他账号上断断续续写过一些blog，现在换了一个账号，希望这个账号能够让我坚持写下去。说是blog，可能看的人也就只有我和一些意外打开的人了吧。对我来说，写blog就是写给以后的自己，不要忘记曾经的努力和美好吧。&lt;br&gt;
    
    </summary>
    
    
      <category term="杂记" scheme="https://yangsoon.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>telegram-bots for developers</title>
    <link href="https://yangsoon.github.io/2017/11/21/telegram-bots-for-developers/"/>
    <id>https://yangsoon.github.io/2017/11/21/telegram-bots-for-developers/</id>
    <published>2017-11-21T14:03:14.000Z</published>
    <updated>2017-12-18T09:54:10.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="写给开发者的telegram-bots介绍文档"><a href="#写给开发者的telegram-bots介绍文档" class="headerlink" title="写给开发者的telegram-bots介绍文档"></a>写给开发者的telegram-bots介绍文档</h4><p>bots是运行在telegram内部的第三方应用。用户可以通过发送消息，命令或者<a href="#inline-mode">内联请求</a>和bots进行交互。开发者可以通过向<a href="https://core.telegram.org/bots/api" target="_blank" rel="noopener">bot API</a>发送HTTPS请求来控制自己的bot。</p><a id="more"></a><blockquote><p>因为最近对telegram bot产生了兴趣，想创建一个bot试一试，因为网上没有找到相关的中文文档，所以就自己跟着自己的理解和Google Translate翻译了介绍文档，文中一定有表述不对的地方，我会在之后编写bot的时候进行修改，建议大家阅读的时候参照<a href="https://core.telegram.org/bots" target="_blank" rel="noopener">原文档</a>一起阅读。</p></blockquote><div class="tip"><br>大家可以继续看看 <a href="/2017/12/18/一个简单的telegram-bot/">《一个简单的telegram-bot》</a> 来学习怎么创建一个简单的telegram-bot。<br></div><h2 id="我能用bots做什么？"><a href="#我能用bots做什么？" class="headerlink" title="我能用bots做什么？"></a>我能用bots做什么？</h2><p>下面举几个例子，你可以用bot来：</p><ul><li>获得自定义的新闻和通知。一个机器人可以扮演一个智能新闻的角色，发送你需要的新闻。 如：<a href="https://t.me/TechCrunchBot" target="_blank" rel="noopener">TechCrunch Bot</a></li><li>和其他服务集成。一个机器人可以通过绑定其他的服务来丰富聊天 如:<a href="https://t.me/gmailbot" target="_blank" rel="noopener">Gmail Bot</a></li><li>接受来自telegram用户的付款</li><li>创建自定义工具 一个机器人可以为你提供预警，天气预报，格式化文本，翻译，或者其他服务.如: <a href="https://t.me/Bold" target="_blank" rel="noopener">Markdown</a></li><li>创建单人多人游戏 一个机器人可以提供丰富的HTML5体验，从简单的街机和解谜游戏到3D射击和实时策略游戏。如:  <a href="https://t.me/gamebot" target="_blank" rel="noopener">GameBot</a></li><li>建立社交服务 一个机器人能够将一些寻找共同兴趣爱好的人联系在一起。如:<a href="https://t.me/hotorbot" target="_blank" rel="noopener">HotOrBot</a></li><li>或者做一些其他的事情 除了做菜–机器人做的菜非常糟糕(官方吐槽)</li></ul><h2 id="bots是如何工作的"><a href="#bots是如何工作的" class="headerlink" title="bots是如何工作的?"></a>bots是如何工作的?</h2><p>Telegram Bots是一个特别的账号并不需要另外的手机号码去创建，用户可以通过下面两种方式和机器人交互。</p><ol><li>创建和bots的聊天并发送消息和命令或者将机器人加入聊天群。这一特性对聊天机器人和官方新闻机器人很有用。</li><li>直接在输入框中键入<code>@username query</code>来发送请求。这样可以通过<a href="https://core.telegram.org/bots/inline" target="_blank" rel="noopener">inline bots</a>直接发送内容到任何聊天，群或者频道。</li></ol><p>用户发送的消息，命令，和请求被转发给运行在你服务上的应用。我们的中介服务器帮你处理消息的加密和telegram api的通讯。你可以通过简单的HTTPS接口(Telegram API的简化版本)和服务通讯,我们把这个接口称为Bot API。</p><blockquote><p>有关Bot API的详细说明，请参阅 <a href="https://core.telegram.org/bots/api" target="_blank" rel="noopener">bots api</a></p></blockquote><h2 id="我怎么创建一个bot"><a href="#我怎么创建一个bot" class="headerlink" title="我怎么创建一个bot?"></a>我怎么创建一个bot?</h2><p>我们提供一个bot来帮助你创建bot，你可以直接和<a href="https://telegram.me/botfather" target="_blank" rel="noopener">BotFather</a>交谈，并按照几个简单的步骤就可以创建一个属于自己的bot。一旦你创建了一个bot并获取到你的authorization token，那就直接去查看<a href="https://core.telegram.org/bots/api" target="_blank" rel="noopener">Bot API</a>手册看看你能操作机器人做什么事情。</p><blockquote><p>你也可以查看一些 <strong> <a href="https://core.telegram.org/bots/samples" target="_blank" rel="noopener">示例代码</a> </strong></p></blockquote><h2 id="bot和普通账号有什么不同"><a href="#bot和普通账号有什么不同" class="headerlink" title="bot和普通账号有什么不同?"></a>bot和普通账号有什么不同?</h2><ul><li>Bots没有在线状态和last seen时间戳，界面只显示bot标签</li><li>Bots有云存储限制，所以较旧的消息可能在服务器处理后不久被删除</li><li>Bots无法主动与用户交流。用户必须将bot添加到群组中或者先给bot发送消息。其他人可以使用<code>telegram.me/&lt;bot_username&gt;</code>链接或者username来找到你的bot。</li><li>Bot的username总是以’bot’结尾。</li><li>当bot被加入群中，它默认不会接受所有消息。</li><li>机器人不需要吃饭，睡觉或者抱怨(除非程序中有设定) <strong> 又是官方吐槽 </strong></li></ul><h2 id="与众不同的Bot"><a href="#与众不同的Bot" class="headerlink" title="与众不同的Bot"></a>与众不同的Bot</h2><p>Telegram bots在很多方面都与众不同 – 我们提供两种样式的键盘以及提供对默认指令、深层链接以及文本格式等的额外接口。</p><h4 id="内联模式"><a href="#内联模式" class="headerlink" title="内联模式"></a>内联模式</h4><p>用户可以在任意聊天的输入框中通过输入内联请求和你的bot进行交互。只需在输入框中以你的bot命开头并输入请求即可。<br>收到查询后，您的机器人可以返回一些结果。一旦用户点击其中一个，它就发送到用户当前打开的聊天。通过这种方式，人们可以通过任何聊天，小组或频道和您的bot进行互动。你可以使用<a href="https://telegram.me/sticker" target="_blank" rel="noopener">@sticker</a>来体验一下。</p><blockquote><p>关于<a href="https://core.telegram.org/bots/inline" target="_blank" rel="noopener">内联模式</a>的更多信息</p></blockquote><h4 id="付款平台"><a href="#付款平台" class="headerlink" title="付款平台"></a><a href="https://core.telegram.org/bots#payments-platform" target="_blank" rel="noopener">付款平台</a></h4><h4 id="游戏平台"><a href="#游戏平台" class="headerlink" title="游戏平台"></a><a href="https://core.telegram.org/bots#gaming-platform" target="_blank" rel="noopener">游戏平台</a></h4><h4 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h4><p>传统的机器人当然可以被教会理解人类的语言。但是有时候你想从用户那里获得更加规范化的输入，为此我们提供了自定义键盘。</p><p>每当你的机器人发送一条消息，它会传递一个特定的键盘与预定义的答复选项(请参阅<a href="https://core.telegram.org/bots/api/#replykeyboardmarkup" target="_blank" rel="noopener">ReplyKeyboardMarkup</a>)，telegram会接收到消息并将你设定的键盘展示给用户。点击任何按钮将立即发送相应的命令。这样你可以大大简化用户与你的机器人交互。</p><blockquote><p>有关自定义键盘的更多信息，请查阅<a href="https://core.telegram.org/bots/api" target="_blank" rel="noopener">Bot API</a>的<a href="https://core.telegram.org/bots/api#sendmessage" target="_blank" rel="noopener">sendMessage</a>部分。</p></blockquote><h4 id="内联键盘和即时更新"><a href="#内联键盘和即时更新" class="headerlink" title="内联键盘和即时更新"></a>内联键盘和即时更新</h4><p>有时候用户更喜欢可以不发送消息也能做一些事情。比如，当你的用户正在改变设置或翻阅搜索结果，在这种情况，你可以直接将内联键盘附加到所属的消息中。与自定义回复键盘不同，点击内联键盘上的按钮不会发送消息到当前聊天中。内联键盘支持按钮在后台工作，比如：callback buttons, URL buttons 和switch to inline buttons。</p><p>当使用回调按钮时，你的bot可以更新已经存在的消息(或者只是这些消息附加的键盘)所以这样能够保持聊天界面的整洁。你可以查看这些机器人的内联键盘的功能:<a href="https://telegram.me/music" target="_blank" rel="noopener">@music</a>、<a href="https://telegram.me/vote" target="_blank" rel="noopener">@vote</a>。</p><blockquote><p><a href="https://core.telegram.org/bots/2-0-intro#new-inline-keyboards" target="_blank" rel="noopener">了解更多关于内联键盘和即时编辑的信息 &gt;&gt;</a></p></blockquote><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><p>命令提供了一个更灵活的方式与您的机器人进行通信。可以使用下面的语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/command [optional] [argument]</div></pre></td></tr></table></figure></p><p>每个命令必须以‘/’开头且不能超过32个字符，命令可以使用拉丁字母，数字和下划线。下面是几个示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/get_messages_stats</div><div class="line">/set_timer 10min Alarm!</div><div class="line">/get_timezone London, UK</div></pre></td></tr></table></figure></p><p>以斜线开头的消息总是被发送给机器人。telegram 将会这样处理:</p><ul><li>当用户输入‘/’时，将会出现带有相应描述的命令提示(开发者提供给botFather相应的命令列表)。点击列表中的命令会立即发送命令。</li><li>在和机器人的所有聊天的输入字段中显示一个额外的（/）按钮。点击它键入一个“/”并显示命令列表。</li><li>在消息中将命令高亮显示，当用户点击突出显示的命令时，立即发送该命令。</li></ul><p>如果多个机器人在一个组中，可以将bot用户名添加到命令中以避免混淆:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/start@TriviaBot</div><div class="line">/start@ApocalypseBot</div></pre></td></tr></table></figure></p><p>这是通过建议列表选择命令时自动完成的，请记住你的bot需要能够处理跟在username后的指令。</p><h4 id="全局命令"><a href="#全局命令" class="headerlink" title="全局命令"></a>全局命令</h4><p>为了使所有的用户能够轻松应对各种bots的使用，我们要求开发者必须实现几个基础命令。telegram将会在界面中为这几个基础指令提供相应的快捷键。</p><ul><li><strong> / start </strong>  - bots开始和用户交互，例如发送一个欢迎的消息。这个指令同样可以传递几个额外的参数给bot。</li><li><strong> / help </strong> - 返回一个帮助消息。</li><li><strong> / setting </strong> - 将会返回给用户一些机器人的功能设定，显示可以编辑设置的指令。</li></ul><p>用户在第一次打开与您的机器人的对话时将看到一个start按钮。在机器人的配置菜单中有help和setting的链接。</p><h4 id="隐私模式"><a href="#隐私模式" class="headerlink" title="隐私模式"></a>隐私模式</h4><p>bots经常被加入到组中来加强人与人之间的沟通。例如通过提供新闻，来自外部服务的通知或其他搜索功能。特别是那些工作聊天组。现在当你与bot共享一个组时，你会问问自己，我怎么能够保证这个小流氓(bot)不会将我的历史记录泄露给竞争对手呢？答案就是-隐私模式。运行在隐私模式下的bot不会收到所有发送给该组的消息。相反，它只会收到：</p><ul><li>命令</li><li>回复机器人自己的消息</li><li>服务消息(人员的添加和删减)</li><li>来自频道的消息</li></ul><p>一方面，这有助于我们一些人在晚上更好地睡觉; 另一方面，它允许机器人开发人员节省大量的资源，因为他们每天不需要处理数以万计的不相关的消息。</p><p>所有的bots默认启用隐私模式，除了被加入组中当做管理员的bot(bot admin)总是收到所有的消息)它可以被禁用，以便机器人像普通用户一样接收所有消息。如果不必要，我们建议你不要这样做。用户可以随时在组成员列表中查看机器人的当前隐私设置。在大多数情况下，使用机器人消息的<a href="https://core.telegram.org/bots/api#forcereply" target="_blank" rel="noopener">强制回复</a>选项应该是绰绰有余的。</p><p><a href="https://core.telegram.org/bots/faq#what-messages-will-my-bot-get" target="_blank" rel="noopener">那么我的bot究竟会收到什么样的信息呢？&gt;&gt;</a></p><h4 id="深层链接"><a href="#深层链接" class="headerlink" title="深层链接"></a><a href="https://en.wikipedia.org/wiki/Deep_linking" target="_blank" rel="noopener">深层链接</a></h4><p>百度百科中对deeplink有下面这样的描述</p><blockquote><p>移动端深度链接 是指在移动端网页或应用内输入搜索结果，可以链接到手机内安装的其他应用。</p></blockquote><p>telegram bots有深层链接机制，允许在启动时将其他参数传递给机器人，这可能是一个启动机器人的命令，或者是一个身份验证令牌将用户的telegram帐户连接到某个外部服务上的帐户。</p><p>每个bot都有一个在telegram打开一个对话的链接。<code>https://telegram.me/&lt;bot username&gt;</code>您可以将参数start或startgroup添加到此链接，参数值最多为64个字符。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://telegram.me/triviabot?startgroup=test</div></pre></td></tr></table></figure><p><code>A-Z</code>,<code>a-z</code>,<code>0-9</code>,<code>_</code>和<code>-</code>都可以使用。我们建议使用base64url编码参数与二进制和其他类型的内容。</p><p>点击带有启动参数的链接将打开与bot的一对一对话，在输入栏位显示一个START按钮。如果使用startgroup参数，则会提示用户选择要添加机器人的组。一旦用户进行了确认(点击START按钮或者选择了一个组加入bot)，你的机器人将以这种格式接收一个来自该用户的消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/start PAYLOAD</div></pre></td></tr></table></figure><p><code>PAYLOAD</code>表示链接中传递的start或startgroup参数的值。</p><h4 id="深层链接示例"><a href="#深层链接示例" class="headerlink" title="深层链接示例"></a>深层链接示例</h4><p>假设网站example.com希望通过bot向用户发送通知。以下是他们为ID<code>123</code>用户开启通知进行的操作。</p><ol><li>创建一个有合适名字的bot，例如 @ExampleComBot</li><li>为传入的消息设置<a href="https://core.telegram.org/bots/api#setwebhook" target="_blank" rel="noopener">webhook</a></li><li>生成足够长度的随机字符串。比如<code>$memcache_key = &quot;vCH1vGWJxfSeofSAs0K5PA&quot;</code></li><li>将值123和<code>$memcache_key</code>放在内存里缓存一小时。</li><li>向用户显示按钮<code>https://telegram.me/ExampleComBot?start=vCH1vGWJxfSeofSAs0K5PA</code>(START按钮会附带参数)</li><li>webhook使用来自start传来的参数(key)去查询内存，如果key存在，将传递给webhook的chat_id记录为用户123的telegram_chat_id。从内存中移除key。</li><li>现在，当我们想发送通知给用户123时，检查他们是否具有telegram_chat_id字段。如果有，那么就使用Bot API中的sendMessage发送消息。</li></ol><h4 id="位置和电话号码"><a href="#位置和电话号码" class="headerlink" title="位置和电话号码"></a>位置和电话号码</h4><p>一些bot需要获得用户额外的数据才能工作的更好。例如，知道用户的位置有助于提供更相关的地理位置特定的结果。用户的电话号码对于与银行等其他服务的集成非常有用。</p><p>bot可以使用特殊按钮询问用户的位置和电话号码。请注意，电话号码和位置请求按钮只能用于私人聊天。</p><p>当按钮被按下后，telegram将显示一个确认提醒，告诉用户即将发生的事情。</p><h2 id="BotFather"><a href="#BotFather" class="headerlink" title="BotFather"></a>BotFather</h2><p>BotFather是管理所有bot的机器人。它将帮助您创建新的机器人和更改现有机器人的设置。</p><h4 id="创建一个新的bot"><a href="#创建一个新的bot" class="headerlink" title="创建一个新的bot"></a>创建一个新的bot</h4><p>使用 <strong> / newbot </strong> 命令来创建一个新的机器人。 BotFather会要求你提供一个名字和用户名，然后为你的新机器人生成一个授权令牌。</p><p>您的机器人的名称显示在联系方式和其他地方。</p><p><strong> Uername </strong> 是一个简称。用户名长度为532个字符，不区分大小写，但只能包含拉丁字符，数字和下划线。你的机器人的用户名必须以“bot”结尾。</p><p><strong> token </strong> 是一串了类似  <code>110201543:AAHdqTcvCH1vGWJxfSeofSAs0K5PALDsaw</code> 的字符串。<br>用于授权bot并向Bot API发送请求。</p><h4 id="生成授权令牌"><a href="#生成授权令牌" class="headerlink" title="生成授权令牌"></a>生成授权令牌</h4><p>如果您的现有令牌受到威胁，或者由于某种原因而丢失了该令牌，请使用/ token命令生成一个新的令牌。</p><h4 id="BotFather-Commands"><a href="#BotFather-Commands" class="headerlink" title="BotFather Commands"></a>BotFather Commands</h4><blockquote><p>命令很简单，此处略过，请读者自己尝试。</p></blockquote><h4 id="状态警报"><a href="#状态警报" class="headerlink" title="状态警报"></a>状态警报</h4><p>百万个用户因为telegram的快速响应选择我们，为了能够保证开发者的bot能时刻处在正常状态。所以当你的bot出现问题时，botfather会给你发送一个状态警报。</p><p>我们将会检查热门bot的回复数目以及 请求/响应 转换率。如果我们得到异常低的读数，您将收到Botfather的通知。</p><h4 id="响应警报"><a href="#响应警报" class="headerlink" title="响应警报"></a>响应警报</h4><p>默认情况下，每个机器人每小时只能获得一个警报。每个警报都有以下按钮：</p><ul><li><strong> Fixed </strong> 如果你发现你的机器人有问题并修复它，请使用它。如果按下修复按钮，我们将继续以常规方式继续发送警报，以便您能够在5-10分钟内查看您的修复是否工作，而不必等待一个小时。</li><li><strong> Support </strong> 如果您没有看到您的机器人有任何问题，或者如果您认为问题在我们这边，可以使用它来打开与@BotSupport的聊天。</li><li><strong> Mute for 8h/1w </strong> 如果您目前无法修复您的机器人，请使用此功能。这将在指定的时间段内禁用问题机器人的所有警报。我们不建议使用此选项，因为您的用户可能会迁移到更稳定的机器人。您可以通过Botfather取消您的机器人设置中的警报静音。</li></ul><h4 id="Monitored-issues-监控"><a href="#Monitored-issues-监控" class="headerlink" title="Monitored issues(监控)"></a>Monitored issues(监控)</h4><ol><li><p><code>Too few **private messages** are sent compared to previous weeks: **{value}**</code><br>你的机器人发送的信息要少于前几周,这对通讯类型的机器人很有用。</p></li><li><p><code>Too few replies to incoming **private messages**. Conversion rate: **{value}**</code><br>您的机器人不会回复发送给它的所有消息(您的机器人的请求/响应转换率在过去的三个5分钟内至少有两次是太低)。为了提供良好的用户体验，请回复发送给您的机器人的所有消息。</p></li><li><p><code>Too few answers to **inline queries**. Conversion rate: **{value}**</code><br>您的机器人不会回复正在发送给它的所有内嵌查询，其计算方式与上述相同。</p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Too few answers to callback queries. Conversion rate: &#123;value&#125;</div><div class="line"></div><div class="line">Too few answers to callback game queries. Conversion rate: &#123;value&#125;</div></pre></td></tr></table></figure><p>你的机器人没有回复正在发送给它的所有回调查询,其计算方式与上述相同。</p></li></ol><blockquote><p>请注意，状态提醒功能仍在测试中，将来会有所改进。</p></blockquote><p>以上就是介绍。阅读完此部分说明您现在已经准备好进入<a href="https://core.telegram.org/bots/api" target="_blank" rel="noopener">BOT API</a>手册。</p><p>如果您有任何问题，请查看我们的<a href="https://core.telegram.org/bots/faq" target="_blank" rel="noopener">Bot FAQ »</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;写给开发者的telegram-bots介绍文档&quot;&gt;&lt;a href=&quot;#写给开发者的telegram-bots介绍文档&quot; class=&quot;headerlink&quot; title=&quot;写给开发者的telegram-bots介绍文档&quot;&gt;&lt;/a&gt;写给开发者的telegram-bots介绍文档&lt;/h4&gt;&lt;p&gt;bots是运行在telegram内部的第三方应用。用户可以通过发送消息，命令或者&lt;a href=&quot;#inline-mode&quot;&gt;内联请求&lt;/a&gt;和bots进行交互。开发者可以通过向&lt;a href=&quot;https://core.telegram.org/bots/api&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;bot API&lt;/a&gt;发送HTTPS请求来控制自己的bot。&lt;/p&gt;
    
    </summary>
    
    
      <category term="telegram-bots" scheme="https://yangsoon.github.io/tags/telegram-bots/"/>
    
      <category term="introduction" scheme="https://yangsoon.github.io/tags/introduction/"/>
    
  </entry>
  
  <entry>
    <title>MPI读书笔记(一)</title>
    <link href="https://yangsoon.github.io/2017/11/10/MPI%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://yangsoon.github.io/2017/11/10/MPI读书笔记/</id>
    <published>2017-11-10T06:55:15.000Z</published>
    <updated>2017-11-11T06:24:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>确认研究方向是并行计算之后，却一直没有认真接触。从开学到现在这段时间都在看一些无关紧要的东西，像<a href="https://cn.vuejs.org/" target="_blank" rel="noopener">vuejs</a>把官方文档过了一遍；<a href="https://book.douban.com/subject/27028517/" target="_blank" rel="noopener">《流畅的python》</a>也看了一多半，感觉确实写的很nice；接触了python web异步框架<a href="https://tornado-zh.readthedocs.io/zh/latest/#" target="_blank" rel="noopener">tornado</a>。最近用vue全家桶(<a href="https://cn.vuejs.org/" target="_blank" rel="noopener">vuejs</a>、<a href="https://router.vuejs.org/zh-cn/" target="_blank" rel="noopener">vue-router</a>、<a href="https://vuex.vuejs.org/zh-cn/" target="_blank" rel="noopener">vuex</a>)和<a href="https://tornado-zh.readthedocs.io/zh/latest/#" target="_blank" rel="noopener">tornado</a>写了一些东西，关于这部分准备以后写篇文章来记录下。近期要开始毕设选题了，北航的学长帮我想了一个和并行计算相关的课题。也推荐了<a href="https://book.douban.com/subject/1244566/" target="_blank" rel="noopener">《高性能计算-并行编程技术》</a>当做入门书籍。这篇文章就当一个学习笔记，记录mpi一些相关的知识点。后期准备将每个章节出现的代码都用c重新实现一遍。<a href="https://github.com/yangsoon/MPI-Demo" target="_blank" rel="noopener">相关代码地址</a><br><a id="more"></a></p><h1 id="并行计算基础"><a href="#并行计算基础" class="headerlink" title="并行计算基础"></a>并行计算基础</h1><h2 id="第1章-并行计算机"><a href="#第1章-并行计算机" class="headerlink" title="第1章-并行计算机"></a>第1章-并行计算机</h2><p>并行计算机即在同一时间执行多条指令(或处理多个数据)的计算机，并行计算机是并行计算的物理载体。</p><ul><li>根据并行计算机能同时执行指令和数据的多少分为 SIMD(单指令多数据)和MIMD(多指令多数据)</li><li>根据执行程序和数据的不同分为SPMD(单程序多数据)和MPMD(多程序多数据)</li><li>从存储方式上可以分为共享内存、分布式内存、分布式共享内存并行计算机</li></ul><h2 id="第2章-并行编程模行与并行语言-amp-amp-第3章-并行算法"><a href="#第2章-并行编程模行与并行语言-amp-amp-第3章-并行算法" class="headerlink" title="第2章-并行编程模行与并行语言&amp;&amp;第3章-并行算法"></a>第2章-并行编程模行与并行语言&amp;&amp;第3章-并行算法</h2><h1 id="基本MPI程序设计"><a href="#基本MPI程序设计" class="headerlink" title="基本MPI程序设计"></a>基本MPI程序设计</h1><h2 id="第4章-MPI简介"><a href="#第4章-MPI简介" class="headerlink" title="第4章-MPI简介"></a>第4章-MPI简介</h2><p>1.MPI是一个库，而不是一门语言。<br>2.MPI是一种规范或标准的代表，不特指某一个对它的具体实现。<br>3.MPI是一种消息传递编程模型。</p><h2 id="第5章-第一个MPI程序"><a href="#第5章-第一个MPI程序" class="headerlink" title="第5章-第一个MPI程序"></a>第5章-第一个MPI程序</h2><p>下面演示第一个mpi程序的编写和运行结果。后面解释mpi的api。</p><blockquote><p><code>hello.c</code></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mpi.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</div><div class="line"><span class="keyword">int</span> myid, numprocs;</div><div class="line"><span class="keyword">int</span> namelen;</div><div class="line"><span class="keyword">char</span> processor_name[MPI_MAX_PROCESSOR_NAME];</div><div class="line"></div><div class="line">MPI_Init(&amp;argc, &amp;argv);</div><div class="line">MPI_Comm_rank(MPI_COMM_WORLD, &amp;myid);</div><div class="line">MPI_Comm_size(MPI_COMM_WORLD, &amp;numprocs);</div><div class="line">MPI_Get_processor_name(processor_name, &amp;namelen);</div><div class="line"></div><div class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Hello World! Process %d of %d on %s\n"</span>, myid, numprocs, processor_name);</div><div class="line"></div><div class="line">MPI_Finalize();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>执行</p><blockquote><p><code>mpicc -o hello hello.c</code><br><code>mpirun -n 2 hello</code>(跑在本地2核处理器见谅见谅)</p></blockquote><p>结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Hello World! Process 1 of 2 on promote.cache-dns.local</div><div class="line">Hello World! Process 0 of 2 on promote.cache-dns.local</div></pre></td></tr></table></figure><h2 id="第6章-六个接口构成的MPI子集"><a href="#第6章-六个接口构成的MPI子集" class="headerlink" title="第6章-六个接口构成的MPI子集"></a>第6章-六个接口构成的MPI子集</h2><h4 id="子集介绍"><a href="#子集介绍" class="headerlink" title="子集介绍"></a>子集介绍</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">初始化mpi</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Init</span><span class="params">(<span class="keyword">int</span> *argc, <span class="keyword">char</span>***argv)</span></span></div><div class="line">MPI结束 </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Finalize</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">当前进程标识 </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Comm_rank</span><span class="params">(MPI_Comm comm, <span class="keyword">int</span> *rank)</span></span></div><div class="line">通信域包含的进程数  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Comm_size</span><span class="params">(MPI_Comm comm, <span class="keyword">int</span> *size)</span></span></div><div class="line">消息发送 </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Send</span><span class="params">(<span class="keyword">void</span>* buff, <span class="keyword">int</span> count, MPI_Datatype datatype, <span class="keyword">int</span> dest, <span class="keyword">int</span> tag, MPI_Comm comm)</span></span></div><div class="line">消息接收 </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Recv</span><span class="params">(<span class="keyword">void</span>* buff, <span class="keyword">int</span> count, MPI_Datatype datatype, <span class="keyword">int</span> source, <span class="keyword">int</span> tag, MPI_Comm comm, MPI_Status *status)</span></span></div></pre></td></tr></table></figure><h4 id="参数介绍"><a href="#参数介绍" class="headerlink" title="参数介绍"></a>参数介绍</h4><blockquote><p><code>MPI_Comm_rank</code></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">MPI_Comm comm 该进程所在的通信域(句柄)</div><div class="line"><span class="keyword">int</span> *rank     调用进程在comm中的标识号</div></pre></td></tr></table></figure><blockquote><p><code>int MPI_Comm_size</code></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *size     通信域comm内包含的进程数</div></pre></td></tr></table></figure><blockquote><p><code>MPI_Send</code></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span>* buf                  发送缓冲区的起始地址(可选类型)</div><div class="line"><span class="keyword">int</span> count                  将发送的数据个数(非负整数)</div><div class="line">MPI_Datatype datatype      发送数据的数据类型(句柄)</div><div class="line"><span class="keyword">int</span> dest                   目的进程的标识号(整型)</div><div class="line"><span class="keyword">int</span> tag                    消息标志(整型)</div></pre></td></tr></table></figure><blockquote><p><code>MPI_Recv</code></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span>* buf                  接收缓冲区的起始地址(可选类型)</div><div class="line"><span class="keyword">int</span> count                  最多可接受的数据个数(非负整数)</div><div class="line">MPI_Datatype datatype      接收数据的数据类型(句柄)</div><div class="line"><span class="keyword">int</span> dest                   接收数据来源进程的标识号(整型)</div><div class="line"><span class="keyword">int</span> tag                    消息标志(整型)</div><div class="line"><span class="keyword">int</span> *status                返回状态(状态类型)</div><div class="line">MPI_Status status &#123; MPI_SOURCE, MPI_TAG, MPI_ERROR &#125;</div></pre></td></tr></table></figure><h4 id="一个简单的接收和发送的例子"><a href="#一个简单的接收和发送的例子" class="headerlink" title="一个简单的接收和发送的例子"></a>一个简单的接收和发送的例子</h4><blockquote><p><code>example1.c</code></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 参照原书6.1.9部分代码，略有改动。</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mpi.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</div><div class="line">    <span class="keyword">char</span> message[<span class="number">20</span>];</div><div class="line">    <span class="keyword">int</span> myrank;</div><div class="line">    <span class="keyword">int</span> number;</div><div class="line">    MPI_Status status;</div><div class="line"></div><div class="line">    <span class="comment">// MPI程序初始化</span></div><div class="line">    MPI_Init(&amp;argc, &amp;argv);</div><div class="line">    <span class="comment">// 得到当前进程的标识</span></div><div class="line">    MPI_Comm_rank(MPI_COMM_WORLD, &amp;myrank);</div><div class="line">    <span class="comment">// 得到通信域下的进程数</span></div><div class="line">    MPI_Comm_size(MPI_COMM_WORLD, &amp;number);</div><div class="line">    <span class="comment">// 进程0发送消息给进程1</span></div><div class="line">    <span class="keyword">if</span> (myrank == <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"mpi size:%d\n"</span>, number);</div><div class="line">        <span class="built_in">strcpy</span>(message, <span class="string">"Hello,process 1"</span>);</div><div class="line">        MPI_Send(message, <span class="built_in">strlen</span>(message), MPI_CHAR, <span class="number">1</span>, <span class="number">99</span>, MPI_COMM_WORLD);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"process%d send: %s -&gt; process 1\n"</span>, myrank, message);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 进程1接收来自进程0的消息</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(myrank == <span class="number">1</span>) &#123;</div><div class="line">        MPI_Recv(message, <span class="number">20</span>, MPI_CHAR, <span class="number">0</span>, <span class="number">99</span>, MPI_COMM_WORLD, &amp;status);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"process%d recived: %s &lt;- process 0\n"</span> ,myrank ,message);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"status-&gt;MPI_SOURCE:%d\n"</span>, status.MPI_SOURCE);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"status-&gt;MPI_TAG:%d\n"</span>, status.MPI_TAG);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"status-&gt;MPI_ERROR:%d\n"</span>, status.MPI_ERROR);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 结束</span></div><div class="line">    MPI_Finalize();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>结果<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mpi size:2</div><div class="line">process0 send: Hello,process 1 -&gt; process 1</div><div class="line">process1 recived: Hello,process 1 &lt;- process 0</div><div class="line">status-&gt;MPI_SOURCE:0</div><div class="line">status-&gt;MPI_TAG:99</div><div class="line">status-&gt;MPI_ERROR:0</div></pre></td></tr></table></figure></p><h4 id="mpi预定义数据类型"><a href="#mpi预定义数据类型" class="headerlink" title="mpi预定义数据类型"></a>mpi预定义数据类型</h4><table><thead><tr><th style="text-align:center">MPI预定义数据类型</th><th style="text-align:center">相应的c数据类型</th></tr></thead><tbody><tr><td style="text-align:center">MPI_CHAR</td><td style="text-align:center">signed char</td></tr><tr><td style="text-align:center">MPI_SHORT</td><td style="text-align:center">signed short int</td></tr><tr><td style="text-align:center">MPI_INT</td><td style="text-align:center">signed int</td></tr><tr><td style="text-align:center">MPI_LONG</td><td style="text-align:center">signed long int</td></tr><tr><td style="text-align:center">MPI_UNSIGNED_CHAR</td><td style="text-align:center">unsigned char</td></tr><tr><td style="text-align:center">MPI_UNSIGNED_SHORT</td><td style="text-align:center">unsigned short int</td></tr><tr><td style="text-align:center">MPI_UNSIGNED</td><td style="text-align:center">unsigned int</td></tr><tr><td style="text-align:center">MPI_UNSIGNED_LONG</td><td style="text-align:center">unsigned long int</td></tr><tr><td style="text-align:center">MPI_FLOAT</td><td style="text-align:center">float</td></tr><tr><td style="text-align:center">MPI_DOUBLE</td><td style="text-align:center">double</td></tr><tr><td style="text-align:center">MPI_LONG_DOUBLE</td><td style="text-align:center">long double</td></tr><tr><td style="text-align:center">MPI_BYTE</td><td style="text-align:center">#</td></tr><tr><td style="text-align:center">MPI_PACKED</td><td style="text-align:center">#</td></tr></tbody></table><h4 id="mpi消息组成"><a href="#mpi消息组成" class="headerlink" title="mpi消息组成"></a>mpi消息组成</h4><p><img src="http://ww1.sinaimg.cn/large/006r0i4lgy1fle2ogr9tej30t40feabl.jpg" style="width:400px;"></p><h2 id="第7章-简单的MPI程序示例"><a href="#第7章-简单的MPI程序示例" class="headerlink" title="第7章-简单的MPI程序示例"></a>第7章-简单的MPI程序示例</h2><div class="tip"><br>书中此部分有7个demo，但由于实验环境问题，有些代码不能很好的调试，后面我会不断完善这部分的代码，<a href="https://github.com/yangsoon/MPI-Demo" target="_blank" rel="noopener">代码地址</a>托管在github上。请大家见谅！<br></div><h2 id="第8章-MPI并行计算的两种基本模式"><a href="#第8章-MPI并行计算的两种基本模式" class="headerlink" title="第8章-MPI并行计算的两种基本模式"></a>第8章-MPI并行计算的两种基本模式</h2><p>mpi的两种基本模式：对等模式和主从模式，绝大多数MPI程序都是这两种模式之一或二</p><h4 id="对等模式的MPI程序设计"><a href="#对等模式的MPI程序设计" class="headerlink" title="对等模式的MPI程序设计"></a>对等模式的MPI程序设计</h4><blockquote><p>在这里采用了Jacobi迭代举例子，Jacobi迭代就是迭代的新值是原来的旧值点相邻数值点的平均，将参与迭代的数据安快分割后，个快之间除了相邻的元素需要通信外，在个快的内部可以完全独立地并行计算，随着计算规模的扩大，通信的开销相对于计算来说比例会降低，这将更有利于提高并行效果。</p></blockquote><p>为了并行求解，这里将参加迭代的数据按列进行分割，并假设一共有4个进程同时并行计算，数据的分割结果如图所示。<br><img src="http://ww1.sinaimg.cn/large/006r0i4lgy1fle3nnlgvoj31ai0o2n0f.jpg"></p><blockquote><p>由于在迭代过程中，边界点新值的计算需要相邻边界其它块的数据，因此在每个数据块的两侧又各增加1列的数据空间，用于存放从相邻数据块通信得到的数据。这样原来每个数据块的大小从M*N扩大到M* (N+2),进程0和进程1的数据块只需扩大一块即可满足通信的要求，但这里为了编程的方便和形式的一致，在两边都增加了数据块。计算和通信过程是这样的，首先对数组赋初值，边界赋为8，内部赋为0，注意对不同的进程，赋值方式是不同的(两个内部块相同，但内部块和两个外部块两两互不相同)。然后便开始进行Jacobi迭代，在迭代之前，每个进程都需要从相邻的进程得到数据块，同时每一个进程也都需要向相邻的进程提供数据块(图27,注意FORTRAN数组在内存中是按列优先排列的)。由于每一个新迭代点的值是由相邻点的旧值得到，所以这里弓|入一个中间数组，用来记录临时得到的新值，一次迭代完成后，再统一进行更新操作。</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/006r0i4lgy1fle3vebmtgj316q0rwgpj.jpg"></p><h4 id="矩阵向量乘法-主从模式"><a href="#矩阵向量乘法-主从模式" class="headerlink" title="矩阵向量乘法-主从模式"></a>矩阵向量乘法-主从模式</h4><blockquote><p>下面的例子实现C=AxB。主进程将向量B广播给所有的从进程，然后将矩阵A的各行依次发送给从进程，从进程计算一行和B相乘的结果，然后将结果发送给主进程。主进程循环向各个从进程发送一行的数据，直到将A各行的数据发送完毕,一旦主进程将A的各行发送完毕，则每收到一个结果，就向相应的从进程发送结束标志，从进程接收到结束标志后退出执行。主进程收集完所有的结果后也结束。</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/006r0i4lgy1fle3yu01naj316u0nc41f.jpg"></p><div class="tip">第九章内容太多，放在一篇文章里太长了，所以就放到了下一篇文章里，以上部分是mpi的一些基础部分，后面就开始讲解高级的并行计算。</div>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h2&gt;&lt;p&gt;确认研究方向是并行计算之后，却一直没有认真接触。从开学到现在这段时间都在看一些无关紧要的东西，像&lt;a href=&quot;https://cn.vuejs.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;vuejs&lt;/a&gt;把官方文档过了一遍；&lt;a href=&quot;https://book.douban.com/subject/27028517/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《流畅的python》&lt;/a&gt;也看了一多半，感觉确实写的很nice；接触了python web异步框架&lt;a href=&quot;https://tornado-zh.readthedocs.io/zh/latest/#&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;tornado&lt;/a&gt;。最近用vue全家桶(&lt;a href=&quot;https://cn.vuejs.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;vuejs&lt;/a&gt;、&lt;a href=&quot;https://router.vuejs.org/zh-cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;vue-router&lt;/a&gt;、&lt;a href=&quot;https://vuex.vuejs.org/zh-cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;vuex&lt;/a&gt;)和&lt;a href=&quot;https://tornado-zh.readthedocs.io/zh/latest/#&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;tornado&lt;/a&gt;写了一些东西，关于这部分准备以后写篇文章来记录下。近期要开始毕设选题了，北航的学长帮我想了一个和并行计算相关的课题。也推荐了&lt;a href=&quot;https://book.douban.com/subject/1244566/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《高性能计算-并行编程技术》&lt;/a&gt;当做入门书籍。这篇文章就当一个学习笔记，记录mpi一些相关的知识点。后期准备将每个章节出现的代码都用c重新实现一遍。&lt;a href=&quot;https://github.com/yangsoon/MPI-Demo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;相关代码地址&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="mpi" scheme="https://yangsoon.github.io/tags/mpi/"/>
    
      <category term="并行计算" scheme="https://yangsoon.github.io/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>vagrant开发遇到的坑</title>
    <link href="https://yangsoon.github.io/2017/10/01/vagrant%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"/>
    <id>https://yangsoon.github.io/2017/10/01/vagrant开发遇到的坑/</id>
    <published>2017-10-01T04:39:35.000Z</published>
    <updated>2017-11-09T12:50:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="npm-EPROTO-protocol-error-symlink"><a href="#npm-EPROTO-protocol-error-symlink" class="headerlink" title="npm EPROTO: protocol error, symlink"></a>npm EPROTO: protocol error, symlink</h2><p>在虚拟机下初始化js项目时，开始会执行 <code>npm install</code>这时候经常会遇到这样的错误，原因是windows和linux在符号链接上有不同的定义和实现。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p><code>npm install --no-bin-links</code></p><h2 id="webpack-dev-server-不能热更新"><a href="#webpack-dev-server-不能热更新" class="headerlink" title="webpack-dev-server 不能热更新"></a>webpack-dev-server 不能热更新</h2><a id="more"></a><p>在使用webpack进行前端开发时，使用起来最方便的应该是webpack的热更新了，但是在vagrant下我们会发现webpack不能进行热更新。在<a href="https://en.wikipedia.org/wiki/Inotify" target="_blank" rel="noopener">wiki</a>中有这样一段话。</p><blockquote><p>Notification via inotify requires the kernel to be aware of all relevant filesystem events, which is not always possible for networked filesystems such as NFS …</p></blockquote><p>大概意思是对于类似NFS这样的网络系统文件，文件的变化并不总是能够成功的通知到变化。好在这并没有宣布彻底放弃当前方案，后面有人给出了方案:</p><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p><code>watchOptions: { poll: true }</code></p><p>我们可以使用webpack –watch –color,设置poll属性，Webpack会在100毫秒左右内检测文件更新，随时build。</p><h2 id="npm安装的全局应用command-not-found"><a href="#npm安装的全局应用command-not-found" class="headerlink" title="npm安装的全局应用command not found"></a>npm安装的全局应用<code>command not found</code></h2><p>当我们使用npm安装一些js应用(vue-cli、webpack、supervisor)时，执行相应的命令的时候，经常因为路径问题出现命令找不到的情况，有时候根据情况不同，解决方案也会有多种。在这里我给大家推荐使用<a href="https://yarnpkg.com/zh-Hans/" target="_blank" rel="noopener">yarn</a>安装一些node包。</p><h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><h4 id="1-Ubuntu下安装yarn"><a href="#1-Ubuntu下安装yarn" class="headerlink" title="1.Ubuntu下安装yarn"></a>1.Ubuntu下安装yarn</h4><p><code>sudo apt-get update &amp;&amp; sudo apt-get install yarn</code></p><h4 id="2-使用yarn安装全局node包"><a href="#2-使用yarn安装全局node包" class="headerlink" title="2.使用yarn安装全局node包"></a>2.使用yarn安装全局node包</h4><p><code>yarn global add &lt;package...&gt;</code></p><p>更多命令查看<a href="https://yarnpkg.com/zh-Hans/docs/cli/" target="_blank" rel="noopener">文档</a></p><h2 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h2><div class="tip"><br>这些主要是在进行前端开发的时候遇到的一些问题，但是经过一些折腾之后，我觉得最好的解决方案就是不要用虚拟机进行前端开发。实践证明，前端开发不一定要追求linux环境。如果想更快的学习前端知识，远离虚拟机。<br></div><p>参考文章<br><a href="http://www.jackpu.com/shi-yong-vagrant-he-webpackkai-fa-cai-guo-de-keng/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">使用Vagrant + webpack开发踩过的坑</a><br><a href="https://blog.wangboyang.com/npm-eproto-protocol-error-symlink/" target="_blank" rel="noopener">npm EPROTO: protocol error, symlink</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;npm-EPROTO-protocol-error-symlink&quot;&gt;&lt;a href=&quot;#npm-EPROTO-protocol-error-symlink&quot; class=&quot;headerlink&quot; title=&quot;npm EPROTO: protocol error, symlink&quot;&gt;&lt;/a&gt;npm EPROTO: protocol error, symlink&lt;/h2&gt;&lt;p&gt;在虚拟机下初始化js项目时，开始会执行 &lt;code&gt;npm install&lt;/code&gt;这时候经常会遇到这样的错误，原因是windows和linux在符号链接上有不同的定义和实现。&lt;/p&gt;
&lt;h4 id=&quot;解决方案&quot;&gt;&lt;a href=&quot;#解决方案&quot; class=&quot;headerlink&quot; title=&quot;解决方案&quot;&gt;&lt;/a&gt;解决方案&lt;/h4&gt;&lt;p&gt;&lt;code&gt;npm install --no-bin-links&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;webpack-dev-server-不能热更新&quot;&gt;&lt;a href=&quot;#webpack-dev-server-不能热更新&quot; class=&quot;headerlink&quot; title=&quot;webpack-dev-server 不能热更新&quot;&gt;&lt;/a&gt;webpack-dev-server 不能热更新&lt;/h2&gt;
    
    </summary>
    
    
      <category term="vagrant" scheme="https://yangsoon.github.io/tags/vagrant/"/>
    
      <category term="webpack" scheme="https://yangsoon.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://yangsoon.github.io/2017/09/30/hello-world/"/>
    <id>https://yangsoon.github.io/2017/09/30/hello-world/</id>
    <published>2017-09-30T05:48:55.000Z</published>
    <updated>2017-09-30T05:48:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
