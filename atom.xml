<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yangsoon</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yangsoon.github.io/"/>
  <updated>2017-11-21T15:40:04.000Z</updated>
  <id>https://yangsoon.github.io/</id>
  
  <author>
    <name>yangs</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>telegram-bots for developers</title>
    <link href="https://yangsoon.github.io/2017/11/21/telegram-bots-for-developers/"/>
    <id>https://yangsoon.github.io/2017/11/21/telegram-bots-for-developers/</id>
    <published>2017-11-21T14:03:14.000Z</published>
    <updated>2017-11-21T15:40:04.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="写给开发者的telegram-bots介绍文档"><a href="#写给开发者的telegram-bots介绍文档" class="headerlink" title="写给开发者的telegram-bots介绍文档"></a>写给开发者的telegram-bots介绍文档</h4><p>bots是运行在telegram内部的第三方应用。用户可以通过发送消息，命令或者<a href="#inline-mode">内联请求</a>和bots进行交互。开发者可以通过向<a href="https://core.telegram.org/bots/api" target="_blank" rel="external">bot API</a>发送HTTPS请求来控制自己的bot。<br><a id="more"></a></p><h2 id="我能用bots做什么？"><a href="#我能用bots做什么？" class="headerlink" title="我能用bots做什么？"></a>我能用bots做什么？</h2><p>下面举几个例子，你可以用bot来：</p><ul><li>获得自定义的新闻和通知。一个机器人可以扮演一个智能新闻的角色，发送你需要的新闻。 如：<a href="https://t.me/TechCrunchBot" target="_blank" rel="external">TechCrunch Bot</a></li><li>和其他服务集成。一个机器人可以通过联系其他的服务来丰富聊天 如:<a href="https://t.me/gmailbot" target="_blank" rel="external">Gmail Bot</a></li><li>接受来自telegram用户的付款</li><li>创建自定义工具 一个机器人可以为你提供预警，天气预报，格式化文本，翻译，或者其他服务.如: <a href="https://t.me/Bold" target="_blank" rel="external">Markdown</a></li><li>创建单人多人游戏 一个机器人可以提供丰富的HTML5体验，从简单的街机和解谜游戏到3D射击和实时策略游戏。如:  <a href="https://t.me/gamebot" target="_blank" rel="external">GameBot</a></li><li>建立社交服务 一个机器人能够将一些寻找共同兴趣爱好的人联系在一起。如:<a href="https://t.me/hotorbot" target="_blank" rel="external">HotOrBot</a></li><li>或者做一些其他的事情 除了做菜–机器人做的菜非常糟糕(官方吐槽)</li></ul><h2 id="bots是如何工作的"><a href="#bots是如何工作的" class="headerlink" title="bots是如何工作的?"></a>bots是如何工作的?</h2><p>Telegram Bots是一个特别的账号并不需要另外的手机号码去创建，用户可以通过下面两种方式和机器人交互。</p><ol><li>创建和bots的聊天并发送消息和命令或者将机器人加入聊天群。这对聊天机器人和官方新闻机器人很有用。</li><li>直接在输入框中键入<code>@username query</code>来发送请求。这允许从内联机器人发送内容直接到任何的聊天，群或者频道。</li></ol><p>用户发送的消息，命令，和请求被传递给运行在你服务上的应用。我们的中介服务器帮你处理消息的加密和telegram api的通讯。你可以通过简单的HTTPS接口(他提供了Telegram API的简化版本)和服务通讯。我们把这个接口称为Bot API。</p><blockquote><p>有关Bot API的详细说明，请参阅 <a href="https://core.telegram.org/bots/api" target="_blank" rel="external">bots api</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;写给开发者的telegram-bots介绍文档&quot;&gt;&lt;a href=&quot;#写给开发者的telegram-bots介绍文档&quot; class=&quot;headerlink&quot; title=&quot;写给开发者的telegram-bots介绍文档&quot;&gt;&lt;/a&gt;写给开发者的telegram-bots介绍文档&lt;/h4&gt;&lt;p&gt;bots是运行在telegram内部的第三方应用。用户可以通过发送消息，命令或者&lt;a href=&quot;#inline-mode&quot;&gt;内联请求&lt;/a&gt;和bots进行交互。开发者可以通过向&lt;a href=&quot;https://core.telegram.org/bots/api&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;bot API&lt;/a&gt;发送HTTPS请求来控制自己的bot。&lt;br&gt;
    
    </summary>
    
    
      <category term="introduction" scheme="https://yangsoon.github.io/tags/introduction/"/>
    
      <category term="telegram-bots" scheme="https://yangsoon.github.io/tags/telegram-bots/"/>
    
  </entry>
  
  <entry>
    <title>mpi读书笔记(2)</title>
    <link href="https://yangsoon.github.io/2017/11/11/mpi%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-2/"/>
    <id>https://yangsoon.github.io/2017/11/11/mpi读书笔记-2/</id>
    <published>2017-11-11T06:29:56.000Z</published>
    <updated>2017-11-11T06:29:56.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MPI读书笔记(一)</title>
    <link href="https://yangsoon.github.io/2017/11/10/MPI%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://yangsoon.github.io/2017/11/10/MPI读书笔记/</id>
    <published>2017-11-10T06:55:15.000Z</published>
    <updated>2017-11-11T06:24:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>确认研究方向是并行计算之后，却一直没有认真接触。从开学到现在这段时间都在看一些无关紧要的东西，像<a href="https://cn.vuejs.org/" target="_blank" rel="external">vuejs</a>把官方文档过了一遍；<a href="https://book.douban.com/subject/27028517/" target="_blank" rel="external">《流畅的python》</a>也看了一多半，感觉确实写的很nice；接触了python web异步框架<a href="https://tornado-zh.readthedocs.io/zh/latest/#" target="_blank" rel="external">tornado</a>。最近用vue全家桶(<a href="https://cn.vuejs.org/" target="_blank" rel="external">vuejs</a>、<a href="https://router.vuejs.org/zh-cn/" target="_blank" rel="external">vue-router</a>、<a href="https://vuex.vuejs.org/zh-cn/" target="_blank" rel="external">vuex</a>)和<a href="https://tornado-zh.readthedocs.io/zh/latest/#" target="_blank" rel="external">tornado</a>写了一些东西，关于这部分准备以后写篇文章来记录下。近期要开始毕设选题了，北航的学长帮我想了一个和并行计算相关的课题。也推荐了<a href="https://book.douban.com/subject/1244566/" target="_blank" rel="external">《高性能计算-并行编程技术》</a>当做入门书籍。这篇文章就当一个学习笔记，记录mpi一些相关的知识点。后期准备将每个章节出现的代码都用c重新实现一遍。<a href="https://github.com/yangsoon/MPI-Demo" target="_blank" rel="external">相关代码地址</a><br><a id="more"></a></p><h1 id="并行计算基础"><a href="#并行计算基础" class="headerlink" title="并行计算基础"></a>并行计算基础</h1><h2 id="第1章-并行计算机"><a href="#第1章-并行计算机" class="headerlink" title="第1章-并行计算机"></a>第1章-并行计算机</h2><p>并行计算机即在同一时间执行多条指令(或处理多个数据)的计算机，并行计算机是并行计算的物理载体。</p><ul><li>根据并行计算机能同时执行指令和数据的多少分为 SIMD(单指令多数据)和MIMD(多指令多数据)</li><li>根据执行程序和数据的不同分为SPMD(单程序多数据)和MPMD(多程序多数据)</li><li>从存储方式上可以分为共享内存、分布式内存、分布式共享内存并行计算机</li></ul><h2 id="第2章-并行编程模行与并行语言-amp-amp-第3章-并行算法"><a href="#第2章-并行编程模行与并行语言-amp-amp-第3章-并行算法" class="headerlink" title="第2章-并行编程模行与并行语言&amp;&amp;第3章-并行算法"></a>第2章-并行编程模行与并行语言&amp;&amp;第3章-并行算法</h2><h1 id="基本MPI程序设计"><a href="#基本MPI程序设计" class="headerlink" title="基本MPI程序设计"></a>基本MPI程序设计</h1><h2 id="第4章-MPI简介"><a href="#第4章-MPI简介" class="headerlink" title="第4章-MPI简介"></a>第4章-MPI简介</h2><p>1.MPI是一个库，而不是一门语言。<br>2.MPI是一种规范或标准的代表，不特指某一个对它的具体实现。<br>3.MPI是一种消息传递编程模型。</p><h2 id="第5章-第一个MPI程序"><a href="#第5章-第一个MPI程序" class="headerlink" title="第5章-第一个MPI程序"></a>第5章-第一个MPI程序</h2><p>下面演示第一个mpi程序的编写和运行结果。后面解释mpi的api。</p><blockquote><p><code>hello.c</code></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mpi.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</div><div class="line"><span class="keyword">int</span> myid, numprocs;</div><div class="line"><span class="keyword">int</span> namelen;</div><div class="line"><span class="keyword">char</span> processor_name[MPI_MAX_PROCESSOR_NAME];</div><div class="line"></div><div class="line">MPI_Init(&amp;argc, &amp;argv);</div><div class="line">MPI_Comm_rank(MPI_COMM_WORLD, &amp;myid);</div><div class="line">MPI_Comm_size(MPI_COMM_WORLD, &amp;numprocs);</div><div class="line">MPI_Get_processor_name(processor_name, &amp;namelen);</div><div class="line"></div><div class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Hello World! Process %d of %d on %s\n"</span>, myid, numprocs, processor_name);</div><div class="line"></div><div class="line">MPI_Finalize();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>执行</p><blockquote><p><code>mpicc -o hello hello.c</code><br><code>mpirun -n 2 hello</code>(跑在本地2核处理器见谅见谅)</p></blockquote><p>结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Hello World! Process 1 of 2 on promote.cache-dns.local</div><div class="line">Hello World! Process 0 of 2 on promote.cache-dns.local</div></pre></td></tr></table></figure><h2 id="第6章-六个接口构成的MPI子集"><a href="#第6章-六个接口构成的MPI子集" class="headerlink" title="第6章-六个接口构成的MPI子集"></a>第6章-六个接口构成的MPI子集</h2><h4 id="子集介绍"><a href="#子集介绍" class="headerlink" title="子集介绍"></a>子集介绍</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">初始化mpi</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Init</span><span class="params">(<span class="keyword">int</span> *argc, <span class="keyword">char</span>***argv)</span></span></div><div class="line">MPI结束 </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Finalize</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">当前进程标识 </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Comm_rank</span><span class="params">(MPI_Comm comm, <span class="keyword">int</span> *rank)</span></span></div><div class="line">通信域包含的进程数  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Comm_size</span><span class="params">(MPI_Comm comm, <span class="keyword">int</span> *size)</span></span></div><div class="line">消息发送 </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Send</span><span class="params">(<span class="keyword">void</span>* buff, <span class="keyword">int</span> count, MPI_Datatype datatype, <span class="keyword">int</span> dest, <span class="keyword">int</span> tag, MPI_Comm comm)</span></span></div><div class="line">消息接收 </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Recv</span><span class="params">(<span class="keyword">void</span>* buff, <span class="keyword">int</span> count, MPI_Datatype datatype, <span class="keyword">int</span> source, <span class="keyword">int</span> tag, MPI_Comm comm, MPI_Status *status)</span></span></div></pre></td></tr></table></figure><h4 id="参数介绍"><a href="#参数介绍" class="headerlink" title="参数介绍"></a>参数介绍</h4><blockquote><p><code>MPI_Comm_rank</code></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">MPI_Comm comm 该进程所在的通信域(句柄)</div><div class="line"><span class="keyword">int</span> *rank     调用进程在comm中的标识号</div></pre></td></tr></table></figure><blockquote><p><code>int MPI_Comm_size</code></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *size     通信域comm内包含的进程数</div></pre></td></tr></table></figure><blockquote><p><code>MPI_Send</code></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span>* buf                  发送缓冲区的起始地址(可选类型)</div><div class="line"><span class="keyword">int</span> count                  将发送的数据个数(非负整数)</div><div class="line">MPI_Datatype datatype      发送数据的数据类型(句柄)</div><div class="line"><span class="keyword">int</span> dest                   目的进程的标识号(整型)</div><div class="line"><span class="keyword">int</span> tag                    消息标志(整型)</div></pre></td></tr></table></figure><blockquote><p><code>MPI_Recv</code></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span>* buf                  接收缓冲区的起始地址(可选类型)</div><div class="line"><span class="keyword">int</span> count                  最多可接受的数据个数(非负整数)</div><div class="line">MPI_Datatype datatype      接收数据的数据类型(句柄)</div><div class="line"><span class="keyword">int</span> dest                   接收数据来源进程的标识号(整型)</div><div class="line"><span class="keyword">int</span> tag                    消息标志(整型)</div><div class="line"><span class="keyword">int</span> *status                返回状态(状态类型)</div><div class="line">MPI_Status status &#123; MPI_SOURCE, MPI_TAG, MPI_ERROR &#125;</div></pre></td></tr></table></figure><h4 id="一个简单的接收和发送的例子"><a href="#一个简单的接收和发送的例子" class="headerlink" title="一个简单的接收和发送的例子"></a>一个简单的接收和发送的例子</h4><blockquote><p><code>example1.c</code></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 参照原书6.1.9部分代码，略有改动。</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mpi.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</div><div class="line">    <span class="keyword">char</span> message[<span class="number">20</span>];</div><div class="line">    <span class="keyword">int</span> myrank;</div><div class="line">    <span class="keyword">int</span> number;</div><div class="line">    MPI_Status status;</div><div class="line"></div><div class="line">    <span class="comment">// MPI程序初始化</span></div><div class="line">    MPI_Init(&amp;argc, &amp;argv);</div><div class="line">    <span class="comment">// 得到当前进程的标识</span></div><div class="line">    MPI_Comm_rank(MPI_COMM_WORLD, &amp;myrank);</div><div class="line">    <span class="comment">// 得到通信域下的进程数</span></div><div class="line">    MPI_Comm_size(MPI_COMM_WORLD, &amp;number);</div><div class="line">    <span class="comment">// 进程0发送消息给进程1</span></div><div class="line">    <span class="keyword">if</span> (myrank == <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"mpi size:%d\n"</span>, number);</div><div class="line">        <span class="built_in">strcpy</span>(message, <span class="string">"Hello,process 1"</span>);</div><div class="line">        MPI_Send(message, <span class="built_in">strlen</span>(message), MPI_CHAR, <span class="number">1</span>, <span class="number">99</span>, MPI_COMM_WORLD);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"process%d send: %s -&gt; process 1\n"</span>, myrank, message);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 进程1接收来自进程0的消息</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(myrank == <span class="number">1</span>) &#123;</div><div class="line">        MPI_Recv(message, <span class="number">20</span>, MPI_CHAR, <span class="number">0</span>, <span class="number">99</span>, MPI_COMM_WORLD, &amp;status);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"process%d recived: %s &lt;- process 0\n"</span> ,myrank ,message);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"status-&gt;MPI_SOURCE:%d\n"</span>, status.MPI_SOURCE);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"status-&gt;MPI_TAG:%d\n"</span>, status.MPI_TAG);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"status-&gt;MPI_ERROR:%d\n"</span>, status.MPI_ERROR);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 结束</span></div><div class="line">    MPI_Finalize();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>结果<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mpi size:2</div><div class="line">process0 send: Hello,process 1 -&gt; process 1</div><div class="line">process1 recived: Hello,process 1 &lt;- process 0</div><div class="line">status-&gt;MPI_SOURCE:0</div><div class="line">status-&gt;MPI_TAG:99</div><div class="line">status-&gt;MPI_ERROR:0</div></pre></td></tr></table></figure></p><h4 id="mpi预定义数据类型"><a href="#mpi预定义数据类型" class="headerlink" title="mpi预定义数据类型"></a>mpi预定义数据类型</h4><table><thead><tr><th style="text-align:center">MPI预定义数据类型</th><th style="text-align:center">相应的c数据类型</th></tr></thead><tbody><tr><td style="text-align:center">MPI_CHAR</td><td style="text-align:center">signed char</td></tr><tr><td style="text-align:center">MPI_SHORT</td><td style="text-align:center">signed short int</td></tr><tr><td style="text-align:center">MPI_INT</td><td style="text-align:center">signed int</td></tr><tr><td style="text-align:center">MPI_LONG</td><td style="text-align:center">signed long int</td></tr><tr><td style="text-align:center">MPI_UNSIGNED_CHAR</td><td style="text-align:center">unsigned char</td></tr><tr><td style="text-align:center">MPI_UNSIGNED_SHORT</td><td style="text-align:center">unsigned short int</td></tr><tr><td style="text-align:center">MPI_UNSIGNED</td><td style="text-align:center">unsigned int</td></tr><tr><td style="text-align:center">MPI_UNSIGNED_LONG</td><td style="text-align:center">unsigned long int</td></tr><tr><td style="text-align:center">MPI_FLOAT</td><td style="text-align:center">float</td></tr><tr><td style="text-align:center">MPI_DOUBLE</td><td style="text-align:center">double</td></tr><tr><td style="text-align:center">MPI_LONG_DOUBLE</td><td style="text-align:center">long double</td></tr><tr><td style="text-align:center">MPI_BYTE</td><td style="text-align:center">#</td></tr><tr><td style="text-align:center">MPI_PACKED</td><td style="text-align:center">#</td></tr></tbody></table><h4 id="mpi消息组成"><a href="#mpi消息组成" class="headerlink" title="mpi消息组成"></a>mpi消息组成</h4><p><img src="http://ww1.sinaimg.cn/large/006r0i4lgy1fle2ogr9tej30t40feabl.jpg" style="width:400px;"></p><h2 id="第7章-简单的MPI程序示例"><a href="#第7章-简单的MPI程序示例" class="headerlink" title="第7章-简单的MPI程序示例"></a>第7章-简单的MPI程序示例</h2><div class="tip"><br>书中此部分有7个demo，但由于实验环境问题，有些代码不能很好的调试，后面我会不断完善这部分的代码，<a href="https://github.com/yangsoon/MPI-Demo" target="_blank" rel="external">代码地址</a>托管在github上。请大家见谅！<br></div><h2 id="第8章-MPI并行计算的两种基本模式"><a href="#第8章-MPI并行计算的两种基本模式" class="headerlink" title="第8章-MPI并行计算的两种基本模式"></a>第8章-MPI并行计算的两种基本模式</h2><p>mpi的两种基本模式：对等模式和主从模式，绝大多数MPI程序都是这两种模式之一或二</p><h4 id="对等模式的MPI程序设计"><a href="#对等模式的MPI程序设计" class="headerlink" title="对等模式的MPI程序设计"></a>对等模式的MPI程序设计</h4><blockquote><p>在这里采用了Jacobi迭代举例子，Jacobi迭代就是迭代的新值是原来的旧值点相邻数值点的平均，将参与迭代的数据安快分割后，个快之间除了相邻的元素需要通信外，在个快的内部可以完全独立地并行计算，随着计算规模的扩大，通信的开销相对于计算来说比例会降低，这将更有利于提高并行效果。</p></blockquote><p>为了并行求解，这里将参加迭代的数据按列进行分割，并假设一共有4个进程同时并行计算，数据的分割结果如图所示。<br><img src="http://ww1.sinaimg.cn/large/006r0i4lgy1fle3nnlgvoj31ai0o2n0f.jpg"></p><blockquote><p>由于在迭代过程中，边界点新值的计算需要相邻边界其它块的数据，因此在每个数据块的两侧又各增加1列的数据空间，用于存放从相邻数据块通信得到的数据。这样原来每个数据块的大小从M*N扩大到M* (N+2),进程0和进程1的数据块只需扩大一块即可满足通信的要求，但这里为了编程的方便和形式的一致，在两边都增加了数据块。计算和通信过程是这样的，首先对数组赋初值，边界赋为8，内部赋为0，注意对不同的进程，赋值方式是不同的(两个内部块相同，但内部块和两个外部块两两互不相同)。然后便开始进行Jacobi迭代，在迭代之前，每个进程都需要从相邻的进程得到数据块，同时每一个进程也都需要向相邻的进程提供数据块(图27,注意FORTRAN数组在内存中是按列优先排列的)。由于每一个新迭代点的值是由相邻点的旧值得到，所以这里弓|入一个中间数组，用来记录临时得到的新值，一次迭代完成后，再统一进行更新操作。</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/006r0i4lgy1fle3vebmtgj316q0rwgpj.jpg"></p><h4 id="矩阵向量乘法-主从模式"><a href="#矩阵向量乘法-主从模式" class="headerlink" title="矩阵向量乘法-主从模式"></a>矩阵向量乘法-主从模式</h4><blockquote><p>下面的例子实现C=AxB。主进程将向量B广播给所有的从进程，然后将矩阵A的各行依次发送给从进程，从进程计算一行和B相乘的结果，然后将结果发送给主进程。主进程循环向各个从进程发送一行的数据，直到将A各行的数据发送完毕,一旦主进程将A的各行发送完毕，则每收到一个结果，就向相应的从进程发送结束标志，从进程接收到结束标志后退出执行。主进程收集完所有的结果后也结束。</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/006r0i4lgy1fle3yu01naj316u0nc41f.jpg"></p><div class="tip">第九章内容太多，放在一篇文章里太长了，所以就放到了下一篇文章里，以上部分是mpi的一些基础部分，后面就开始讲解高级的并行计算。</div>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h2&gt;&lt;p&gt;确认研究方向是并行计算之后，却一直没有认真接触。从开学到现在这段时间都在看一些无关紧要的东西，像&lt;a href=&quot;https://cn.vuejs.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;vuejs&lt;/a&gt;把官方文档过了一遍；&lt;a href=&quot;https://book.douban.com/subject/27028517/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《流畅的python》&lt;/a&gt;也看了一多半，感觉确实写的很nice；接触了python web异步框架&lt;a href=&quot;https://tornado-zh.readthedocs.io/zh/latest/#&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;tornado&lt;/a&gt;。最近用vue全家桶(&lt;a href=&quot;https://cn.vuejs.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;vuejs&lt;/a&gt;、&lt;a href=&quot;https://router.vuejs.org/zh-cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;vue-router&lt;/a&gt;、&lt;a href=&quot;https://vuex.vuejs.org/zh-cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;vuex&lt;/a&gt;)和&lt;a href=&quot;https://tornado-zh.readthedocs.io/zh/latest/#&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;tornado&lt;/a&gt;写了一些东西，关于这部分准备以后写篇文章来记录下。近期要开始毕设选题了，北航的学长帮我想了一个和并行计算相关的课题。也推荐了&lt;a href=&quot;https://book.douban.com/subject/1244566/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《高性能计算-并行编程技术》&lt;/a&gt;当做入门书籍。这篇文章就当一个学习笔记，记录mpi一些相关的知识点。后期准备将每个章节出现的代码都用c重新实现一遍。&lt;a href=&quot;https://github.com/yangsoon/MPI-Demo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;相关代码地址&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="mpi" scheme="https://yangsoon.github.io/tags/mpi/"/>
    
      <category term="并行计算" scheme="https://yangsoon.github.io/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>vagrant开发遇到的坑</title>
    <link href="https://yangsoon.github.io/2017/10/01/vagrant%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"/>
    <id>https://yangsoon.github.io/2017/10/01/vagrant开发遇到的坑/</id>
    <published>2017-10-01T04:39:35.000Z</published>
    <updated>2017-11-09T12:50:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="npm-EPROTO-protocol-error-symlink"><a href="#npm-EPROTO-protocol-error-symlink" class="headerlink" title="npm EPROTO: protocol error, symlink"></a>npm EPROTO: protocol error, symlink</h2><p>在虚拟机下初始化js项目时，开始会执行 <code>npm install</code>这时候经常会遇到这样的错误，原因是windows和linux在符号链接上有不同的定义和实现。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p><code>npm install --no-bin-links</code></p><h2 id="webpack-dev-server-不能热更新"><a href="#webpack-dev-server-不能热更新" class="headerlink" title="webpack-dev-server 不能热更新"></a>webpack-dev-server 不能热更新</h2><a id="more"></a><p>在使用webpack进行前端开发时，使用起来最方便的应该是webpack的热更新了，但是在vagrant下我们会发现webpack不能进行热更新。在<a href="https://en.wikipedia.org/wiki/Inotify" target="_blank" rel="external">wiki</a>中有这样一段话。</p><blockquote><p>Notification via inotify requires the kernel to be aware of all relevant filesystem events, which is not always possible for networked filesystems such as NFS …</p></blockquote><p>大概意思是对于类似NFS这样的网络系统文件，文件的变化并不总是能够成功的通知到变化。好在这并没有宣布彻底放弃当前方案，后面有人给出了方案:</p><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p><code>watchOptions: { poll: true }</code></p><p>我们可以使用webpack –watch –color,设置poll属性，Webpack会在100毫秒左右内检测文件更新，随时build。</p><h2 id="npm安装的全局应用command-not-found"><a href="#npm安装的全局应用command-not-found" class="headerlink" title="npm安装的全局应用command not found"></a>npm安装的全局应用<code>command not found</code></h2><p>当我们使用npm安装一些js应用(vue-cli、webpack、supervisor)时，执行相应的命令的时候，经常因为路径问题出现命令找不到的情况，有时候根据情况不同，解决方案也会有多种。在这里我给大家推荐使用<a href="https://yarnpkg.com/zh-Hans/" target="_blank" rel="external">yarn</a>安装一些node包。</p><h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><h4 id="1-Ubuntu下安装yarn"><a href="#1-Ubuntu下安装yarn" class="headerlink" title="1.Ubuntu下安装yarn"></a>1.Ubuntu下安装yarn</h4><p><code>sudo apt-get update &amp;&amp; sudo apt-get install yarn</code></p><h4 id="2-使用yarn安装全局node包"><a href="#2-使用yarn安装全局node包" class="headerlink" title="2.使用yarn安装全局node包"></a>2.使用yarn安装全局node包</h4><p><code>yarn global add &lt;package...&gt;</code></p><p>更多命令查看<a href="https://yarnpkg.com/zh-Hans/docs/cli/" target="_blank" rel="external">文档</a></p><h2 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h2><div class="tip"><br>这些主要是在进行前端开发的时候遇到的一些问题，但是经过一些折腾之后，我觉得最好的解决方案就是不要用虚拟机进行前端开发。实践证明，前端开发不一定要追求linux环境。如果想更快的学习前端知识，远离虚拟机。<br></div><p>参考文章<br><a href="http://www.jackpu.com/shi-yong-vagrant-he-webpackkai-fa-cai-guo-de-keng/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">使用Vagrant + webpack开发踩过的坑</a><br><a href="https://blog.wangboyang.com/npm-eproto-protocol-error-symlink/" target="_blank" rel="external">npm EPROTO: protocol error, symlink</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;npm-EPROTO-protocol-error-symlink&quot;&gt;&lt;a href=&quot;#npm-EPROTO-protocol-error-symlink&quot; class=&quot;headerlink&quot; title=&quot;npm EPROTO: protocol error, symlink&quot;&gt;&lt;/a&gt;npm EPROTO: protocol error, symlink&lt;/h2&gt;&lt;p&gt;在虚拟机下初始化js项目时，开始会执行 &lt;code&gt;npm install&lt;/code&gt;这时候经常会遇到这样的错误，原因是windows和linux在符号链接上有不同的定义和实现。&lt;/p&gt;
&lt;h4 id=&quot;解决方案&quot;&gt;&lt;a href=&quot;#解决方案&quot; class=&quot;headerlink&quot; title=&quot;解决方案&quot;&gt;&lt;/a&gt;解决方案&lt;/h4&gt;&lt;p&gt;&lt;code&gt;npm install --no-bin-links&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;webpack-dev-server-不能热更新&quot;&gt;&lt;a href=&quot;#webpack-dev-server-不能热更新&quot; class=&quot;headerlink&quot; title=&quot;webpack-dev-server 不能热更新&quot;&gt;&lt;/a&gt;webpack-dev-server 不能热更新&lt;/h2&gt;
    
    </summary>
    
    
      <category term="vagrant" scheme="https://yangsoon.github.io/tags/vagrant/"/>
    
      <category term="webpack" scheme="https://yangsoon.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://yangsoon.github.io/2017/09/30/hello-world/"/>
    <id>https://yangsoon.github.io/2017/09/30/hello-world/</id>
    <published>2017-09-30T05:48:55.000Z</published>
    <updated>2017-09-30T05:48:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
