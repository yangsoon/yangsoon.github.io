<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yangsoon</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yangsoon.github.io/"/>
  <updated>2019-01-20T08:01:52.466Z</updated>
  <id>https://yangsoon.github.io/</id>
  
  <author>
    <name>yangs</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>py_FP</title>
    <link href="https://yangsoon.github.io/2019/01/13/py-FP/"/>
    <id>https://yangsoon.github.io/2019/01/13/py-FP/</id>
    <published>2019-01-13T11:33:39.000Z</published>
    <updated>2019-01-20T08:01:52.466Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">(xs)</span>:</span></div><div class="line">    xs.rever</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> count, takewhile</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">prime</span><span class="params">()</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sieve</span><span class="params">(numbers)</span>:</span></div><div class="line">        head = next(numbers)</div><div class="line">        <span class="keyword">yield</span> head</div><div class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> sieve(n <span class="keyword">for</span> n <span class="keyword">in</span> numbers <span class="keyword">if</span> n % head)</div><div class="line">    <span class="keyword">return</span> sieve(count(<span class="number">2</span>))</div><div class="line">list(takewhile(<span class="keyword">lambda</span> x: x &lt; <span class="number">60</span>, prime()))</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>好文整理</title>
    <link href="https://yangsoon.github.io/2018/12/15/%E5%A5%BD%E6%96%87%E6%95%B4%E7%90%86/"/>
    <id>https://yangsoon.github.io/2018/12/15/好文整理/</id>
    <published>2018-12-15T11:58:52.000Z</published>
    <updated>2019-02-07T03:22:09.643Z</updated>
    
    <content type="html"><![CDATA[<p>整理一些在学习过程中收集的比较好的文章</p><a id="more"></a><h1 id="2019"><a href="#2019" class="headerlink" title="2019"></a>2019</h1><hr><h3 id="P-NP-NPC-问题"><a href="#P-NP-NPC-问题" class="headerlink" title="P NP NPC 问题"></a>P NP NPC 问题</h3><blockquote><p><a href="http://www.matrix67.com/blog/archives/105" target="_blank" rel="noopener">什么是P问题、NP问题、NPC问题</a></p></blockquote><h1 id="2018"><a href="#2018" class="headerlink" title="2018"></a>2018</h1><hr><h3 id="什么是-lambda-演算"><a href="#什么是-lambda-演算" class="headerlink" title="什么是$\lambda$演算"></a>什么是$\lambda$演算</h3><blockquote><p><a href="http://cgnail.github.io/academic/lambda-index/" target="_blank" rel="noopener">Good Math/Bad Math的Lambda演算系列的中文翻译</a></p></blockquote><h3 id="XGBoost"><a href="#XGBoost" class="headerlink" title="XGBoost"></a>XGBoost</h3><blockquote><p><a href="https://blog.csdn.net/qq_22238533/article/details/79477547" target="_blank" rel="noopener">xgboost原理分析以及实践</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整理一些在学习过程中收集的比较好的文章&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>我的2018</title>
    <link href="https://yangsoon.github.io/2018/12/13/%E6%88%91%E7%9A%842018/"/>
    <id>https://yangsoon.github.io/2018/12/13/我的2018/</id>
    <published>2018-12-13T07:23:27.000Z</published>
    <updated>2019-02-07T04:00:17.048Z</updated>
    
    <content type="html"><![CDATA[<p>我的2018</p><h1 id="毕业季"><a href="#毕业季" class="headerlink" title="毕业季"></a>毕业季</h1><h2 id="遗憾和希望"><a href="#遗憾和希望" class="headerlink" title="遗憾和希望"></a>遗憾和希望</h2><p>刘鑫考研结果出来了，分数线能够进入复试，但复试表现不佳，没有被中农录取，调剂到了北国会。准备复试那阵子她的状态很不好，总是担心害怕，对不起，我应该那时候陪在你身边给你鼓励。还好，我们终于结束了异地的生活，要一起去北京拼搏了，加油！我们一起努力。</p><h2 id="第一次兼职-3-31"><a href="#第一次兼职-3-31" class="headerlink" title="第一次兼职(3.31)"></a>第一次兼职(3.31)</h2><p>大四下比较闲，无聊之际选择了一份兼职工作，就是带着一些初中生去逛逛南京的大学和革命圣地，感觉这次带队很失败，因为一直在赶，从一个地点赶往下一个地点，期间没有和孩子交流什么的。也发现了自己确实粗心大意，最搞笑的是我差点把他们的校长弄丢，哈哈！还好把他们的校长找到了，在公交车上把我一顿批评。那群孩子还是很可爱的，在我被怼的时候，还在安慰我。<br><img src="http://ww1.sinaimg.cn/large/006r0i4lly1fzxpndl2dyj32io1w0u0y.jpg"></p><h2 id="在南理工的最后一个520-5-20"><a href="#在南理工的最后一个520-5-20" class="headerlink" title="在南理工的最后一个520(5.20)"></a>在南理工的最后一个520(5.20)</h2><p><img src="http://ww1.sinaimg.cn/large/006r0i4lly1fzxps64jxkj32io1w0hdt.jpg"><br><img src="http://ww1.sinaimg.cn/large/006r0i4lly1fzxpseu3zfj32io1w0e81.jpg"></p><h2 id="毕业照-6-2"><a href="#毕业照-6-2" class="headerlink" title="毕业照(6.2)"></a>毕业照(6.2)</h2><p>时间好快，真的很开心能遇到这么多好的同学，朋友。谢谢你们，大学承蒙照顾了。<br><img src="http://ww1.sinaimg.cn/large/006r0i4lly1fzxpugscz7j33402bsx6s.jpg"></p><h2 id="毕业旅行-女友篇-6-7-6-8"><a href="#毕业旅行-女友篇-6-7-6-8" class="headerlink" title="毕业旅行 女友篇 (6.7-6.8)"></a>毕业旅行 女友篇 (6.7-6.8)</h2><p>和刘鑫去了上海逛了一圈</p><h2 id="毕业旅行-室友篇-6-12-6-13"><a href="#毕业旅行-室友篇-6-12-6-13" class="headerlink" title="毕业旅行 室友篇 (6.12-6.13)"></a>毕业旅行 室友篇 (6.12-6.13)</h2><p>和亲爱的室友去苏州2日游</p><h2 id="毕业典礼-6-22"><a href="#毕业典礼-6-22" class="headerlink" title="毕业典礼 (6.22)"></a>毕业典礼 (6.22)</h2><p>爸妈来参加了我的毕业典礼</p><h2 id="第一次实习-7-22-8-31"><a href="#第一次实习-7-22-8-31" class="headerlink" title="第一次实习(7.22-8.31)"></a>第一次实习(7.22-8.31)</h2><p>在家里的互联网小镇实习</p><h1 id="开学季"><a href="#开学季" class="headerlink" title="开学季"></a>开学季</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我的2018&lt;/p&gt;
&lt;h1 id=&quot;毕业季&quot;&gt;&lt;a href=&quot;#毕业季&quot; class=&quot;headerlink&quot; title=&quot;毕业季&quot;&gt;&lt;/a&gt;毕业季&lt;/h1&gt;&lt;h2 id=&quot;遗憾和希望&quot;&gt;&lt;a href=&quot;#遗憾和希望&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>XGboost</title>
    <link href="https://yangsoon.github.io/2018/12/12/XGboost/"/>
    <id>https://yangsoon.github.io/2018/12/12/XGboost/</id>
    <published>2018-12-12T11:25:16.000Z</published>
    <updated>2019-03-09T14:20:25.261Z</updated>
    
    <content type="html"><![CDATA[<p>因为一些特别的原因，在组会上做了两次XGboost的相关报告(其实就是一周两次组会，因为老师都不一样，为了划水就两次都讲了一样的内容)。在第二次报告准备的时候，发现自己对XGboost并没有真正的了解，第一次做报告的时候，学长问了几个问题我也是xjb回答的。第二次自认为是看懂了，所以索性趁热打铁，来一发热乎乎的blog记录一下。</p><a id="more"></a><p>请见 <a href="https://github.com/yangsoon/python-notebooks/blob/master/XGboost.ipynb" target="_blank" rel="noopener">https://github.com/yangsoon/python-notebooks/blob/master/XGboost.ipynb</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为一些特别的原因，在组会上做了两次XGboost的相关报告(其实就是一周两次组会，因为老师都不一样，为了划水就两次都讲了一样的内容)。在第二次报告准备的时候，发现自己对XGboost并没有真正的了解，第一次做报告的时候，学长问了几个问题我也是xjb回答的。第二次自认为是看懂了，所以索性趁热打铁，来一发热乎乎的blog记录一下。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>线性代数笔记(三)</title>
    <link href="https://yangsoon.github.io/2018/09/05/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-3/"/>
    <id>https://yangsoon.github.io/2018/09/05/线性代数-3/</id>
    <published>2018-09-05T03:20:19.000Z</published>
    <updated>2018-12-24T09:45:25.890Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本部分主要讲解基变换、特征向量和特征值的内容。该部分对应的视频地址</p><p><a href="https://www.bilibili.com/video/av6731067/?p=13" target="_blank" rel="noopener">基变换</a>、<a href="https://www.bilibili.com/video/av6731067/?p=14&amp;spm_id_from=333.788.b_6d756c74695f70616765.14" target="_blank" rel="noopener">特征向量与特征值</a></p><a id="more"></a><h3 id="点积和对偶性、叉积"><a href="#点积和对偶性、叉积" class="headerlink" title="点积和对偶性、叉积"></a>点积和对偶性、叉积</h3><p>略</p><h3 id="基变换"><a href="#基变换" class="headerlink" title="基变换"></a>基变换</h3><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">标准坐标系的基向量</th><th style="text-align:center">另一组基向量(MJ的基向量)</th></tr></thead><tbody><tr><td style="text-align:center">基向量表示</td><td style="text-align:center">$ \hat i = \begin{bmatrix}1 \\ 0 \end{bmatrix}  \hat j = \begin{bmatrix}0 \\ 1\end{bmatrix} $</td><td style="text-align:center">$ \hat i_m \Rightarrow \begin{bmatrix}2 \\ 1 \end{bmatrix} \hat j_m \Rightarrow \begin{bmatrix} -1 \\ 1 \end{bmatrix}$ <br>(在标准坐标系中的表示)</td></tr><tr><td style="text-align:center">$\vec v$在不同基向量下的表示</td><td style="text-align:center">$ \vec v = \begin {bmatrix} 3 \\ 2\end{bmatrix} $</td><td style="text-align:center">$  \vec v = \begin{bmatrix} {5}/{3} \\ {1}/{3}\end{bmatrix} (\hat i_m = \begin{bmatrix} 1\\ 0\end{bmatrix} \hat j_m = \begin{bmatrix} 0 \\ 1\end{bmatrix})$</td></tr><tr><td style="text-align:center">MJ下的向量$\rightarrow$标准下的向量</td><td style="text-align:center">$\vec w = \begin{bmatrix} 2 &amp; -1 \\ 1  &amp; 1\end{bmatrix} \begin{bmatrix} -1\\ 2\end{bmatrix} = \begin{bmatrix} -4\\ 1\end{bmatrix}$ <br>将我们对MJ的误解转换为MJ真正想表达的向量</td><td style="text-align:center">$\vec w =  \begin{bmatrix} -1 \\ 2 \end{bmatrix} (\hat i_m = \begin{bmatrix} 1\\ 0\end{bmatrix} \hat j_m = \begin{bmatrix} 0 \\ 1\end{bmatrix}) $</td></tr><tr><td style="text-align:center">MJ下的向量$\leftarrow$标准下的向量</td><td style="text-align:center">$ \vec v = \begin {bmatrix} 3 \\ 2\end{bmatrix} $</td><td style="text-align:center">$\vec w = \begin{bmatrix} 2 &amp; -1 \\ 1  &amp; 1\end{bmatrix}^{-1} \begin{bmatrix} 3\\ 2\end{bmatrix}$</td></tr></tbody></table><p>用我们的坐标系描述MJ的基向量 $A = \begin{bmatrix} 2&amp; -1 \\ 1 &amp; 1\end{bmatrix}$  </p><p>用我们的坐标描述相同的向量 $A \begin{bmatrix} x_j \\ y_j \end{bmatrix} = \begin{bmatrix} x_o \\ y_o \end{bmatrix}$ </p><p>在标准坐标系中我们可以使用 $ M = \begin{bmatrix} 0&amp; -1 \\ 1 &amp; 0\end{bmatrix}$ 来表示一个逆时针选转$90^{\circ}$的线性变换。</p><p>对于MJ的线性变换应该怎么表示? 首先对MJ下的任意一个向量 如 $ \vec v =  \begin{bmatrix} -1 \\ 2\end{bmatrix}$, 首先将该向量转变为使用标准基向量来描述 ，然后将变换结果左乘相应的线性变换矩阵，此时结果为变换后的向量，但是是使用标准基向量来描述，所以再次左乘基变换矩阵的逆，从而得到使用MJ来描述的向量。</p><p>$$ A^{-1}MA\vec v = \begin{bmatrix} 2 &amp; -1 \\ 1  &amp; 1\end{bmatrix}^{-1}  \begin{bmatrix} 0&amp; -1 \\ 1 &amp; 0\end{bmatrix} \begin{bmatrix} 2 &amp; -1 \\ 1  &amp; 1\end{bmatrix} \begin{bmatrix} -1\\ 2\end{bmatrix}$$</p><p>因为 $\vec v$ 可以为任意向量 所以 $ A^{-1}MA = \begin{bmatrix} 2 &amp; -1 \\ 1  &amp; 1\end{bmatrix}^{-1}  \begin{bmatrix} 0&amp; -1 \\ 1 &amp; 0\end{bmatrix} \begin{bmatrix} 2 &amp; -1 \\ 1  &amp; 1\end{bmatrix} $ 表示的就是MJ下基向量描述的逆时针选转$90^{\circ}$的线性变换。</p><h3 id="特征向量与特征值"><a href="#特征向量与特征值" class="headerlink" title="特征向量与特征值"></a>特征向量与特征值</h3><p>首先声明一个线性变换矩阵 $ M = \begin{bmatrix}3&amp;1\\ 0&amp;2 \end{bmatrix}$ 我们关注他对一个特定向量的作用，并且考虑这个向量张成的空间，也就是通过原点和向量尖端的直线。某些特殊的向量在线性变换后留在了他所张成的空间。意味着线性变换对他的影响只是进行了伸长和压缩。在线性变换$M$中$\hat i$就是这样一个特殊的向量，该向量张成的空间就是$x$轴，$x$轴上的向量都被拉长了3倍。同时向量$\begin{bmatrix} -1 \\ 1\end{bmatrix}$ 在变换中也留在了自己张成的空间中。被拉伸为原来的2倍。这两个特殊的向量就被称为变换的<strong>特征向量</strong>，每个特征向量都有一个所属的值，被称为<strong>特征值</strong>。</p><p>特征向量的概念如下：</p><p>$$ A \vec v = \lambda \vec v \Rightarrow A \vec v - (\lambda I)\vec v = \vec 0 \Rightarrow (A-\lambda I)\vec v = \vec 0 $$</p><p>$A$ 代表着某种线性变换的矩阵，$\vec v$是特征向量，$\lambda$ 对应着特征值。因此我们就寻找一个向量使得新矩阵$(A-\lambda I)$与$\vec v$相乘结果为零向量。</p><p>首先不考虑$\vec v$为$\vec 0$的情况。则需要$(A-\lambda I)$ 的行列式为0，即新的矩阵代表的线性变换将空间压缩到更低的维度。即$det(A- \lambda I) = 0$</p><p>以$M$为例 </p><p>$$det(M-\lambda I) = det(\begin{bmatrix} 3-\lambda &amp; 1 \\ 0 &amp; 2-\lambda \end{bmatrix}) = (3-\lambda)(2-\lambda) = 0$$</p><p>可得$\lambda = 3$或者$\lambda = 2$。求解特征值为3的特征向量时，将$\lambda = 3$代入，$\begin{bmatrix} 0&amp;1\\ 0&amp;-1\end{bmatrix} \begin{bmatrix}x \\ y \end{bmatrix} = \begin{bmatrix} 0 \\ 0\end{bmatrix}$,转换为线性方程组求解即可。</p><blockquote><p>特征值出现复数，一般对应变换中的某种旋转。</p></blockquote><h4 id="特征基"><a href="#特征基" class="headerlink" title="特征基"></a>特征基</h4><p>基向量正好是特征向量。$\begin{bmatrix}-1&amp;0 \\ 0 &amp;2 \end{bmatrix}$ ，$\hat i$和$\hat j$ 变换的倍数就是他们所属的特征值。除了对角以外，其他元素都为0的矩阵被称为对角矩阵，对他的解读方法就是所有的基向量都是特征向量，矩阵的对角元就是他们所属的特征值。</p><p>对角矩阵的特点是对角矩阵多次相乘只是进行特征值上的累乘。</p><p>对于非对角矩阵进行多次累乘，可以计算非对角矩阵的特征向量，然后进行坐标系的转换。</p><p>$$\begin{bmatrix} 1&amp; -1 \\ 0&amp; 1\end{bmatrix}^{-1} \begin{bmatrix} 3 &amp; 1 \\ 0&amp; 2\end{bmatrix} \begin{bmatrix} 1&amp; -1 \\ 0&amp; 1\end{bmatrix} = \begin{bmatrix} 3&amp; 0 \\ 0&amp; 2\end{bmatrix}$$ </p><p>转换成对角矩阵后再进行累乘，最后可以再次进行坐标系转换变换结果。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本部分主要讲解基变换、特征向量和特征值的内容。该部分对应的视频地址&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/av6731067/?p=13&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;基变换&lt;/a&gt;、&lt;a href=&quot;https://www.bilibili.com/video/av6731067/?p=14&amp;amp;spm_id_from=333.788.b_6d756c74695f70616765.14&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;特征向量与特征值&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>线性代数笔记(二)</title>
    <link href="https://yangsoon.github.io/2018/09/03/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-2/"/>
    <id>https://yangsoon.github.io/2018/09/03/线性代数-2/</id>
    <published>2018-09-03T07:45:44.000Z</published>
    <updated>2018-12-27T13:48:55.108Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本部分讲解 矩阵乘法与线性变换复合、行列式、逆矩阵、列空间、秩和零向量 非方阵。该部分对应视频地址</p><p><a href="https://www.bilibili.com/video/av6731067/?p=5" target="_blank" rel="noopener">矩阵乘法与线性变换复合</a>、<a href="https://www.bilibili.com/video/av6731067/?p=7" target="_blank" rel="noopener">行列式</a>、<a href="https://www.bilibili.com/video/av6731067/?p=8" target="_blank" rel="noopener">列空间、秩和零向量</a>、<a href="https://www.bilibili.com/video/av6731067/?p=9" target="_blank" rel="noopener">非方阵</a></p><a id="more"></a><h3 id="矩阵乘法与线性变换复合"><a href="#矩阵乘法与线性变换复合" class="headerlink" title="矩阵乘法与线性变换复合"></a>矩阵乘法与线性变换复合</h3><p>矩阵和向量相乘就是将线性变换作用于那个向量。</p><p>两个矩阵相乘有着几何意义，也就是两个线性变换相继作用。</p><p>下面举一个例子 两个矩阵相乘 $M_2 \times M_1 = \begin{bmatrix} 0 &amp; 2\\ 1 &amp; 0 \end{bmatrix} \begin{bmatrix} 1 &amp; -2\\ 1 &amp; 0 \end{bmatrix} = \begin{bmatrix} ? &amp; ? \\ ? &amp; ? \end{bmatrix} $</p><p>1 首先我们要算出 $\hat i$ 的去向，经过$M_1$矩阵的线性变换，$\hat i$ 转换为 $ \begin{bmatrix}  1\\ 1 \end{bmatrix} $</p><p>2 经过 $M_2$ 作用后 $M_2 \times \hat i = \begin{bmatrix} 0 &amp; 2 \\ 1 &amp; 0\end{bmatrix} \begin{bmatrix} 1 \\ 1\end{bmatrix} = \begin{bmatrix}2 \\  1\end{bmatrix} $ 为复合矩阵的第一列。</p><p>3 同理 $\hat j$ 经过变换 $M_2 \times \hat j = \begin{bmatrix} 0 &amp; 2 \\ 1 &amp; 0 \end{bmatrix} \begin{bmatrix} -2 \\ 0 \end{bmatrix} = \begin{bmatrix} 0 \\ -2 \end{bmatrix}​$ 为复合矩阵的第二列。</p><p>所以最终结果 $M_2 \times M_1 = \begin{bmatrix} 0 &amp; 2\\ 1 &amp; 0 \end{bmatrix} \begin{bmatrix} 1 &amp; -2\\ 1 &amp; 0 \end{bmatrix} = \begin{bmatrix} 2 &amp; 1\\ 0 &amp; 2 \end{bmatrix} $</p><p>根据这一思想，可以清楚的想到矩阵运算满足结合律。</p><h3 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h3><p>几何意义-空间被拉伸了多少</p><h3 id="逆矩阵、列空间、秩和零向量"><a href="#逆矩阵、列空间、秩和零向量" class="headerlink" title="逆矩阵、列空间、秩和零向量"></a>逆矩阵、列空间、秩和零向量</h3><h4 id="逆矩阵"><a href="#逆矩阵" class="headerlink" title="逆矩阵"></a>逆矩阵</h4><p>矩阵的用途可以帮助我们求解特定的方程组 下面的方程组为线性方程组</p><p>$$\begin{cases} 2x+5y+3z = -3 \\ 4x+0y+8z = 0 \\ 1x+3y+0z=2 \end{cases} \Rightarrow \begin{bmatrix} 2&amp;5&amp;3 \\ 4&amp;0&amp;8 \\ 1&amp;3&amp;0\end{bmatrix} \begin{bmatrix} x \\ y\\ z\end{bmatrix} =  \begin{bmatrix} -3 \\  0\\ 2\end{bmatrix} $$</p><p>上式可以简写为 $ A  \vec x = \vec v$ 该式简述了这个问题中优美的几何直观部分。矩阵$A$代表一种线性变换， 所以求解$ A  \vec x = \vec v$意味着我们寻找一个向量$x$使得他变换后和$\vec v$重合。这个方程的解依赖于矩阵$A$代表的变换，是将空间挤压到一条线或一个点的低等维度，还是保持像初始状态一样的完整二维空间。 根据行列式划分，可以分成行列式为0和行列式不为0，两种情况。</p><p>1 当$det(A) \neq 0$时，此时空间没有被挤压为零面积的区域，在这种情况，有且只有一个向量在变换后与$\vec v$重合。你可以通过逆向进行变换来找到这个向量。当你进行逆向变换时，他实际上对应了另一个线性变换。通常被称为$A$的逆，记为$A^{-1}$。总的来说，$A$逆是满足以下性质的唯一变换，首先应用$A$代表的变换，再应用$A$逆代表的变换，就会回到原始状态。找到$A^{-1}$之后，就可以在等式两边同时乘$A$的逆矩阵来求解向量方程。</p><p>$$ A^{-1}A \vec x = A^{-1} \vec v$$</p><p>而且 $det(A) \neq 0 \Rightarrow A^{-1} exist$</p><p>2 当$det(A) = 0$时，与这个方程组相关的线性变换将空间压缩到更低的维度，此时没有逆变换。但即便没有逆变换，也有可能存在解。假设线性变换成一条直线，而$\vec v$正好在直线上。</p><h4 id="秩"><a href="#秩" class="headerlink" title="秩"></a>秩</h4><p>当变换结果为一条直线时，也就是说结果是一维的，我们称这个变换的秩为1。如果变换后的向量落在某个二维空间上，我们称这个变换的秩为2。秩代表着变换后空间的维度。</p><h4 id="列空间"><a href="#列空间" class="headerlink" title="列空间"></a>列空间</h4><p>列空间就是矩阵的列张成的空间。零向量一定会被包含在列空间中。对一个非满秩矩阵来说，他将空间压缩到一个更低的维度，会有一系列向量在变换后成为零向量。变换后一些向量落在零向量上，而零向量正是这些向量所构成的空间。</p><h3 id="非方阵"><a href="#非方阵" class="headerlink" title="非方阵"></a>非方阵</h3><p>$\begin{bmatrix} 2 &amp; 0 \\ -1 &amp; 1 \\ -2&amp; 1\end{bmatrix}$ 该矩阵为一个$3 \times 2$的矩阵，表示三维空间中的一个二维平面，因为列空间的维数与输入空</p><p>间的维数相等，所以这个矩阵仍然满秩。(弹幕中解释矩阵有两列，而列空间的维数也是二，所以是满秩) 所以当你看到一个 $3 \times 2$ 的矩阵时，你就会明白他的意义就是将二维空间映射到三维空间上，矩阵有两列表白输入空间有两个基向量。有三行表示每个基向量在变换后都用三个独立的坐标来描述。</p><p>对于一个 $2 \times 3$ 的矩阵 $\begin{bmatrix} 3 &amp;1 &amp;4 \\ 1&amp; 5 &amp;9\end{bmatrix}$ 矩阵有三列表示原始空间由3个基向量，2行表示基向量使用2个坐标</p><p>描述。因此这是一个从三维空间到二维空间的映射。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本部分讲解 矩阵乘法与线性变换复合、行列式、逆矩阵、列空间、秩和零向量 非方阵。该部分对应视频地址&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/av6731067/?p=5&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;矩阵乘法与线性变换复合&lt;/a&gt;、&lt;a href=&quot;https://www.bilibili.com/video/av6731067/?p=7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;行列式&lt;/a&gt;、&lt;a href=&quot;https://www.bilibili.com/video/av6731067/?p=8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;列空间、秩和零向量&lt;/a&gt;、&lt;a href=&quot;https://www.bilibili.com/video/av6731067/?p=9&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;非方阵&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>线性代数笔记(一)</title>
    <link href="https://yangsoon.github.io/2018/07/16/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    <id>https://yangsoon.github.io/2018/07/16/线性代数/</id>
    <published>2018-07-16T02:29:55.000Z</published>
    <updated>2018-12-16T13:28:58.316Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在B站上发现了 <a href="https://www.bilibili.com/video/av6731067" target="_blank" rel="noopener">线性代数的本质</a> 这一系列合集，从几何的角度讲解了线性代数的本质，让我们更容易的理解线性代数。我决定尝试的用博客记录下来，作为以后的参考。</p><p>本部分主要讲解 矩阵与线性变换的知识</p><a id="more"></a><h3 id="向量究竟是什么"><a href="#向量究竟是什么" class="headerlink" title="向量究竟是什么"></a>向量究竟是什么</h3><p>这一部分对应视频 <a href="https://www.bilibili.com/video/av6731067/?p=2" target="_blank" rel="noopener">向量究竟是什么</a> 的内容。</p><blockquote><p>引入一些数作为坐标是一种鲁莽的行为。– 赫尔曼·外尔</p></blockquote><ol><li>物理学的角度：向量是空间中的箭头，决定向量的是它的长度和它所指的方向。</li><li>计算机的角度：向量是有序的数字列表。</li><li>数学的角度：向量可以是任何东西，只有保证两个向量相加以及数字和向量相乘有意义即可。</li></ol><h3 id="线性组合、张成的空间与基"><a href="#线性组合、张成的空间与基" class="headerlink" title="线性组合、张成的空间与基"></a>线性组合、张成的空间与基</h3><p><a href="https://www.bilibili.com/video/av6731067/?p=3" target="_blank" rel="noopener">线性组合、张成的空间与基</a></p><blockquote><p>数学需要的不是天赋，而是少量的自由想象，但想象太过自由又会陷入疯狂 – 安古斯·罗杰斯</p></blockquote><h4 id="线性组合"><a href="#线性组合" class="headerlink" title="线性组合"></a>线性组合</h4><p>两个数乘向量的和被称为这两个向量的线性组合。 $$a\vec v + b\vec w$$</p><p>所有可以表示为给定向量线性组合的向量的集合，被称为给定向量张成的空间(span)</p><p>$\vec v$ 和 $\vec w$ 全部线性组合构成的向量集合称为 张成的空间。</p><p>当你有多个向量，并且可以移除其中一个而不减小张成的空间，当这种情况发生时，我们称这些向量线性相关。其中一个向量可以表示为其他向量的线性组合  </p><p>$$\begin{cases} \vec w = a \vec v &amp; 二维空间 \\ \vec u = a\vec v + b\vec w &amp; 三维空间 \ \end{cases}$$</p><p>如果所有的向量都给张成的空间增添了新的维度，他们就被称为是线性无关的。</p><p>$$\begin{cases} \vec w \neq a \vec v &amp; 二维空间 \\ \vec u \neq a\vec v + b\vec w &amp; 三维空间 \ \end{cases}$$</p><p>向量空间的一组基是张成该空间的一个线性无关的向量集。</p><h3 id="矩阵与线性变换"><a href="#矩阵与线性变换" class="headerlink" title="矩阵与线性变换"></a>矩阵与线性变换</h3><p><a href="https://www.bilibili.com/video/av6731067/?p=4" target="_blank" rel="noopener">矩阵与线性变换</a></p><blockquote><p>很遗憾，矩阵是什么是说不清的。你必须得自己亲眼看看。– 墨菲斯</p></blockquote><h4 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h4><p>变换本质上是函数的一种花哨的说法。它接收输入内容，并输出对应结果。特别的在线性代数的情况下，我们考虑的是接收一个向量并且输出一个向量的变换。</p><p>如果一个变换具有以下特性，就说明是线性的:</p><ol><li>直线在变换后，仍然保持为直线，不能有所弯曲。</li><li>原点必须保持固定。</li></ol><p>如何用数值表示线性变换，只要记录坐标中的两个基向量 $\hat{i}$ 和 $\hat{j}$ 的变换，其他的向量都会随之变换。</p><p>先假设 基向量 $\hat{i}$ 和 $\hat{j}$ 变换后的坐标为</p><p>$$ \hat{i} \Rightarrow \begin{bmatrix} 1\\ -2 \end{bmatrix}, \hat{j} \Rightarrow \begin{bmatrix} 3 \\ 0 \end{bmatrix}$$</p><p>一般情况在原始 $\hat{i}$ 和 $\hat{j}$ 张成的向量空间中的某一向量表示为 $\begin{bmatrix} x\\ y \end{bmatrix}$,变换后的向量就是</p><p>$$\begin{bmatrix} x\\ y \end{bmatrix} \Rightarrow x \begin{bmatrix} 1\\ -2 \end{bmatrix} + y \begin{bmatrix} 3 \\ 0 \end{bmatrix} = \begin{bmatrix} x + 3y\\ -2x +0y \end{bmatrix}$$</p><p>一个二维线性变换仅由4个数字完全确定，变换后的的 $\hat{i}$ 的坐标和 $\hat{j}$ 的坐标。我们将这些坐标包装在一个 $2 \times 2$ 的格子里，称它为 $2 \times 2$ 矩阵。$\begin{bmatrix} 1 &amp; 3\\ -2 &amp; 0\end{bmatrix}$ ,可以把他的列理解为特殊向量变换后的 $\hat{i}$和$\hat{j}$</p><p>如果你有一个描述线性变换的 $2 \times 2$ 的矩阵和一个给定的向量，你想了解线性变换对这个向量的作用，你只需要取出向量的坐标，将他们分别与矩阵对应的列相乘，然后将结果相加即可。可以将此运算定义为矩阵向量乘法。</p><p>$$\begin{bmatrix} a &amp; b\\ c &amp; d \end{bmatrix} \begin{bmatrix} x\\ y \end{bmatrix} = x \begin{bmatrix} a\\ c \end{bmatrix} + y \begin{bmatrix} b \\ d \end{bmatrix} = \begin{bmatrix} ax + by \\ cx+dy \end{bmatrix}$$</p><p>矩阵放在向量的左边，类似一个函数。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在B站上发现了 &lt;a href=&quot;https://www.bilibili.com/video/av6731067&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;线性代数的本质&lt;/a&gt; 这一系列合集，从几何的角度讲解了线性代数的本质，让我们更容易的理解线性代数。我决定尝试的用博客记录下来，作为以后的参考。&lt;/p&gt;
&lt;p&gt;本部分主要讲解 矩阵与线性变换的知识&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>基于aiotg创建一个telegram爬虫机器人</title>
    <link href="https://yangsoon.github.io/2018/04/14/%E7%94%A8aiotg%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAtelegram%E7%88%AC%E8%99%AB%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    <id>https://yangsoon.github.io/2018/04/14/用aiotg开发一个telegram爬虫机器人/</id>
    <published>2018-04-14T05:41:01.000Z</published>
    <updated>2018-12-15T11:53:14.295Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="http://stepan.xyz/aiotg/index.html" target="_blank" rel="noopener">aiotg</a> 可以通过异步调用telegram api的方式来构建bot，因为决定开发一个爬虫功能的bot，所以网络请求阻塞是比较严重的性能障碍。而asyncio的异步非阻塞特性能够完美的解决这一问题。这篇文章在记录如何使用aiotg进行telegram开发的同时，也会说明一些aiohttp的使用方法,这里是<a href="https://github.com/yangsoon/funny-bot" target="_blank" rel="noopener">项目源码</a>。</p><p><a href="https://t.me/fpicturebot" target="_blank" rel="noopener">https://t.me/fpicturebot</a> 点击链接可以体验一下这个bot的功能。</p><div class="tip"><br>如果读者之前对telegram的bot没有了解，可以查看这篇<a href="/2017/11/21/telegram-bots-for-developers/">写给开发者的telegram-bots介绍文档</a><br></div><br><a id="more"></a><br><br>## aiotg简单教程<br><br>#### 1.一个最简单的bot<br><br><div class="tip"><br>你可以先学习如何<a href="/2017/11/21/telegram-bots-for-developers/#newbot">新建</a>一个机器人<br></div><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> aiotg <span class="keyword">import</span> Bot, Chat</div><div class="line"></div><div class="line">config = &#123;</div><div class="line">    <span class="string">"api_token"</span>: <span class="string">"***********"</span>,</div><div class="line">    <span class="string">"proxy"</span>: <span class="string">"http://127.0.0.1:8118"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">bot = Bot(**config)</div><div class="line"></div><div class="line"><span class="meta">@bot.command(r"/echo (.+)")</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo</span><span class="params">(chat: Chat, match)</span>:</span></div><div class="line">    <span class="keyword">return</span> chat.reply(match.group(<span class="number">1</span>))</div><div class="line"></div><div class="line">bot.run()</div></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006r0i4lgy1fqi7geixaqj31og1aowpx.jpg" alt="运行结果"></p><p>上面是一个简单的回复机器人，当你使用指令 <code>/echo</code>+内容时，机器人会自动回复给你发送的内容。这里要注意一点，在我这里没有采用使用  <code>pipenv</code>  ( <code>pip</code> ) 安装aiotg的方法，因为pip平台上安装的是master分支的包，aiotg通过使用aiohttp来调用telegram bot api，在创建一个bot的时候没有提供<code>proxy</code>选项为aiohttp设置代理，在本地开发的时候会因为国内网络抽搐出现网络连接错误，所以在这里我使用了aiotg的proxy分支，直接从github上下载的代码。在创建Bot对象的时候加入proxy选项就能使用本地代理来进行开发调试了。</p><div class="tip"><br>后来我在aiotg telegram群里建议作者将proxy合并到主分支，后来作者表示他也有这样的想法，同时他也吐槽了一下俄罗斯的网络也有很多审查和限制，现在在aiotg里已经没有proxy分支了，在aiotg-0.9.9版本中提供proxy选项，所以大家可以继续使用pipenv下载aiotg包。<br></div><h4 id="2-aiotg异步特性"><a href="#2-aiotg异步特性" class="headerlink" title="2.aiotg异步特性"></a>2.aiotg异步特性</h4><p>既然用到aiotg来开发就是看中了他的异步特性，下面就列出一个简单的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> aiohttp</div><div class="line"><span class="keyword">import</span> json</div><div class="line"><span class="keyword">from</span> aiotg <span class="keyword">import</span> Bot, Chat</div><div class="line"></div><div class="line"><span class="keyword">with</span> open(<span class="string">'token.conf'</span>) <span class="keyword">as</span> f:</div><div class="line">    token = json.loads(f.read())</div><div class="line"></div><div class="line">bot = Bot(**token)</div><div class="line"></div><div class="line"><span class="meta">@bot.command("/fetch")</span></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">async_fecth</span><span class="params">(chat: Chat, match)</span>:</span></div><div class="line">    url = <span class="string">"http://www.gamersky.com/ent/111/"</span></div><div class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> sesssion:</div><div class="line">        <span class="keyword">async</span> <span class="keyword">with</span> sesssion.get(url) <span class="keyword">as</span> resp:</div><div class="line">            info = <span class="string">' version: &#123;&#125;\n status :&#123;&#125;\n method: &#123;&#125;\n url: &#123;&#125;\n'</span>.format(</div><div class="line">                resp.version, resp.status, resp.method, resp.url)</div><div class="line">            <span class="keyword">await</span> chat.send_text(info)</div><div class="line"></div><div class="line">bot.run(debug=<span class="keyword">True</span>)</div></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006r0i4lgy1fqi8fxvvdjj31og1aona6.jpg" alt="运行结果"></p><h4 id="3-自定义键盘"><a href="#3-自定义键盘" class="headerlink" title="3. 自定义键盘"></a><a id="keyboards" style="color: black">3. 自定义键盘</a></h4><p>关于<a href="https://core.telegram.org/bots#keyboards" target="_blank" rel="noopener">自定义键盘</a>的内容可以点击链接查看官方解释，<a href="/2017/11/21/telegram-bots-for-developers/#keyboards">这里</a>是简单的中文描述。</p><p><code>category.json</code><br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">    &#123;</div><div class="line">        <span class="attr">"name"</span>: <span class="string">"dynamic"</span>,</div><div class="line">        <span class="attr">"title"</span>: <span class="string">"动态图"</span>,</div><div class="line">        <span class="attr">"url"</span>: <span class="string">"http://www.gamersky.com/ent/111/"</span></div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        <span class="attr">"name"</span>: <span class="string">"oops"</span>,</div><div class="line">        <span class="attr">"title"</span>: <span class="string">"囧图"</span>,</div><div class="line">        <span class="attr">"url"</span>: <span class="string">"http://www.gamersky.com/ent/147/"</span></div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        <span class="attr">"name"</span>: <span class="string">"beauty"</span>,</div><div class="line">        <span class="attr">"title"</span>: <span class="string">"福利图"</span>,</div><div class="line">        <span class="attr">"url"</span>: <span class="string">"http://tag.gamersky.com/news/66.html"</span></div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        <span class="attr">"name"</span>: <span class="string">"easy-moment"</span>,</div><div class="line">        <span class="attr">"title"</span>: <span class="string">"轻松一刻"</span>,</div><div class="line">        <span class="attr">"url"</span>: <span class="string">"http://www.gamersky.com/ent/20503/"</span></div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        <span class="attr">"name"</span>: <span class="string">"trivia"</span>,</div><div class="line">        <span class="attr">"title"</span>: <span class="string">"冷知识"</span>,</div><div class="line">        <span class="attr">"url"</span>: <span class="string">"http://www.gamersky.com/ent/198/"</span></div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        <span class="attr">"name"</span>: <span class="string">"cold-tucao"</span>,</div><div class="line">        <span class="attr">"title"</span>: <span class="string">"冷吐槽"</span>,</div><div class="line">        <span class="attr">"url"</span>: <span class="string">"http://www.gamersky.com/ent/20108/"</span></div><div class="line">    &#125;</div><div class="line">]</div></pre></td></tr></table></figure></p><p><code>main.py</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> aiohttp</div><div class="line"><span class="keyword">import</span> json</div><div class="line"><span class="keyword">from</span> aiotg <span class="keyword">import</span> Bot, Chat</div><div class="line"></div><div class="line"><span class="keyword">with</span> open(<span class="string">'token.json'</span>) <span class="keyword">as</span> t, open(<span class="string">'category.json'</span>) <span class="keyword">as</span> c:</div><div class="line">    token = json.loads(t.read())</div><div class="line">    category = json.loads(c.read())</div><div class="line"></div><div class="line">bot = Bot(**token)</div><div class="line"></div><div class="line"><span class="meta">@bot.command("/reply")</span></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">resply</span><span class="params">(chat: Chat, match)</span>:</span></div><div class="line">    kb = [[item[<span class="string">'title'</span>]] <span class="keyword">for</span> item <span class="keyword">in</span> category]</div><div class="line">    keyboard = &#123;</div><div class="line">        <span class="string">"keyboard"</span>: kb,</div><div class="line">        <span class="string">"resize_keyboard"</span>: <span class="keyword">True</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">await</span> chat.send_text(text=<span class="string">"看看你的键盘"</span>, reply_markup=json.dumps(keyboard))</div><div class="line"></div><div class="line">bot.run(debug=<span class="keyword">True</span>)</div></pre></td></tr></table></figure></p><p><img src="http://ww1.sinaimg.cn/large/006r0i4lgy1fqnftc74voj31og1aoqh4.jpg" alt=""></p><p>只需要在调用chat的发送消息函数中，指定 <code>reply_markup</code> 参数，你就能个性化的设定用户键盘， <code>reply_markup</code> 参数需要一个json对象，官方指定为<a href="https://core.telegram.org/bots/api#replykeyboardmarkup" target="_blank" rel="noopener">ReplyKeyboardMarkup</a>类型，其中<code>keyboard</code>需要传递一个<a href="https://core.telegram.org/bots/api#keyboardbutton" target="_blank" rel="noopener">KeyboardButton</a>的数组。</p><p>每个keyboard的成员代表着键盘中的行，你可以通过修改每行中KeyboardButton的个数来排列你的键盘，比如我们让键盘每行显示两个KeyboardButton，如下所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@bot.command("/reply")</span></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">reply</span><span class="params">(chat: Chat, match)</span>:</span></div><div class="line">    <span class="comment"># kb = [[item['title']] for item in category]</span></div><div class="line">    kb, row = [], <span class="number">-1</span></div><div class="line">    <span class="keyword">for</span> idx, item <span class="keyword">in</span> enumerate(category):</div><div class="line">        <span class="keyword">if</span> idx % <span class="number">2</span> == <span class="number">0</span>:</div><div class="line">            kb.append([])</div><div class="line">            row += <span class="number">1</span></div><div class="line">        kb[row].append(item[<span class="string">'title'</span>])</div><div class="line">    keyboard = &#123;</div><div class="line">        <span class="string">"keyboard"</span>: kb,</div><div class="line">        <span class="string">"resize_keyboard"</span>: <span class="keyword">True</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">await</span> chat.send_text(text=<span class="string">"看看你的键盘"</span>, reply_markup=json.dumps(keyboard))</div></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006r0i4lgy1fqng7pn535j31og1aok5k.jpg" alt=""></p><h4 id="4-内联键盘和消息更新"><a href="#4-内联键盘和消息更新" class="headerlink" title="4. 内联键盘和消息更新"></a><a id="inlinekeyboards" style="color: black">4. 内联键盘和消息更新</a></h4><p><a href="/2017/11/21/telegram-bots-for-developers/#inlinekeyboards">内联键盘</a>的意思就是附着在消息上的键盘，内联键盘由内联按钮组成，每个按钮会附带一个回调数据，每次点击按钮之后会有对应的回调函数处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@bot.command("/inline")</span></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">inlinekeyboard</span><span class="params">(chat: Chat, match)</span>:</span></div><div class="line"></div><div class="line">    inlinekeyboardmarkup = &#123;</div><div class="line">            <span class="string">'type'</span>: <span class="string">'InlineKeyboardMarkup'</span>,</div><div class="line">            <span class="string">'inline_keyboard'</span>: [</div><div class="line">                [&#123;<span class="string">'type'</span>: <span class="string">'InlineKeyboardButton'</span>,</div><div class="line">                  <span class="string">'text'</span>: <span class="string">'上一页'</span>,</div><div class="line">                  <span class="string">'callback_data'</span>: <span class="string">'page-pre'</span>&#125;,</div><div class="line">                 &#123;<span class="string">'type'</span>: <span class="string">'InlineKeyboardButton'</span>,</div><div class="line">                  <span class="string">'text'</span>: <span class="string">'下一页'</span>,</div><div class="line">                  <span class="string">'callback_data'</span>: <span class="string">'page-next'</span>&#125;]</div><div class="line">                ]</div><div class="line">            &#125;</div><div class="line"></div><div class="line">    <span class="keyword">await</span> chat.send_text(<span class="string">'请翻页'</span>, reply_markup=json.dumps(inlinekeyboardmarkup))</div><div class="line"></div><div class="line"><span class="meta">@bot.callback(r'page-(\w+)')</span></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">buttonclick</span><span class="params">(chat, cq, match)</span>:</span></div><div class="line">    <span class="keyword">await</span> chat.send_text(<span class="string">'You clicked &#123;&#125;'</span>.format(match.group(<span class="number">1</span>)))</div></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006r0i4lgy1fr5jc7vs09j31se1dwk79.jpg" alt=""></p><p>有时候我们想修改之前已经发送过的消息内容，例如当用户点击了内联键盘，而键盘的功能是进行翻页更新消息的内容。这时候我们可以使用 <code>editMessageText</code> 功能。例如点击上面内联键盘中的上一页按钮，你可以看到消息的内容被更改了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@bot.callback(r'page-(\w+)')</span></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">buttonclick</span><span class="params">(chat, cq, match)</span>:</span></div><div class="line">    <span class="keyword">await</span> chat.edit_text(message_id=chat.message[<span class="string">'message_id'</span>], text=<span class="string">"消息被修改了"</span>)</div></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006r0i4lgy1fr69270omhj31se1dwh0s.jpg" alt=""></p><h4 id="5-内联请求模式"><a href="#5-内联请求模式" class="headerlink" title="5.内联请求模式"></a><a id="inlinemode" style="color: black">5.内联请求模式</a></h4><p><a href="/2017/11/21/telegram-bots-for-developers/#inlinemode">内联请求模式</a>感觉更适合在群组中使用，在讨论组中输入<code>@botname</code> + 特定指令，输入框的上方就会显示查询内容，你可以返回给用户文章类型、图片类型或者其他类型的查询信息。<a href="https://core.telegram.org/bots/api#inline-mode" target="_blank" rel="noopener">官网</a>有更详细的内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@bot.inline</span></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">inlinemode</span><span class="params">(iq)</span>:</span></div><div class="line">    results = [&#123;</div><div class="line">            <span class="string">'type'</span>: <span class="string">'article'</span>,</div><div class="line">            <span class="string">'id'</span>: str(index),</div><div class="line">            <span class="string">'title'</span>: article[<span class="string">'title'</span>],</div><div class="line">            <span class="string">'input_message_content'</span>: &#123; <span class="string">'message_text'</span>: article[<span class="string">'title'</span>]&#125;,</div><div class="line">            <span class="string">'description'</span>: <span class="string">f"这里是<span class="subst">&#123;article[<span class="string">'title'</span>]&#125;</span>"</span></div><div class="line">        &#125; <span class="keyword">for</span> index, article <span class="keyword">in</span> enumerate(category)]</div><div class="line">    <span class="keyword">await</span> iq.answer(results)</div></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006r0i4lgy1fr7au03whbj30jz0zkabu.jpg" style="width: 350px; height: 630px"></p><p>我们设定当用户输入内联指令时，bot返回可以选择的图片种类，返回结果的类型是article类型，官方还提供了语音，图片，gif，视频，音频。表情等类型，你可以根据自己的需要进行选择。</p><h2 id="爬虫机器人功能实现"><a href="#爬虫机器人功能实现" class="headerlink" title="爬虫机器人功能实现"></a>爬虫机器人功能实现</h2><p>我使用aiotg编写的机器人是用来抓取来自<a href="http://www.gamersky.com/" target="_blank" rel="noopener">游民星空</a>的图片。</p><h4 id="1-爬虫功能"><a href="#1-爬虫功能" class="headerlink" title="1. 爬虫功能"></a>1. 爬虫功能</h4><p>爬虫功能的实现是用aiohttp发送web请求，使用beautifulsoup进行html解析，核心代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line"><span class="keyword">import</span> aiohttp</div><div class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">aioget</span><span class="params">(url)</span>:</span></div><div class="line">    <span class="keyword">return</span> aiohttp.request(<span class="string">'GET'</span>, url)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter_img</span><span class="params">(tag)</span>:</span></div><div class="line">    <span class="keyword">if</span> tag.name != <span class="string">'p'</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        <span class="keyword">if</span> tag.attrs[<span class="string">'align'</span>] == <span class="string">'center'</span>:</div><div class="line">            <span class="keyword">for</span> child <span class="keyword">in</span> tag.contents:</div><div class="line">                <span class="keyword">if</span> child.name == <span class="string">'img'</span> <span class="keyword">or</span> child.name == <span class="string">'a'</span>:</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">    <span class="keyword">except</span> KeyError:</div><div class="line">        <span class="keyword">if</span> <span class="string">'style'</span> <span class="keyword">in</span> tag.attrs:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">            </div><div class="line">            </div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">fetch_img</span><span class="params">(url)</span>:</span></div><div class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aioget(url) <span class="keyword">as</span> resp:</div><div class="line">        resp_text = <span class="keyword">await</span> resp.text()</div><div class="line">        content = BeautifulSoup(resp_text, <span class="string">"lxml"</span>)</div><div class="line">        imgs = content.find(class_=<span class="string">"Mid2L_con"</span>).findAll(filter_img)</div><div class="line">        results = []</div><div class="line">        <span class="keyword">for</span> img <span class="keyword">in</span> imgs:</div><div class="line">            <span class="keyword">try</span>:</div><div class="line">                results.append(&#123;</div><div class="line">                    <span class="string">'src'</span>:  img.find(<span class="string">'img'</span>).attrs[<span class="string">'src'</span>],</div><div class="line">                    <span class="string">'desc'</span>: <span class="string">'\n'</span>.join(list(img.stripped_strings))</div><div class="line">                &#125;)</div><div class="line">            <span class="keyword">except</span> AttributeError:</div><div class="line">                <span class="keyword">continue</span></div><div class="line">        <span class="keyword">return</span> results</div></pre></td></tr></table></figure><p>我将aiohttp的get请求稍微包装了一下，简洁一些。html中元素的提取就不在赘述，就是找找html中的规律</p><h4 id="2-指令功能"><a href="#2-指令功能" class="headerlink" title="2. 指令功能"></a>2. 指令功能</h4><p>指令功能实现需要使用aiotg.bot.command装饰器进行命令注册，下面列出 <code>/start</code>的功能实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@bot.command(r"/start")</span></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">list_category</span><span class="params">(chat: Chat, match)</span>:</span></div><div class="line">    kb, row = [], <span class="number">-1</span></div><div class="line">    <span class="keyword">for</span> idx, item <span class="keyword">in</span> enumerate(category[<span class="string">"name"</span>]):</div><div class="line">        <span class="keyword">if</span> idx % <span class="number">2</span> == <span class="number">0</span>:</div><div class="line">            kb.append([])</div><div class="line">            row += <span class="number">1</span></div><div class="line">        kb[row].append(item)</div><div class="line">    keyboard = &#123;</div><div class="line">        <span class="string">"keyboard"</span>: kb,</div><div class="line">        <span class="string">"resize_keyboard"</span>: <span class="keyword">True</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">await</span> chat.send_text(text=<span class="string">"请选择你喜欢的图片类型"</span>, reply_markup=json.dumps(keyboard))</div></pre></td></tr></table></figure><p>关于自定义键盘部分在上文中已经讲过，读者可以自己编码实现</p><h4 id="3-callback功能"><a href="#3-callback功能" class="headerlink" title="3. callback功能"></a>3. callback功能</h4><p><img src="http://ww1.sinaimg.cn/large/006r0i4lgy1frff8guj7cj31se1dwnlk.jpg" alt=""></p><p>读者可以看到在消息上附有页面切换按钮，每个按钮会带着一个callbackdata，当点击按钮会调用相应的callback函数进行处理，这里点击下一页时会进行翻页。</p><p><img src="http://ww1.sinaimg.cn/large/006r0i4lgy1frffbgtx1qj31se1dw7so.jpg" alt=""></p><p>看页面更新了，关于更新页面的实现在上面也讲到了如何进行消息更新。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@bot.callback(r"page-(?P&lt;name&gt;\w+)-(?P&lt;page&gt;\d+)")</span></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">change_lists</span><span class="params">(chat: Chat, cq, match)</span>:</span></div><div class="line">    req_name = match.group(<span class="string">'name'</span>)</div><div class="line">    page = match.group(<span class="string">'page'</span>)</div><div class="line">    url = category[req_name]</div><div class="line">    text, markup = <span class="keyword">await</span> format_message(req_name, url, page)</div><div class="line">    <span class="keyword">await</span> chat.edit_text(message_id=chat.message[<span class="string">'message_id'</span>], text=text, markup=markup)</div></pre></td></tr></table></figure><p>也是使用装饰器进行回调函数注册，使用<code>chat.edit_text</code>进行消息更新。</p><p>callback功能也用在了图片的更新。点击下一页更新图片。</p><p><img src="http://ww1.sinaimg.cn/large/006r0i4lgy1frffhu9b97j31se1dw7wh.jpg" alt=""></p><h4 id="4-内联请求模式功能"><a href="#4-内联请求模式功能" class="headerlink" title="4.内联请求模式功能"></a>4.内联请求模式功能</h4><p>当用户在输入框中输入<code>@botusername+指令</code>时，会在输入框上显示查询内容。</p><p><img src="http://ww1.sinaimg.cn/large/006r0i4lgy1frffjspbwzj31se1dw4qp.jpg" alt=""></p><p>当没有指令时，会显示一些能够查看的图片类型。</p><p><img src="http://ww1.sinaimg.cn/large/006r0i4lgy1frffjjn3cfj31se1dw4qp.jpg" alt=""></p><p>当输入对应类型汉字的前几个字时，bot会匹配你想看的图片列表，并罗列出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@bot.inline(r"([\u4e00-\u9fa5]+)")</span></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">inline_name</span><span class="params">(iq, match)</span>:</span></div><div class="line">    req = match.group(<span class="number">1</span>)</div><div class="line">    req_name = match_category(req.strip(), category[<span class="string">'name'</span>])</div><div class="line">    ptype = <span class="string">'G'</span> <span class="keyword">if</span> req_name == <span class="string">"dynamic"</span> <span class="keyword">else</span> <span class="string">'P'</span></div><div class="line">    <span class="keyword">if</span> req_name <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">        <span class="keyword">return</span></div><div class="line">    results, _ = <span class="keyword">await</span> fetch_lists(category[req_name])</div><div class="line">    c_results = [&#123;</div><div class="line">            <span class="string">'type'</span>: <span class="string">'article'</span>,</div><div class="line">            <span class="string">'id'</span>: str(index),</div><div class="line">            <span class="string">'title'</span>: item[<span class="string">'title'</span>],</div><div class="line">            <span class="string">'input_message_content'</span>: &#123;</div><div class="line">                <span class="string">'message_text'</span>: <span class="string">'/'</span> + ptype + item[<span class="string">'date'</span>] + <span class="string">'_'</span> + item[<span class="string">'key'</span>]</div><div class="line">            &#125;,</div><div class="line">            <span class="string">'description'</span>: item[<span class="string">'desc'</span>]</div><div class="line">        &#125; <span class="keyword">for</span> index, item <span class="keyword">in</span> enumerate(results)]</div><div class="line">    <span class="keyword">await</span> iq.answer(c_results)</div></pre></td></tr></table></figure><h4 id="redis缓存"><a href="#redis缓存" class="headerlink" title="redis缓存"></a>redis缓存</h4><p>当发送给用户图片时，telegram会返回一个和图片对应的file_id, 当再次发送相同的图片时，只需要在调用send_photo时，将photo参数赋值为file_id即可，所以每次使用爬虫进行抓取图片时，将图片的fild_id存在redis中，用户请求图片时，如果图片之前已经抓取过，这时候只要从redis中取出file_id，再调用send_photo即可。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>之前一直说要保证每周都要写文章，可是发现自己的毕设是一个大坑，连续的写了一个多月，github上的commit都绿了一片，但是不能光把精力都放在毕设上，还是要抽空学学别的东西，比如，英语是吧，唉。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://stepan.xyz/aiotg/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;aiotg&lt;/a&gt; 可以通过异步调用telegram api的方式来构建bot，因为决定开发一个爬虫功能的bot，所以网络请求阻塞是比较严重的性能障碍。而asyncio的异步非阻塞特性能够完美的解决这一问题。这篇文章在记录如何使用aiotg进行telegram开发的同时，也会说明一些aiohttp的使用方法,这里是&lt;a href=&quot;https://github.com/yangsoon/funny-bot&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;项目源码&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://t.me/fpicturebot&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://t.me/fpicturebot&lt;/a&gt; 点击链接可以体验一下这个bot的功能。&lt;/p&gt;
&lt;div class=&quot;tip&quot;&gt;&lt;br&gt;如果读者之前对telegram的bot没有了解，可以查看这篇&lt;a href=&quot;/2017/11/21/telegram-bots-for-developers/&quot;&gt;写给开发者的telegram-bots介绍文档&lt;/a&gt;&lt;br&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Python Tricks</title>
    <link href="https://yangsoon.github.io/2018/04/07/Python-Tricks/"/>
    <id>https://yangsoon.github.io/2018/04/07/Python-Tricks/</id>
    <published>2018-04-07T14:33:30.000Z</published>
    <updated>2019-03-04T13:09:02.511Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>发现了<a href="https://github.com/brennerm/PyTricks" target="_blank" rel="noopener">PyTricks</a>这个仓库，教你写出更优雅的python代码。不定期更新</p><a id="more"></a><h2 id="元组和字典的解包"><a href="#元组和字典的解包" class="headerlink" title="元组和字典的解包"></a>元组和字典的解包</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">produce</span><span class="params">(a, b)</span>:</span></div><div class="line">    print(a*b)</div><div class="line">argument1 = (<span class="number">1</span>, <span class="number">2</span>)</div><div class="line">argument2 =&#123;<span class="string">'a'</span>:<span class="number">1</span>, <span class="string">'b'</span>:<span class="number">2</span>&#125;</div><div class="line"></div><div class="line">produce(*argument1)</div><div class="line">produce(**argument2)</div></pre></td></tr></table></figure><h2 id="不使用if-else实现一个计算器"><a href="#不使用if-else实现一个计算器" class="headerlink" title="不使用if else实现一个计算器"></a>不使用if else实现一个计算器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> operator</div><div class="line"></div><div class="line">ops = &#123;</div><div class="line">    <span class="string">'+'</span>: operator.add,</div><div class="line">    <span class="string">'-'</span>: operator.sub,</div><div class="line">    <span class="string">'*'</span>: operator.mul,</div><div class="line">    <span class="string">'/'</span>: operator.truediv</div><div class="line">&#125;</div><div class="line"></div><div class="line">x = input(<span class="string">"Enter an operator [OPTIONS: +, -, *, /]: "</span>)</div><div class="line">y = int(input(<span class="string">"x:"</span>))</div><div class="line">z = int(input(<span class="string">"y:"</span>))</div><div class="line"></div><div class="line">print(ops[x](y,z))</div></pre></td></tr></table></figure><h2 id="使用运算符进行链式比较"><a href="#使用运算符进行链式比较" class="headerlink" title="使用运算符进行链式比较"></a>使用运算符进行链式比较</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = <span class="number">10</span></div><div class="line">print(<span class="number">1</span> &lt; a &lt; <span class="number">50</span>)</div><div class="line">print(<span class="number">10</span> == a &lt; <span class="number">20</span>)</div></pre></td></tr></table></figure><h2 id="优雅的更新字典"><a href="#优雅的更新字典" class="headerlink" title="优雅的更新字典"></a>优雅的更新字典</h2><p>当我们想再字典里更新值时 会先判断字典里是否存在key，但使用<code>dict.setdefault</code>, <code>dict.get</code> 和 <code>collections.defaultdict</code> 会使代码简洁干净</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">d = &#123;&#125;</div><div class="line">d.setdefault(<span class="string">'a'</span>, []).append(<span class="number">1</span>)</div><div class="line"><span class="comment"># 当字典中不存在key时 返回默认值 0</span></div><div class="line">d[<span class="string">'b'</span>] = d.get(<span class="string">'b'</span>, <span class="number">0</span>) + <span class="number">1</span></div><div class="line">print(d)</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</div><div class="line">d = defaultdict(list)</div><div class="line">d[<span class="string">'a'</span>].append(<span class="number">1</span>)</div><div class="line">print(d)</div></pre></td></tr></table></figure><h2 id="使用内置的sorted-函数和key参数对字典的值进行排序"><a href="#使用内置的sorted-函数和key参数对字典的值进行排序" class="headerlink" title="使用内置的sorted()函数和key参数对字典的值进行排序"></a>使用内置的sorted()函数和key参数对字典的值进行排序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">d = &#123;<span class="string">'apple'</span>: <span class="number">10</span>, <span class="string">'orange'</span>: <span class="number">20</span>, <span class="string">'banana'</span>: <span class="number">5</span>, <span class="string">'rotten tomato'</span>: <span class="number">1</span>&#125;</div><div class="line">print(sorted(d.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>]))</div><div class="line">print(sorted(d, key=d.get))</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</div><div class="line">print(sorted(d.items(), key=itemgetter(<span class="number">1</span>)))</div></pre></td></tr></table></figure><h2 id="交换字典里的键和值"><a href="#交换字典里的键和值" class="headerlink" title="交换字典里的键和值"></a>交换字典里的键和值</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">_dict = &#123;<span class="string">"one"</span>: <span class="number">1</span>, <span class="string">"two"</span>: <span class="number">2</span>&#125;</div><div class="line">reversed_dict = &#123;v: k <span class="keyword">for</span> k, v <span class="keyword">in</span> _dict.items()&#125;</div><div class="line">print(reversed_dict)</div></pre></td></tr></table></figure><h2 id="缓存特性-cacheproperty"><a href="#缓存特性-cacheproperty" class="headerlink" title="缓存特性(cacheproperty)"></a>缓存特性(cacheproperty)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PropertyCache</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="string">""" a decorator to cache property</span></div><div class="line"><span class="string">    """</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></div><div class="line">        self.func = func</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, obj, cls)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> obj:</div><div class="line">            <span class="keyword">return</span> self</div><div class="line">        value = self.func(obj)</div><div class="line">        setattr(obj, self.func.__name__, value)</div><div class="line">        <span class="keyword">return</span> value</div><div class="line">        </div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self._property_to_be_cached = <span class="string">'result'</span></div><div class="line"></div><div class="line"><span class="meta">    @PropertyCache</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">property_to_be_cached</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'compute'</span>)</div><div class="line">        <span class="keyword">return</span> self._property_to_be_cached</div><div class="line">    </div><div class="line">test = Foo()</div><div class="line"></div><div class="line">print(test.property_to_be_cached)</div><div class="line">print(test.property_to_be_cached)</div></pre></td></tr></table></figure><p>输出结果<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">compute</div><div class="line">result</div><div class="line">result</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;发现了&lt;a href=&quot;https://github.com/brennerm/PyTricks&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PyTricks&lt;/a&gt;这个仓库，教你写出更优雅的python代码。不定期更新&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>apollo主题下使用gitment</title>
    <link href="https://yangsoon.github.io/2018/03/17/apollo%E4%B8%BB%E9%A2%98%E4%B8%8B%E4%BD%BF%E7%94%A8gitment/"/>
    <id>https://yangsoon.github.io/2018/03/17/apollo主题下使用gitment/</id>
    <published>2018-03-17T11:55:18.000Z</published>
    <updated>2018-03-20T10:21:58.812Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前一直没在blog下添加评论系统，多说貌似不干了，偶然间发现了<a href="https://github.com/imsun/gitment" target="_blank" rel="noopener">gitment</a>，它是一款基于GitHub Issues 的评论系统，同时有完整的 Markdown / GFM 和代码高亮支持。感觉不错，就添加到blog下了。</p><a id="more"></a><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="1-注册-OAuth-Application"><a href="#1-注册-OAuth-Application" class="headerlink" title="1. 注册 OAuth Application"></a>1. 注册 OAuth Application</h4><p><a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">点击此处</a> 来注册一个新的 OAuth Application。其他内容可以随意填写，但要确保填入正确的 callback URL(一般是评论页面对应的域名) 你会得到一个 client ID 和一个 client secret，这个将被用于之后的用户登录。</p><h4 id="2-引入Gitment"><a href="#2-引入Gitment" class="headerlink" title="2. 引入Gitment"></a>2. 引入Gitment</h4><p>因为使用的是apollo主题，所以我们先配置 <code>_config.yml</code> 文件。只需要添加几行代码就行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># Comment</div><div class="line"># e.g disqus: seansun</div><div class="line">disqus:</div><div class="line">duoshuo:</div><div class="line">gitment:</div><div class="line">    enable: true</div><div class="line">    owner: yangsoon</div><div class="line">    repo: yangsoon.github.io</div><div class="line">    client_id: ************</div><div class="line">    client_secret: ************</div></pre></td></tr></table></figure><p>下面我们修改 <code>/themes/apollo/layout/partial</code> 目录下的 <code>comment.jade</code> 文件, 在末尾加入就行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> theme.gitment.enable</div><div class="line">    - <span class="keyword">var</span> date = page.date</div><div class="line">    #container</div><div class="line">    link(rel=<span class="string">'stylesheet'</span>, href=<span class="string">'https://imsun.github.io/gitment/style/default.css'</span>)</div><div class="line">    script(src=<span class="string">'https://imsun.github.io/gitment/dist/gitment.browser.js'</span>)</div><div class="line">    script.</div><div class="line">        <span class="keyword">var</span> gitment = <span class="keyword">new</span> Gitment(&#123;</div><div class="line">            id: <span class="string">'#&#123;date&#125;'</span>,</div><div class="line">            owner: <span class="string">'#&#123;theme.gitment.owner&#125;'</span>,</div><div class="line">            repo: <span class="string">'#&#123;theme.gitment.repo&#125;'</span>,</div><div class="line">            oauth: &#123;</div><div class="line">                client_id: <span class="string">'#&#123;theme.gitment.client_id&#125;'</span>,</div><div class="line">                client_secret: <span class="string">'#&#123;theme.gitment.client_secret&#125;'</span>,</div><div class="line">            &#125;,</div><div class="line">        &#125;)</div><div class="line">        gitment.render(<span class="string">'container'</span>)</div></pre></td></tr></table></figure><p>之后将静态页面提交到github上查看就行了，一些细节还是看看官方文档吧。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote><p><a href="https://imsun.net/posts/gitment-introduction/" target="_blank" rel="noopener">https://imsun.net/posts/gitment-introduction/</a><br><a href="https://github.com/imsun/gitment/issues/118" target="_blank" rel="noopener">https://github.com/imsun/gitment/issues/118</a><br><a href="https://wf94.github.io/2017/04/14/Use-Gitment-In-Hexo/" target="_blank" rel="noopener">https://wf94.github.io/2017/04/14/Use-Gitment-In-Hexo/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;之前一直没在blog下添加评论系统，多说貌似不干了，偶然间发现了&lt;a href=&quot;https://github.com/imsun/gitment&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gitment&lt;/a&gt;，它是一款基于GitHub Issues 的评论系统，同时有完整的 Markdown / GFM 和代码高亮支持。感觉不错，就添加到blog下了。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>asyncio中使用阻塞函数</title>
    <link href="https://yangsoon.github.io/2018/03/16/asyncio-%E5%88%9D%E6%8E%A2/"/>
    <id>https://yangsoon.github.io/2018/03/16/asyncio-初探/</id>
    <published>2018-03-16T11:11:23.000Z</published>
    <updated>2018-03-19T09:49:04.983Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>最近在学习python的异步编程标准库asyncio，在学习期间，想到如果想要在asyncio中使用阻塞的函数调用，但是不阻塞事件循环的当前线程，应该怎么操作？<br><br>例如我想在asyncio中使用第三方阻塞调用库requests(当然现在有支持异步操作的aiohttp)，或者是想用一些费时的函数计算，亦或是进行io读写。</p><a id="more"></a><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>在《流畅的python》中有这样一段话。</p><blockquote><p>函数(例如io读写，requests网络请求)阻塞了客户代码与asycio事件循环的唯一线程，因此在执行调用时，整个应用程序都会冻结。这个问题的解决方法是，使用事件循环对象的 <code>run_in_executor</code>方法。asyncio的事件循环在背后维护着一个<code>ThreadPoolExecutor</code>对象，我们可以调用<code>run_in_executor</code>方法，把可调用对象发给它执行。</p></blockquote><p>这样我们就知道了我们可以通过<code>run_in_executor</code>方法来新建一个线程来执行耗时函数。</p><h3 id="函数讲解"><a href="#函数讲解" class="headerlink" title="函数讲解"></a>函数讲解</h3><p>因为书中对<code>run_in_executor</code>函数的介绍很少，所以我们先查阅一下<a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.run_in_executor" target="_blank" rel="noopener">官方文档</a>来看一下<code>run_in_executor</code>函数的具体使用方法。</p><p>根据官方文档我们可以知道该方法返回一个协程<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">AbstractEventLoop.run_in_executor(executor, func, *args)</div><div class="line">executor 参数应该是一个 Executor 实例。如果为 <span class="keyword">None</span>，则使用默认 executor。</div><div class="line">func 就是要执行的函数</div><div class="line">*args 就是传递给 func 的参数</div></pre></td></tr></table></figure></p><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><p>下面我们就用一个简单的例子来演示一下如何使用，通过输出结果我们可以看出5个阻塞调用同时进行，在5秒后所有调用结束。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep, strftime</div><div class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</div><div class="line"></div><div class="line">executor = futures.ThreadPoolExecutor(max_workers=<span class="number">5</span>)</div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">blocked_sleep</span><span class="params">(name, t)</span>:</span></div><div class="line">    print(strftime(<span class="string">'[%H:%M:%S]'</span>),end=<span class="string">' '</span>)</div><div class="line">    print(<span class="string">'sleep &#123;&#125; is running &#123;&#125;s'</span>.format(name, t))</div><div class="line">    loop = asyncio.get_event_loop()</div><div class="line">    <span class="keyword">await</span> loop.run_in_executor(executor, sleep, t)</div><div class="line">    print(strftime(<span class="string">'[%H:%M:%S]'</span>),end=<span class="string">' '</span>)</div><div class="line">    print(<span class="string">'sleep &#123;&#125; is end'</span>.format(name))</div><div class="line">    <span class="keyword">return</span> t</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    future = (blocked_sleep(i, i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">6</span>))</div><div class="line">    fs = asyncio.gather(*future)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">await</span> fs</div><div class="line"></div><div class="line">loop = asyncio.get_event_loop()</div><div class="line">results = loop.run_until_complete(main())</div><div class="line">print(<span class="string">'results: &#123;&#125;'</span>.format(results))</div></pre></td></tr></table></figure></p><p>输出结果是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[19:49:32] sleep 3 is running 3s</div><div class="line">[19:49:32] sleep 4 is running 4s</div><div class="line">[19:49:32] sleep 1 is running 1s</div><div class="line">[19:49:32] sleep 5 is running 5s</div><div class="line">[19:49:32] sleep 2 is running 2s</div><div class="line">[19:49:33] sleep 1 is end</div><div class="line">[19:49:34] sleep 2 is end</div><div class="line">[19:49:35] sleep 3 is end</div><div class="line">[19:49:36] sleep 4 is end</div><div class="line">[19:49:37] sleep 5 is end</div><div class="line">result: [1, 2, 3, 4, 5]</div></pre></td></tr></table></figure><p><code>strftime</code>函数是为了格式化输出当前时间，比较清楚的看到调用过程。<code>blocked_sleep</code>函数通过使用<code>run_in_executor</code>方法调用阻塞的sleep()函数。</p><p>在官网中有这样<a href="https://docs.python.org/3/library/asyncio-task.html#coroutines" target="_blank" rel="noopener">一段话</a> 调用协程不会使其中的代码运行，协程对象在被排定执行时间之前都不会进行任何操作。下面有两种基本的方式来启动它的运行:</p><ol><li>在另一个协程中调用 <code>await coroutine</code> 和 <code>yield from coroutine</code> (假定另一个协程已经在执行，即在事件循环中) </li><li>使用 <code>ensure_future</code> 函数或 <code>AbstractEventLoop.create_task</code> 方法来排定执行时间。 </li></ol><p>根据上面的函数讲解我们已经知道<code>run_in_executor</code>方法返回一个协程。因此我们在<code>blocked_sleep</code>函数中驱动他的执行。</p><p>在main函数中<code>future = (blocked_sleep(i, i) for i in range(1, 6))</code>我们产生一个生成器表达式，每个元素都是一个协程。我们将future传递给gather函数。</p><p>对于gather函数的使用方法如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">asyncio.gather(*coros_or_futures, loop=<span class="keyword">None</span>, return_exceptions=<span class="keyword">False</span>)</div><div class="line">你现在知道gather返回一个包含future对象结果的list即可</div></pre></td></tr></table></figure><p>python从3.5开始就引入了新的语法 async 和 await 但是之前因为使用yield from习惯了，所以下面来一个之前的版本。大致上和上面的例子一样，有兴趣可以看一下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep, strftime</div><div class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">blocked</span><span class="params">(t)</span>:</span></div><div class="line">    print(strftime(<span class="string">'[%H:%M:%S]'</span>),end=<span class="string">' '</span>)</div><div class="line">    print(<span class="string">'&#123;&#125; sleep:&#123;&#125;s....'</span>.format(t, t))</div><div class="line">    sleep(t)</div><div class="line">    print(strftime(<span class="string">'[%H:%M:%S]'</span>),end=<span class="string">' '</span>)</div><div class="line">    print(<span class="string">'&#123;&#125; finished'</span>.format(t))</div><div class="line">    <span class="keyword">return</span> t</div><div class="line">    </div><div class="line"><span class="meta">@asyncio.coroutine</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">with</span> futures.ThreadPoolExecutor(max_workers=<span class="number">5</span>) <span class="keyword">as</span> executor:</div><div class="line">        loop = asyncio.get_event_loop()</div><div class="line">        future = [loop.run_in_executor(executor,blocked, i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">6</span>)]</div><div class="line">        fs = asyncio.wait(future)</div><div class="line">        <span class="keyword">return</span> (<span class="keyword">yield</span> <span class="keyword">from</span> fs)</div><div class="line">        </div><div class="line">loop = asyncio.get_event_loop()</div><div class="line">results, _ = loop.run_until_complete(main())</div><div class="line">print(<span class="string">'results: &#123;&#125;'</span>.format([result.result() <span class="keyword">for</span> result <span class="keyword">in</span> results]))</div></pre></td></tr></table></figure><p>输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[20:18:13] 1 sleep:1s....</div><div class="line">[20:18:13] 2 sleep:2s....</div><div class="line">[20:18:13] 3 sleep:3s....</div><div class="line">[20:18:13] 4 sleep:4s....</div><div class="line">[20:18:13] 5 sleep:5s....</div><div class="line">[20:18:14] 1 finished</div><div class="line">[20:18:15] 2 finished</div><div class="line">[20:18:16] 3 finished</div><div class="line">[20:18:17] 4 finished</div><div class="line">[20:18:18] 5 finished</div><div class="line">results: [3, 2, 1, 4, 5]</div></pre></td></tr></table></figure></p><p>在第二份代码里，我故意使用wait函数来等待任务结束，是为了记录一下不同的函数调用方法，和gather函数不同，wait函数需要传入一个list，并且返回两组Futures，(done, pending)。这就是为什么代码里使用 <code>results, _ = loop.run_until_complete(main())</code>的原因了。</p><p>下面是一个使用<code>asyncio.as_comleted</code>方法的例子，该方法返回一个协程迭代器。迭代时迭代器只返回已经完成的future。<a href="https://github.com/python/cpython/blob/3.6/Lib/asyncio/tasks.py#L412" target="_blank" rel="noopener">源码</a>中内部维护一个队列，每次迭代都从队列中返回已经完成的future的结果(result or exception)，可以注意到在输出结果中，7秒后，所以任务才完成。因为executor大小设置为5，每次只有5个线程在跑，所以在第一个block运行结束后，我们可以看到第6个block立即执行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep, strftime</div><div class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">blocked</span><span class="params">(t)</span>:</span></div><div class="line">    print(strftime(<span class="string">'[%H:%M:%S]'</span>),end=<span class="string">' '</span>)</div><div class="line">    print(<span class="string">'&#123;&#125; sleep:&#123;&#125;s....'</span>.format(t, t))</div><div class="line">    sleep(t)</div><div class="line">    print(strftime(<span class="string">'[%H:%M:%S]'</span>),end=<span class="string">' '</span>)</div><div class="line">    print(<span class="string">'&#123;&#125; finished'</span>.format(t))</div><div class="line">    <span class="keyword">return</span> t</div><div class="line"></div><div class="line"><span class="meta">@asyncio.coroutine</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">with</span> futures.ThreadPoolExecutor(max_workers=<span class="number">5</span>) <span class="keyword">as</span> executor:</div><div class="line">        loop = asyncio.get_event_loop()</div><div class="line">        future = [loop.run_in_executor(executor,blocked, i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">7</span>)]</div><div class="line">        fs = asyncio.as_completed(future)</div><div class="line">        results = []</div><div class="line">        <span class="keyword">for</span> f <span class="keyword">in</span> fs:</div><div class="line">            result = <span class="keyword">yield</span> <span class="keyword">from</span> f</div><div class="line">            results.append(result)</div><div class="line">        <span class="keyword">return</span> results</div><div class="line">  </div><div class="line">loop = asyncio.get_event_loop()</div><div class="line">results= loop.run_until_complete(main())</div><div class="line">print(<span class="string">'results: &#123;&#125;'</span>.format(results))</div></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[13:42:39] 1 sleep:1s....</div><div class="line">[13:42:39] 2 sleep:2s....</div><div class="line">[13:42:39] 3 sleep:3s....</div><div class="line">[13:42:39] 4 sleep:4s....</div><div class="line">[13:42:39] 5 sleep:5s....</div><div class="line">[13:42:40] 1 finished</div><div class="line">[13:42:40] 6 sleep:6s....</div><div class="line">[13:42:41] 2 finished</div><div class="line">[13:42:42] 3 finished</div><div class="line">[13:42:43] 4 finished</div><div class="line">[13:42:44] 5 finished</div><div class="line">[13:42:46] 6 finished</div><div class="line">results: [1, 2, 3, 4, 5, 6]</div></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在asyncio中调用阻塞函数时，需要使用asyncio维护的线程池来另开线程运行阻塞函数，防止阻塞事件循环所在的线程。</p><p>几个重要函数比较</p><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">传参</th><th style="text-align:left">返回值</th><th style="text-align:left">返回值顺序</th><th style="text-align:left"></th><th>函数意义</th></tr></thead><tbody><tr><td style="text-align:left"><code>asyncio.gather</code></td><td style="text-align:left">可以传递多个协程或者Futures，函数会自动将协程包装成task，例如协程生成器。</td><td style="text-align:left">包含Futures结果的list</td><td style="text-align:left">按照原始顺序排列</td><td style="text-align:left"></td><td>注重收集结果，等待一堆Futures并按照顺序返回结果</td></tr><tr><td style="text-align:left"><code>asyncio.wait</code></td><td style="text-align:left">a list of futures</td><td style="text-align:left">返回两个Future集合 (done, pending)</td><td style="text-align:left">无序(暂定)</td><td style="text-align:left"></td><td>是一个协程等传给他的所有协程都运行完之后结束，并不直接返回结果</td></tr><tr><td style="text-align:left"><code>asyncio.as_completed</code></td><td style="text-align:left">a list of futures</td><td style="text-align:left">返回一个协程迭代器</td><td style="text-align:left">按照完成顺序</td><td style="text-align:left"></td><td>返回的迭代器每次迭代只返回已经完成的Futures</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;p&gt;最近在学习python的异步编程标准库asyncio，在学习期间，想到如果想要在asyncio中使用阻塞的函数调用，但是不阻塞事件循环的当前线程，应该怎么操作？&lt;br&gt;&lt;br&gt;例如我想在asyncio中使用第三方阻塞调用库requests(当然现在有支持异步操作的aiohttp)，或者是想用一些费时的函数计算，亦或是进行io读写。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>学习linux/unix系统编程手册-编译代码</title>
    <link href="https://yangsoon.github.io/2018/03/15/%E5%AD%A6%E4%B9%A0linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C-%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81/"/>
    <id>https://yangsoon.github.io/2018/03/15/学习linux系统编程手册-编译代码/</id>
    <published>2018-03-15T06:22:38.000Z</published>
    <updated>2018-03-18T12:18:03.768Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>发现每次写文章都要加个前言来瞎扯一波，最近在找实习，之前以为大四上就比较无聊了，后来发现大四下更无聊，不过也有时间来学一些自己喜欢的东西，但是经常会学着学着就打开抖音看小姐姐了，这样不行不行… 所以就要求自己争取每周都能写几篇文章来记录都学了什么。上学期的时候买了一本《linux/unix系统编程手册》里面有相应的demo代码，于是想编译一下，没错我在终端里输入了 <code>gcc demo.c</code> 。结果可想而知报了一大推错。这篇文章是小白记录文，大神就不用看了。</p><a id="more"></a><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><h4 id="1-gcc-I"><a href="#1-gcc-I" class="headerlink" title="1. gcc -I"></a>1. <code>gcc -I</code></h4><p>执行<code>gcc demo.c</code>之后，会出现这样的报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">seek_io.c:4:22: 致命错误：tlpi_hdr.h：没有那个文件或目录</div><div class="line"> #include &quot;tlpi_hdr.h&quot;</div><div class="line">                      ^</div><div class="line">编译中断。</div></pre></td></tr></table></figure><p>因为没有指定头文件<code>tlpi_hdr.h</code>的路径，所以编译器无法找到指定的头文件，所以我们需要给gcc指定对应的头文件所在路径。当然可以修改源码，用相对/绝对路径调用头文件。但是这样显然不好，如果任何文件位置发生变化，都要再次修改源码。</p><p>gcc有-I这个选项，可以把include “…”包含的文件路径放在-I后面。于是做了如下修改：</p><p>执行 <code>gcc -I /home/vagrant/project/tlpi-dist/lib demo.c</code>但是还是报错:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/tmp/ccj4Ei8K.o：在函数‘main’中：</div><div class="line">seek_io.c:(.text+0x46)：对‘usageErr’未定义的引用</div><div class="line">seek_io.c:(.text+0x80)：对‘errExit’未定义的引用</div><div class="line">seek_io.c:(.text+0x125)：对‘getLong’未定义的引用</div><div class="line">seek_io.c:(.text+0x165)：对‘errExit’未定义的引用</div><div class="line">seek_io.c:(.text+0x194)：对‘errExit’未定义的引用</div><div class="line">collect2: 错误：ld 返回 1</div></pre></td></tr></table></figure><h4 id="2-链接"><a href="#2-链接" class="headerlink" title="2. 链接"></a>2. 链接</h4><p>之后在网上查阅资料才知道，出现这种情况的原因，主要是C/C++编译为obj文件的时候并不需要函数的具体实现，只要有函数的原型即可。但是在链接为可执行文件的时候就必须要具体的实现了。如果错误是未声明的引用，那就是找不到函数的原型。</p><p>下面简单的说一下gcc编译流程 1. 预处理阶段 2. 编译阶段 3. 汇编阶段 4. 链接阶段</p><p>问题就出现在链接阶段，程序中没有定义一系列函数的实现，所以会报出上面的错误。函数库一般分为静态库和动态库两种。静态库是指编译链接时，把库文件的代码全部加入到可执行文件中，因此生成的文件比较大，但在运行时也就不再需要库文件了。其后缀名一般为”.a”。动态库与之相反，在编译链接时并没有把库文件的代码加入到可执行文件中，而是在程序执行时由运行时链接文件加载库，这样可以节省系统的开销。动态库一般后缀名为”.so”。</p><p>这时候就需要我们指定函数库的位置。很高兴，tlpi帮我们打包好了。所以继续修改:</p><p><code>gcc -I /home/vagrant/project/tlpi-dist/lib demo.c /home/vagrant/project/tlpi-dist/libtlpi.a</code> </p><p>至此我们可以编译demo.c代码了，但是每次都要输入一堆路径，确实有些烦，为了能在各处写代码，还不用输入一大堆路径，我就写了一个简单的shell脚本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">export TLPI_PATH="/home/vagrant/project/tlpi-dist"</div><div class="line">function glink()&#123;</div><div class="line">    if [ $# -ne 1 ]</div><div class="line">    then</div><div class="line">      echo "请输入一个程序名"</div><div class="line">      return</div><div class="line">    else</div><div class="line">      name=$1</div><div class="line">      echo "gcc -I $&#123;TLPI_PATH&#125;/lib $1 $&#123;TLPI_PATH&#125;/libtlpi.a -o $&#123;name%.*&#125;.o"</div><div class="line">      gcc -I $&#123;TLPI_PATH&#125;/lib $1 $&#123;TLPI_PATH&#125;/libtlpi.a -o $&#123;name%.*&#125;.o</div><div class="line">    fi</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>打开<code>.zshrc</code>或者<code>.bashrc</code>文件，加入上面的代码，<code>TLPI_PATH</code>填上你自己的文件路径，之后执行<code>source .zshrc</code>或者<code>source .bashrc</code>。然后可以用 <code>glink demo.c</code>来编译自己的代码。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote><p><a href="http://www.cnblogs.com/xbf9xbf/p/4755458.html" target="_blank" rel="noopener">http://www.cnblogs.com/xbf9xbf/p/4755458.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;发现每次写文章都要加个前言来瞎扯一波，最近在找实习，之前以为大四上就比较无聊了，后来发现大四下更无聊，不过也有时间来学一些自己喜欢的东西，但是经常会学着学着就打开抖音看小姐姐了，这样不行不行… 所以就要求自己争取每周都能写几篇文章来记录都学了什么。上学期的时候买了一本《linux/unix系统编程手册》里面有相应的demo代码，于是想编译一下，没错我在终端里输入了 &lt;code&gt;gcc demo.c&lt;/code&gt; 。结果可想而知报了一大推错。这篇文章是小白记录文，大神就不用看了。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>我的2017</title>
    <link href="https://yangsoon.github.io/2017/12/16/%E6%9D%82%E8%AE%B0/"/>
    <id>https://yangsoon.github.io/2017/12/16/杂记/</id>
    <published>2017-12-16T14:12:09.000Z</published>
    <updated>2019-02-07T03:23:46.711Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近看了一些其他博主的blog，发现和他们的一些技术文章相比，我似乎更喜欢看他们的一些和平常生活有关的文章。那些生活中琐碎的小事，对我来说都格外的有意思。感觉那是生活中非常美好的部分。之前在其他账号上断断续续写过一些blog，现在换了一个账号，希望这个账号能够让我坚持写下去。说是blog，可能看的人也就只有我和一些意外打开的人了吧。对我来说，写blog就是写给以后的自己，不要忘记曾经的努力和美好吧。<br><a id="more"></a></p><h2 id="劳动节-4-29-5-2"><a href="#劳动节-4-29-5-2" class="headerlink" title="劳动节(4.29-5.2)"></a>劳动节(4.29-5.2)</h2><p>因为到年底了，所以就回顾一下这一年里的发生的比较有意义的事情。在劳动节的时候，和刘鑫一起去了大连玩。比较有意义的是，这次是我第一次坐飞机。坐上飞机之后，像一个孩子一样，不断的探头看地上的风景。因为坐在了靠近过道的位置，离窗户比较远，搞得坐在旁边的情侣很尴尬。哈哈..<br>在大连留下深刻印象的就是星海广场的海鸥，第一次给海鸥喂食，这个小生灵让我感到了生命的美好。下面的图片就是海鸥在夺取食物。<br><img src="http://ww1.sinaimg.cn/large/006r0i4lgy1fmizw73nhsj31w02io7ow.jpg" style="width: 50%; height: 50%"><br>按照行程，我们在大连玩一天就坐船去烟台的蓬莱岛，结果坐的轮船又给了我另一个惊喜。<br><img src="http://ww1.sinaimg.cn/large/006r0i4lgy1fmj03tdi2lj34zs1woqv5.jpg"><br>没错就是这样一个超大的轮船，有点震撼。之后的两天就是在烟台的蓬莱逛逛。没有什么好说的了，但是在烟台的时候在蓬莱的民宿住了一晚，感觉挺不错的，虽然是在别人的家里住，但是环境非常干净，还可以在他们家里吃饭，阿姨做的汤感觉很鲜嫩，没有海鲜的腥味，对于像我这样万年不吃鱼的人来说感觉非常的美味。但是阿姨韭菜馅的馄饨是几个意思..</p><h2 id="6月-7月"><a href="#6月-7月" class="headerlink" title="6月-7月"></a>6月-7月</h2><p>基本上大三已经结束了，这个暑假，对一些人比较重要。那就是要参加外校的夏令营。如果能够获得外校的入营资格，并能获得录取资格，那就表明大四基本上可以轻轻松松的度过了。但是一些学校的入营资格又迟迟不发布，所以我们这些人就整天人心惶惶的等待结果。我们即将开始大四生活，就说明学长就要离开南理工了，所以就想送送之前关系一直很好的C学长(保到清华)，在他走的那天，帮他办了些无关紧要的事情，最后很不好意思的蹭了W学长(保到中科院)一顿饭，吃饭的时候，C学长和他女票(保到北航)传授了一些夏令营面试经验，嘻嘻。<br>一般夏令营开始都在7月份，所以放假到等结果这段时间，我一直宅在宿舍里复习一些专业基础知识，在这段时间里，我们在宿舍里吃了一顿火锅，哈哈，用祥哥的脸盆装的菜，之后被子上都是火锅味，最后强行用花露水掩盖住了味道。<br>到了7月，很幸运的能够获得北航的入营资格，结果也获得了录取资格，刘鑫正好也在北京实习，在出结果那天她请假过来陪我，晚上松神去网吧happy，我和刘鑫在海淀区骑着单车乱逛，后来骑到了清华，去清华里逛了一会，晚上11点多才回到宾馆。洗洗睡睡，第二天，需要选择导师，我就直接选了mail联系过的老师，然后就回家了。</p><blockquote><p>写的脖子比较累，明早还要爬山，有空继续写吧</p></blockquote><p>回家之后，因为过几天还要去中科院网络中心参加夏令营，在家里就当做中转，休息了几天。回家之后，家里竟然开了一家万达。嘻嘻，以后在家里又多了一个能够乱逛的地方，也可以在家里看到IMAX了。<br>在中科院的几天活动中，先听了两天讲座，期间豪哥过来陪我，我们又去鸟巢逛了一圈，记得上一次我们来鸟巢的时候还是高一学竞赛，我们都不由得感叹时间过得飞快。在网络中心的时候，很荣幸的参观了网络中心的机房，还在那里看到了国家域名总节点。<br><img src="http://ww1.sinaimg.cn/large/006r0i4lgy1fmjsk5v1a0j31w02io4d7.jpg" style="width: 50%; height: 50%"><br>在结束面试，笔试之后，中心为我们举办了晚会。晚餐是麦当劳，还有很多零食，水果。中心确实不错。晚会举办的很愉快，我和祥哥都参加了一些中场活动，祥哥还参加了你画我猜的游戏。就这样7月就过去了。</p><h2 id="8月"><a href="#8月" class="headerlink" title="8月"></a>8月</h2><p>8月都在学车，准备寒假再考科二，认识一群很社会的人(哈哈!)。其实都是一些刚上大学的人，感觉j就像回到了高中，和健哥瞎扯的那个时光。</p><h2 id="9月"><a href="#9月" class="headerlink" title="9月"></a>9月</h2><p>9月，妈妈因为之前的病，去济南复查，因为检查结果需要一周的时间才能出来。那一周过得挺煎熬的，黑色的九月。可能当面临一些事情的时候，感觉一些外在的东西都是无所谓的了。<br>刘鑫准备考研了，可能是我给的压力太大了，感觉很对不起她。</p><h2 id="12月"><a href="#12月" class="headerlink" title="12月"></a>12月</h2><p>到了现在写blog的时间点了，考研的马上就要迎来了解放的时候了。祝愿他们心想事成。上面说过爬山的事情，今天天气很好，没想到爬紫金山这么快。爬过泰山之后，爬这样的山感觉就轻松很多。现在到了年底了，越来越意识到自己学到的东西那么少，那么浅。现在一直在补基础的知识，最近在看<a href="https://book.douban.com/subject/3652388/" target="_blank" rel="noopener">《程序员的修养》</a>可能听起来名字很怪，但是感觉这是今年看到的第二本好书了，里面的内容真的需要每个程序员都要掌握。在知乎上看到了一个问题 2017年你又点满了哪些技能树？唉，问问自己感觉真的没学到什么知识。以后要对一年的学习做个基本的规划，计算机一定要与时俱进呀。</p><p>今年4月份的时候吧，在学校拍了这样一张照片。一位老爷爷在吹萨克斯，一位老奶奶在一旁看着，虽然不知道他们是什么关系，但是这样的画面感觉很美好。记得刘鑫曾经说我唱歌好听，希望以后能够每天都唱给她听，再见，即将逝去的17年。<br><img src="http://ww1.sinaimg.cn/large/006r0i4lgy1fmjt7cg6ncj31w02iox6p.jpg" style="width: 50%; height: 50%"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近看了一些其他博主的blog，发现和他们的一些技术文章相比，我似乎更喜欢看他们的一些和平常生活有关的文章。那些生活中琐碎的小事，对我来说都格外的有意思。感觉那是生活中非常美好的部分。之前在其他账号上断断续续写过一些blog，现在换了一个账号，希望这个账号能够让我坚持写下去。说是blog，可能看的人也就只有我和一些意外打开的人了吧。对我来说，写blog就是写给以后的自己，不要忘记曾经的努力和美好吧。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>telegram-bots for developers</title>
    <link href="https://yangsoon.github.io/2017/11/21/telegram-bots-for-developers/"/>
    <id>https://yangsoon.github.io/2017/11/21/telegram-bots-for-developers/</id>
    <published>2017-11-21T14:03:14.000Z</published>
    <updated>2018-05-12T11:22:04.112Z</updated>
    
    <content type="html"><![CDATA[<h4 id="写给开发者的telegram-bots介绍文档"><a href="#写给开发者的telegram-bots介绍文档" class="headerlink" title="写给开发者的telegram-bots介绍文档"></a>写给开发者的telegram-bots介绍文档</h4><p>bots是运行在telegram内部的第三方应用。用户可以通过发送消息，命令或者<a href="#inline-mode">内联请求</a>和bots进行交互。开发者可以通过向<a href="https://core.telegram.org/bots/api" target="_blank" rel="noopener">bot API</a>发送HTTPS请求来控制自己的bot。</p><a id="more"></a><blockquote><p>因为最近对telegram bot产生了兴趣，想创建一个bot试一试，因为网上没有找到相关的中文文档，所以就自己跟着自己的理解和Google Translate翻译了部分的介绍文档(只有bot的基本功能，付款和游戏平台部分没有翻译)，文中一定有表述不对的地方，我会在之后编写bot的时候进行修改，建议大家阅读的时候参照<a href="https://core.telegram.org/bots" target="_blank" rel="noopener">原文档</a>一起阅读。你也可以在下面的评论中提出建议和我一起修改。</p></blockquote><div class="tip"><br>如果你已经熟悉bot的操作模式，那还等什么看快来看这篇 <a href="/2018/04/14/用aiotg开发一个telegram爬虫机器人/">基于aiotg的telegram机器人</a>创建你自己的机器人吧！<br></div><h2 id="我能用bots做什么？"><a href="#我能用bots做什么？" class="headerlink" title="我能用bots做什么？"></a>我能用bots做什么？</h2><p>下面举几个例子，你可以用bot来：</p><ul><li>获得自定义的新闻和通知。一个机器人可以扮演一个智能新闻的角色，发送你需要的新闻。 如：<a href="https://t.me/TechCrunchBot" target="_blank" rel="noopener">TechCrunch Bot</a></li><li>和其他服务集成。一个机器人可以通过绑定其他的服务来丰富聊天 如:<a href="https://t.me/gmailbot" target="_blank" rel="noopener">Gmail Bot</a></li><li>接受来自telegram用户的付款</li><li>创建自定义工具 一个机器人可以为你提供预警，天气预报，格式化文本，翻译，或者其他服务.如: <a href="https://t.me/Bold" target="_blank" rel="noopener">Markdown</a></li><li>创建单人多人游戏 一个机器人可以提供丰富的HTML5体验，从简单的街机和解谜游戏到3D射击和实时策略游戏。如:  <a href="https://t.me/gamebot" target="_blank" rel="noopener">GameBot</a></li><li>建立社交服务 一个机器人能够将一些寻找共同兴趣爱好的人联系在一起。如:<a href="https://t.me/hotorbot" target="_blank" rel="noopener">HotOrBot</a></li><li>或者做一些其他的事情 除了做菜–机器人做的菜非常糟糕(官方吐槽)</li></ul><h2 id="bots是如何工作的"><a href="#bots是如何工作的" class="headerlink" title="bots是如何工作的?"></a>bots是如何工作的?</h2><p>Telegram Bots是一个特别的账号并不需要另外的手机号码去创建，用户可以通过下面两种方式和机器人交互。</p><ol><li>创建和bots的聊天并发送消息和命令或者将机器人加入聊天群。这一特性对聊天机器人和官方新闻机器人很有用。</li><li>直接在输入框中键入<code>@username query</code>来发送请求。这样可以通过<a href="https://core.telegram.org/bots/inline" target="_blank" rel="noopener">inline bots</a>直接发送内容到任何聊天，群或者频道。</li></ol><p>用户发送的消息，命令，和请求被转发给运行在你服务上的应用。我们的中介服务器帮你处理消息的加密和telegram api的通讯。你可以通过简单的HTTPS接口(Telegram API的简化版本)和服务通讯,我们把这个接口称为Bot API。</p><blockquote><p>有关Bot API的详细说明，请参阅 <a href="https://core.telegram.org/bots/api" target="_blank" rel="noopener">bots api</a></p></blockquote><h2 id="我怎么创建一个bot"><a href="#我怎么创建一个bot" class="headerlink" title="我怎么创建一个bot?"></a>我怎么创建一个bot?</h2><p>我们提供一个bot来帮助你创建bot，你可以直接和<a href="https://telegram.me/botfather" target="_blank" rel="noopener">BotFather</a>交谈，并按照几个简单的步骤就可以创建一个属于自己的bot。一旦你创建了一个bot并获取到你的authorization token，那就直接去查看<a href="https://core.telegram.org/bots/api" target="_blank" rel="noopener">Bot API</a>手册看看你能操作机器人做什么事情。</p><blockquote><p>你也可以查看一些 <strong> <a href="https://core.telegram.org/bots/samples" target="_blank" rel="noopener">示例代码</a> </strong></p></blockquote><h2 id="bot和普通账号有什么不同"><a href="#bot和普通账号有什么不同" class="headerlink" title="bot和普通账号有什么不同?"></a>bot和普通账号有什么不同?</h2><ul><li>Bots没有在线状态和last seen时间戳，界面只显示bot标签</li><li>Bots有云存储限制，所以较旧的消息可能在服务器处理后不久被删除</li><li>Bots无法主动与用户交流。用户必须将bot添加到群组中或者先给bot发送消息。其他人可以使用<code>telegram.me/&lt;bot_username&gt;</code>链接或者username来找到你的bot。</li><li>Bot的username总是以’bot’结尾。</li><li>当bot被加入群中，它默认不会接受所有消息。</li><li>机器人不需要吃饭，睡觉或者抱怨(除非程序中有设定) <strong> 又是官方吐槽 </strong></li></ul><h2 id="与众不同的Bot"><a href="#与众不同的Bot" class="headerlink" title="与众不同的Bot"></a>与众不同的Bot</h2><p>Telegram bots在很多方面都与众不同 – 我们提供两种样式的键盘以及提供对默认指令、深层链接以及文本格式等的额外接口。</p><h4 id="内联请求模式"><a href="#内联请求模式" class="headerlink" title="内联请求模式"></a><a id="inlinemode" style="color: black">内联请求模式</a></h4><p>用户可以在任意聊天的输入框中通过输入内联请求和你的bot进行交互。只需在输入框中以你的bot命开头并输入请求即可。<br>收到查询后，您的机器人可以返回一些结果。一旦用户点击其中一个，它就发送到用户当前打开的聊天。通过这种方式，人们可以通过任何聊天，小组或频道和您的bot进行互动。你可以使用<a href="https://telegram.me/sticker" target="_blank" rel="noopener">@sticker</a>来体验一下。</p><div class="tip"><br><a href="/2018/04/14/用aiotg开发一个telegram爬虫机器人/#inlinemode">这里</a>是一个简单的bot基于aiotg的内联模式的代码实现以及图片演示。<br></div><blockquote><p>关于<a href="https://core.telegram.org/bots/inline" target="_blank" rel="noopener">内联模式</a>的更多信息</p></blockquote><h4 id="付款平台"><a href="#付款平台" class="headerlink" title="付款平台"></a><a href="https://core.telegram.org/bots#payments-platform" target="_blank" rel="noopener">付款平台</a></h4><h4 id="游戏平台"><a href="#游戏平台" class="headerlink" title="游戏平台"></a><a href="https://core.telegram.org/bots#gaming-platform" target="_blank" rel="noopener">游戏平台</a></h4><h4 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a><a id="keyboards" style="color: black">键盘</a></h4><p>传统的机器人当然可以被教会理解人类的语言。但是有时候你想从用户那里获得更加规范化的输入，为此我们提供了自定义键盘。</p><div class="tip"><br><a href="/2018/04/14/用aiotg开发一个telegram爬虫机器人/#keyboards">这里</a>是一个简单的bot基于aiotg的自定义键盘代码实现以及图片演示。<br></div><p>每当你的机器人发送一条消息，它会传递一个特定的键盘与预定义的答复选项(请参阅<a href="https://core.telegram.org/bots/api/#replykeyboardmarkup" target="_blank" rel="noopener">ReplyKeyboardMarkup</a>)，telegram会接收到消息并将你设定的键盘展示给用户。点击任何按钮将立即发送相应的命令。这样你可以大大简化用户与你的机器人交互。</p><blockquote><p>有关自定义键盘的更多信息，请查阅<a href="https://core.telegram.org/bots/api" target="_blank" rel="noopener">Bot API</a>的<a href="https://core.telegram.org/bots/api#sendmessage" target="_blank" rel="noopener">sendMessage</a>部分。</p></blockquote><h4 id="内联键盘和消息更新"><a href="#内联键盘和消息更新" class="headerlink" title=" 内联键盘和消息更新 "></a><a id="inlinekeyboards" style="color: black"> 内联键盘和消息更新 </a></h4><p>有时候用户更喜欢可以不发送消息也能做一些事情。比如，当你的用户正在改变设置或翻阅搜索结果，在这种情况，你可以直接将内联键盘附加到所属的消息中。与自定义回复键盘不同，点击内联键盘上的按钮不会发送消息到当前聊天中。内联键盘支持按钮在后台工作，比如：callback buttons, URL buttons 和switch to inline buttons。</p><p>当使用回调按钮时，你的bot可以更新已经存在的消息(或者只是这些消息附加的键盘)所以这样能够保持聊天界面的整洁。你可以查看这些机器人的内联键盘的功能:<a href="https://telegram.me/music" target="_blank" rel="noopener">@music</a>、<a href="https://telegram.me/vote" target="_blank" rel="noopener">@vote</a>。</p><div class="tip"><br><a href="/2018/04/14/用aiotg开发一个telegram爬虫机器人/#inlinekeyboards">这里</a>是一个简单的bot基于aiotg内联键盘和消息更新的代码实现以及图片演示。<br></div><blockquote><p><a href="https://core.telegram.org/bots/2-0-intro#new-inline-keyboards" target="_blank" rel="noopener">了解更多关于内联键盘和即时编辑的信息 &gt;&gt;</a></p></blockquote><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><p>命令提供了一个更灵活的方式与您的机器人进行通信。可以使用下面的语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/command [optional] [argument]</div></pre></td></tr></table></figure></p><p>每个命令必须以‘/’开头且不能超过32个字符，命令可以使用拉丁字母，数字和下划线。下面是几个示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/get_messages_stats</div><div class="line">/set_timer 10min Alarm!</div><div class="line">/get_timezone London, UK</div></pre></td></tr></table></figure></p><p>以斜线开头的消息总是被发送给机器人。telegram 将会这样处理:</p><ul><li>当用户输入‘/’时，将会出现带有相应描述的命令提示(开发者提供给botFather相应的命令列表)。点击列表中的命令会立即发送命令。</li><li>在和机器人的所有聊天的输入字段中显示一个额外的（/）按钮。点击它键入一个“/”并显示命令列表。</li><li>在消息中将命令高亮显示，当用户点击突出显示的命令时，立即发送该命令。</li></ul><p>如果多个机器人在一个组中，可以将bot用户名添加到命令中以避免混淆:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/start@TriviaBot</div><div class="line">/start@ApocalypseBot</div></pre></td></tr></table></figure></p><p>这是通过建议列表选择命令时自动完成的，请记住你的bot需要能够处理跟在username后的指令。</p><h4 id="全局命令"><a href="#全局命令" class="headerlink" title="全局命令"></a>全局命令</h4><p>为了使所有的用户能够轻松应对各种bots的使用，我们要求开发者必须实现几个基础命令。telegram将会在界面中为这几个基础指令提供相应的快捷键。</p><ul><li><strong> / start </strong>  - bots开始和用户交互，例如发送一个欢迎的消息。这个指令同样可以传递几个额外的参数给bot。</li><li><strong> / help </strong> - 返回一个帮助消息。</li><li><strong> / setting </strong> - 将会返回给用户一些机器人的功能设定，显示可以编辑设置的指令。</li></ul><p>用户在第一次打开与您的机器人的对话时将看到一个start按钮。在机器人的配置菜单中有help和setting的链接。</p><h4 id="隐私模式"><a href="#隐私模式" class="headerlink" title="隐私模式"></a>隐私模式</h4><p>bots经常被加入到组中来加强人与人之间的沟通。例如通过提供新闻，来自外部服务的通知或其他搜索功能。特别是那些工作聊天组。现在当你与bot共享一个组时，你会问问自己，我怎么能够保证这个小流氓(bot)不会将我的历史记录泄露给竞争对手呢？答案就是-隐私模式。运行在隐私模式下的bot不会收到所有发送给该组的消息。相反，它只会收到：</p><ul><li>命令</li><li>回复机器人自己的消息</li><li>服务消息(人员的添加和删减)</li><li>来自频道的消息</li></ul><p>一方面，这有助于我们一些人在晚上更好地睡觉; 另一方面，它允许机器人开发人员节省大量的资源，因为他们每天不需要处理数以万计的不相关的消息。</p><p>所有的bots默认启用隐私模式，除了被加入组中当做管理员的bot(bot admin)总是收到所有的消息)它可以被禁用，以便机器人像普通用户一样接收所有消息。如果不必要，我们建议你不要这样做。用户可以随时在组成员列表中查看机器人的当前隐私设置。在大多数情况下，使用机器人消息的<a href="https://core.telegram.org/bots/api#forcereply" target="_blank" rel="noopener">强制回复</a>选项应该是绰绰有余的。</p><p><a href="https://core.telegram.org/bots/faq#what-messages-will-my-bot-get" target="_blank" rel="noopener">那么我的bot究竟会收到什么样的信息呢？&gt;&gt;</a></p><h4 id="深层链接"><a href="#深层链接" class="headerlink" title="深层链接"></a><a href="https://en.wikipedia.org/wiki/Deep_linking" target="_blank" rel="noopener">深层链接</a></h4><p>百度百科中对deeplink有下面这样的描述</p><blockquote><p>移动端深度链接 是指在移动端网页或应用内输入搜索结果，可以链接到手机内安装的其他应用。</p></blockquote><p>telegram bots有深层链接机制，允许在启动时将其他参数传递给机器人，这可能是一个启动机器人的命令，或者是一个身份验证令牌将用户的telegram帐户连接到某个外部服务上的帐户。</p><p>每个bot都有一个在telegram打开一个对话的链接。<code>https://telegram.me/&lt;bot username&gt;</code>您可以将参数start或startgroup添加到此链接，参数值最多为64个字符。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://telegram.me/triviabot?startgroup=test</div></pre></td></tr></table></figure><p><code>A-Z</code>,<code>a-z</code>,<code>0-9</code>,<code>_</code>和<code>-</code>都可以使用。我们建议使用base64url编码参数与二进制和其他类型的内容。</p><p>点击带有启动参数的链接将打开与bot的一对一对话，在输入栏位显示一个START按钮。如果使用startgroup参数，则会提示用户选择要添加机器人的组。一旦用户进行了确认(点击START按钮或者选择了一个组加入bot)，你的机器人将以这种格式接收一个来自该用户的消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/start PAYLOAD</div></pre></td></tr></table></figure><p><code>PAYLOAD</code>表示链接中传递的start或startgroup参数的值。</p><h4 id="深层链接示例"><a href="#深层链接示例" class="headerlink" title="深层链接示例"></a>深层链接示例</h4><p>假设网站example.com希望通过bot向用户发送通知。以下是他们为ID<code>123</code>用户开启通知进行的操作。</p><ol><li>创建一个有合适名字的bot，例如 @ExampleComBot</li><li>为传入的消息设置<a href="https://core.telegram.org/bots/api#setwebhook" target="_blank" rel="noopener">webhook</a></li><li>生成足够长度的随机字符串。比如<code>$memcache_key = &quot;vCH1vGWJxfSeofSAs0K5PA&quot;</code></li><li>将值123和<code>$memcache_key</code>放在内存里缓存一小时。</li><li>向用户显示按钮<code>https://telegram.me/ExampleComBot?start=vCH1vGWJxfSeofSAs0K5PA</code>(START按钮会附带参数)</li><li>webhook使用来自start传来的参数(key)去查询内存，如果key存在，将传递给webhook的chat_id记录为用户123的telegram_chat_id。从内存中移除key。</li><li>现在，当我们想发送通知给用户123时，检查他们是否具有telegram_chat_id字段。如果有，那么就使用Bot API中的sendMessage发送消息。</li></ol><h4 id="位置和电话号码"><a href="#位置和电话号码" class="headerlink" title="位置和电话号码"></a>位置和电话号码</h4><p>一些bot需要获得用户额外的数据才能工作的更好。例如，知道用户的位置有助于提供更相关的地理位置特定的结果。用户的电话号码对于与银行等其他服务的集成非常有用。</p><p>bot可以使用特殊按钮询问用户的位置和电话号码。请注意，电话号码和位置请求按钮只能用于私人聊天。</p><p>当按钮被按下后，telegram将显示一个确认提醒，告诉用户即将发生的事情。</p><h2 id="BotFather"><a href="#BotFather" class="headerlink" title="BotFather"></a>BotFather</h2><p>BotFather是管理所有bot的机器人。它将帮助您创建新的机器人和更改现有机器人的设置。</p><h4 id="创建一个新的bot"><a href="#创建一个新的bot" class="headerlink" title="创建一个新的bot"></a><a id="newbot" style="color: black">创建一个新的bot</a></h4><p>使用 <strong> / newbot </strong> 命令来创建一个新的机器人。 BotFather会要求你提供一个名字和用户名，然后为你的新机器人生成一个授权令牌。</p><p>您的机器人的名称显示在联系方式和其他地方。</p><p><strong> Uername </strong> 是一个简称。用户名长度为532个字符，不区分大小写，但只能包含拉丁字符，数字和下划线。你的机器人的用户名必须以“bot”结尾。</p><p><strong> token </strong> 是一串了类似  <code>110201543:AAHdqTcvCH1vGWJxfSeofSAs0K5PALDsaw</code> 的字符串。<br>用于授权bot并向Bot API发送请求。</p><h4 id="生成授权令牌"><a href="#生成授权令牌" class="headerlink" title="生成授权令牌"></a>生成授权令牌</h4><p>如果您的现有令牌受到威胁，或者由于某种原因而丢失了该令牌，请使用/ token命令生成一个新的令牌。</p><h4 id="BotFather-Commands"><a href="#BotFather-Commands" class="headerlink" title="BotFather Commands"></a>BotFather Commands</h4><blockquote><p>命令很简单，此处略过，请读者自己尝试。</p></blockquote><h4 id="状态警报"><a href="#状态警报" class="headerlink" title="状态警报"></a>状态警报</h4><p>百万个用户因为telegram的快速响应选择我们，为了能够保证开发者的bot能时刻处在正常状态。所以当你的bot出现问题时，botfather会给你发送一个状态警报。</p><p>我们将会检查热门bot的回复数目以及 请求/响应 转换率。如果我们得到异常低的读数，您将收到Botfather的通知。</p><h4 id="响应警报"><a href="#响应警报" class="headerlink" title="响应警报"></a>响应警报</h4><p>默认情况下，每个机器人每小时只能获得一个警报。每个警报都有以下按钮：</p><ul><li><strong> Fixed </strong> 如果你发现你的机器人有问题并修复它，请使用它。如果按下修复按钮，我们将继续以常规方式继续发送警报，以便您能够在5-10分钟内查看您的修复是否工作，而不必等待一个小时。</li><li><strong> Support </strong> 如果您没有看到您的机器人有任何问题，或者如果您认为问题在我们这边，可以使用它来打开与@BotSupport的聊天。</li><li><strong> Mute for 8h/1w </strong> 如果您目前无法修复您的机器人，请使用此功能。这将在指定的时间段内禁用问题机器人的所有警报。我们不建议使用此选项，因为您的用户可能会迁移到更稳定的机器人。您可以通过Botfather取消您的机器人设置中的警报静音。</li></ul><h4 id="Monitored-issues-监控"><a href="#Monitored-issues-监控" class="headerlink" title="Monitored issues(监控)"></a>Monitored issues(监控)</h4><ol><li><p><code>Too few **private messages** are sent compared to previous weeks: **{value}**</code><br>你的机器人发送的信息要少于前几周,这对通讯类型的机器人很有用。</p></li><li><p><code>Too few replies to incoming **private messages**. Conversion rate: **{value}**</code><br>您的机器人不会回复发送给它的所有消息(您的机器人的请求/响应转换率在过去的三个5分钟内至少有两次是太低)。为了提供良好的用户体验，请回复发送给您的机器人的所有消息。</p></li><li><p><code>Too few answers to **inline queries**. Conversion rate: **{value}**</code><br>您的机器人不会回复正在发送给它的所有内嵌查询，其计算方式与上述相同。</p></li><li><p>​</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Too few answers to callback queries. Conversion rate: &#123;value&#125;</div><div class="line"></div><div class="line">Too few answers to callback game queries. Conversion rate: &#123;value&#125;</div></pre></td></tr></table></figure><p>你的机器人没有回复正在发送给它的所有回调查询,其计算方式与上述相同。</p></li></ol><blockquote><p>请注意，状态提醒功能仍在测试中，将来会有所改进。</p></blockquote><p>以上就是介绍。阅读完此部分说明您现在已经准备好进入<a href="https://core.telegram.org/bots/api" target="_blank" rel="noopener">BOT API</a>手册。</p><p>如果您有任何问题，请查看我们的<a href="https://core.telegram.org/bots/faq" target="_blank" rel="noopener">Bot FAQ »</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;写给开发者的telegram-bots介绍文档&quot;&gt;&lt;a href=&quot;#写给开发者的telegram-bots介绍文档&quot; class=&quot;headerlink&quot; title=&quot;写给开发者的telegram-bots介绍文档&quot;&gt;&lt;/a&gt;写给开发者的telegram-bots介绍文档&lt;/h4&gt;&lt;p&gt;bots是运行在telegram内部的第三方应用。用户可以通过发送消息，命令或者&lt;a href=&quot;#inline-mode&quot;&gt;内联请求&lt;/a&gt;和bots进行交互。开发者可以通过向&lt;a href=&quot;https://core.telegram.org/bots/api&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;bot API&lt;/a&gt;发送HTTPS请求来控制自己的bot。&lt;/p&gt;
    
    </summary>
    
    
      <category term="introduction" scheme="https://yangsoon.github.io/tags/introduction/"/>
    
      <category term="telegram-bots" scheme="https://yangsoon.github.io/tags/telegram-bots/"/>
    
  </entry>
  
  <entry>
    <title>vagrant开发遇到的坑</title>
    <link href="https://yangsoon.github.io/2017/10/01/vagrant%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"/>
    <id>https://yangsoon.github.io/2017/10/01/vagrant开发遇到的坑/</id>
    <published>2017-10-01T04:39:35.000Z</published>
    <updated>2017-11-09T12:50:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="npm-EPROTO-protocol-error-symlink"><a href="#npm-EPROTO-protocol-error-symlink" class="headerlink" title="npm EPROTO: protocol error, symlink"></a>npm EPROTO: protocol error, symlink</h2><p>在虚拟机下初始化js项目时，开始会执行 <code>npm install</code>这时候经常会遇到这样的错误，原因是windows和linux在符号链接上有不同的定义和实现。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p><code>npm install --no-bin-links</code></p><h2 id="webpack-dev-server-不能热更新"><a href="#webpack-dev-server-不能热更新" class="headerlink" title="webpack-dev-server 不能热更新"></a>webpack-dev-server 不能热更新</h2><a id="more"></a><p>在使用webpack进行前端开发时，使用起来最方便的应该是webpack的热更新了，但是在vagrant下我们会发现webpack不能进行热更新。在<a href="https://en.wikipedia.org/wiki/Inotify" target="_blank" rel="noopener">wiki</a>中有这样一段话。</p><blockquote><p>Notification via inotify requires the kernel to be aware of all relevant filesystem events, which is not always possible for networked filesystems such as NFS …</p></blockquote><p>大概意思是对于类似NFS这样的网络系统文件，文件的变化并不总是能够成功的通知到变化。好在这并没有宣布彻底放弃当前方案，后面有人给出了方案:</p><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p><code>watchOptions: { poll: true }</code></p><p>我们可以使用webpack –watch –color,设置poll属性，Webpack会在100毫秒左右内检测文件更新，随时build。</p><h2 id="npm安装的全局应用command-not-found"><a href="#npm安装的全局应用command-not-found" class="headerlink" title="npm安装的全局应用command not found"></a>npm安装的全局应用<code>command not found</code></h2><p>当我们使用npm安装一些js应用(vue-cli、webpack、supervisor)时，执行相应的命令的时候，经常因为路径问题出现命令找不到的情况，有时候根据情况不同，解决方案也会有多种。在这里我给大家推荐使用<a href="https://yarnpkg.com/zh-Hans/" target="_blank" rel="noopener">yarn</a>安装一些node包。</p><h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><h4 id="1-Ubuntu下安装yarn"><a href="#1-Ubuntu下安装yarn" class="headerlink" title="1.Ubuntu下安装yarn"></a>1.Ubuntu下安装yarn</h4><p><code>sudo apt-get update &amp;&amp; sudo apt-get install yarn</code></p><h4 id="2-使用yarn安装全局node包"><a href="#2-使用yarn安装全局node包" class="headerlink" title="2.使用yarn安装全局node包"></a>2.使用yarn安装全局node包</h4><p><code>yarn global add &lt;package...&gt;</code></p><p>更多命令查看<a href="https://yarnpkg.com/zh-Hans/docs/cli/" target="_blank" rel="noopener">文档</a></p><h2 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h2><div class="tip"><br>这些主要是在进行前端开发的时候遇到的一些问题，但是经过一些折腾之后，我觉得最好的解决方案就是不要用虚拟机进行前端开发。实践证明，前端开发不一定要追求linux环境。如果想更快的学习前端知识，远离虚拟机。<br></div><p>参考文章<br><a href="http://www.jackpu.com/shi-yong-vagrant-he-webpackkai-fa-cai-guo-de-keng/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">使用Vagrant + webpack开发踩过的坑</a><br><a href="https://blog.wangboyang.com/npm-eproto-protocol-error-symlink/" target="_blank" rel="noopener">npm EPROTO: protocol error, symlink</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;npm-EPROTO-protocol-error-symlink&quot;&gt;&lt;a href=&quot;#npm-EPROTO-protocol-error-symlink&quot; class=&quot;headerlink&quot; title=&quot;npm EPROTO: protocol error, symlink&quot;&gt;&lt;/a&gt;npm EPROTO: protocol error, symlink&lt;/h2&gt;&lt;p&gt;在虚拟机下初始化js项目时，开始会执行 &lt;code&gt;npm install&lt;/code&gt;这时候经常会遇到这样的错误，原因是windows和linux在符号链接上有不同的定义和实现。&lt;/p&gt;
&lt;h4 id=&quot;解决方案&quot;&gt;&lt;a href=&quot;#解决方案&quot; class=&quot;headerlink&quot; title=&quot;解决方案&quot;&gt;&lt;/a&gt;解决方案&lt;/h4&gt;&lt;p&gt;&lt;code&gt;npm install --no-bin-links&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;webpack-dev-server-不能热更新&quot;&gt;&lt;a href=&quot;#webpack-dev-server-不能热更新&quot; class=&quot;headerlink&quot; title=&quot;webpack-dev-server 不能热更新&quot;&gt;&lt;/a&gt;webpack-dev-server 不能热更新&lt;/h2&gt;
    
    </summary>
    
    
      <category term="vagrant" scheme="https://yangsoon.github.io/tags/vagrant/"/>
    
      <category term="webpack" scheme="https://yangsoon.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://yangsoon.github.io/2017/09/30/hello-world/"/>
    <id>https://yangsoon.github.io/2017/09/30/hello-world/</id>
    <published>2017-09-30T05:48:55.000Z</published>
    <updated>2017-09-30T05:48:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
