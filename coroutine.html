<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!-- iOS Safari -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- Chrome, Firefox OS and Opera Status Bar Color -->
<meta name="theme-color" content="#FFFFFF">
<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css">
<link rel="stylesheet" type="text/css"
  href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.19.0/themes/prism.min.css">
<link rel="stylesheet" type="text/css" href="css/SourceSansPro.css">
<link rel="stylesheet" type="text/css" href="css/theme.css">
<link rel="stylesheet" type="text/css" href="css/notablog.css">
<!-- Favicon -->

  <link rel="shortcut icon" href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F755439b9-9583-43c3-b282-b5d6af4102f1%2Fcodeedit.svg?table=collection&amp;id=3e8bb3a8-a159-4df7-963b-d7260c12c7f3">

<style>
  :root {
    font-size: 20px;
  }
</style>
  <title>有栈协程实现原理&nbsp;|&nbsp;yangsoon の 自嗨</title>
  <meta property="og:type" content="blog">
  <meta property="og:title" content="有栈协程实现原理">
  
    <meta name="description" content="携程(误) 协程的实现原理">
    <meta property="og:description" content="携程(误) 协程的实现原理">
  
  
    <meta property="og:image" content="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F77239291-88f1-4896-b4e6-07b12a3c7b72%2F3x.svg?table=block&amp;id=46b70d0f-b1d9-4a90-aee0-0461722333ba">
  
  <style>
    .DateTagBar {
      margin-top: 1.0rem;
    }
  </style>
</head>

<body>
  <nav class="Navbar">
  <a href="index.html">
    <div class="Navbar__Btn">
      
        <span><img class="inline-img-icon" src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F755439b9-9583-43c3-b282-b5d6af4102f1%2Fcodeedit.svg?table=collection&amp;id=3e8bb3a8-a159-4df7-963b-d7260c12c7f3"></span>&nbsp;
      
      <span>Home</span>
    </div>
  </a>
  
    
  
    
  
    
      <span class="Navbar__Delim">&centerdot;</span>
      <a href="about.html">
        <div class="Navbar__Btn">
          
            <span><img class="inline-img-icon" src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fe8540b67-25be-41a9-8a21-2d3e20712d66%2FIMG_2189.jpg?table=block&amp;id=4bf8bf12-ac4b-47a5-a71e-d5892342c49c"></span>&nbsp;
          
          <span>About</span>
        </div>
      </a>
    
  
    
  
    
  
    
  
</nav>
  <header class="Header">
    
      <div class="Header__Cover">
        <img src="https://images.unsplash.com/photo-1613253932202-686cbcd993b0?ixlib=rb-1.2.1&amp;q=85&amp;fm=jpg&amp;crop=entropy&amp;cs=srgb">
      </div>
    
    <div class="Header__Spacer ">
    </div>
    
      <div class="Header__Icon">
        <span><img class="inline-img-icon" src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F77239291-88f1-4896-b4e6-07b12a3c7b72%2F3x.svg?table=block&amp;id=46b70d0f-b1d9-4a90-aee0-0461722333ba"></span>
      </div>
    
    <h1 class="Header__Title">有栈协程实现原理</h1>
    
      <div class="DateTagBar">
        
          <span class="DateTagBar__Item DateTagBar__Date">Posted on Sun, Jul 11, 2021</span>
        
        
          <span class="DateTagBar__Item DateTagBar__Tag DateTagBar__Tag--purple">
            <a href="tag/os.html">os</a>
          </span>
        
      </div>
    
  </header>
  <article id="https://www.notion.so/46b70d0fb1d94a90aee00461722333ba" class="PageRoot PageRoot--FullWidth"><div id="https://www.notion.so/6faabd561bdd46788fcd2c2e53e0f648" class="ColumnList"><div id="https://www.notion.so/0a1d50386fa64bb6a8ebdfe560ee4e9e" class="Column" style="width:calc((100% - var(--column-spacing) * 1) * 0.1875)"><ul id="https://www.notion.so/65faf3739df340da8ee96668936c4879" class="ColorfulBlock ColorfulBlock--ColorGray TableOfContents"><li class="TableOfContents__Item"><a href="#https://www.notion.so/722ebb7638524f978a9304142c672e6b"><div style="margin-left:0px"><span class="SemanticStringArray"><span class="SemanticString">协程</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/71ff10c93c464461823d74f09edb359d"><div style="margin-left:0px"><span class="SemanticStringArray"><span class="SemanticString">进程、线程</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/1a4d4d2f79814963a6e6b7d72ffce7bb"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">进程地址空间</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/2b22dcb77b2e4cf2bc9ff961583966cf"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">栈的增长方式</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/8f15eff45e8c4e04ba3da948aaafb738"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">线程</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/85567b132bd84050a0dc03553b6365ba"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">线程上下文切换</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/e8b293fae4d7457f93e0dbc6571b8c8f"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">实现协程的理论依据</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/aec6fa3ab1c54d4599272a7e87a128ba"><div style="margin-left:0px"><span class="SemanticStringArray"><span class="SemanticString">ucontext</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/1badb3bd39bb4d25ade4c1ed12edad42"><div style="margin-left:0px"><span class="SemanticStringArray"><span class="SemanticString">coroutine实现</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/8cb8158c60b940c3ae59989e41a84319"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">coroutine例子</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/860ce9447bdc41079ce49eb1fe04cc8d"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">核心对象</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/ffad741c58c14cb68f733b4050adfd70"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">协程状态</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/cce74e23347142019bb33a6f3640798d"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">READY -&gt; RUNNING</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/3cf237b741d74562a909445c4d3aeb5a"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">RUNNING -&gt; SUSPEND</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/2aac51fa201044d39f25a12a1a25a1aa"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">SUSPEND -&gt; RUNNING</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/62c8a347d32947fbb98de5a6ecc7b574"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">运行栈保存</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/a2781ff2b97e4c21ab0a19ea80c7a8d8"><div style="margin-left:0px"><span class="SemanticStringArray"><span class="SemanticString">goroutine实现</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/1bfa850fe5b04654aef93de03787cc0e"><div style="margin-left:0px"><span class="SemanticStringArray"><span class="SemanticString">参考文献</span></span></div></a></li></ul></div><div id="https://www.notion.so/c991e2766b3d426ab1ba06418823e61c" class="Column" style="width:calc((100% - var(--column-spacing) * 1) * 0.8125)"><div id="https://www.notion.so/530b46964e764cb788a22327a7d72a62" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">本文主要讲解有栈线程的实现原理，以云风实现的coroutine为例。在讲解之前，本文会先描述一些基本的概念，保证读者能够轻松的理解coroutine的实现。</span></span></p></div><h2 id="https://www.notion.so/722ebb7638524f978a9304142c672e6b" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/722ebb7638524f978a9304142c672e6b"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">协程</span></span></h2><div id="https://www.notion.so/a5d1c53d9ca24c6792da2e46afaf0c36" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">关于协程的概念，在网上没有找到很好的解释，下面就说说个人的理解，(有栈)协程可以理解为一个用户态下的线程，在用户态下进行线程（协程）的上下文切换。但是和传统的线程不同的是：线程是抢占式执行，当发生系统调用或者中断的时候，交由OS调度执行；而协程是通过yield主动让出cpu所有权，切换到其他协程执行。</span></span></p></div><h2 id="https://www.notion.so/71ff10c93c464461823d74f09edb359d" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/71ff10c93c464461823d74f09edb359d"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">进程、线程</span></span></h2><h3 id="https://www.notion.so/1a4d4d2f79814963a6e6b7d72ffce7bb" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/1a4d4d2f79814963a6e6b7d72ffce7bb"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">进程地址空间</span></span></h3><div id="https://www.notion.so/2568ea477d1442e6a196365f305f9743" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">一般来说一个进程的地址空间有这几个默认区域:</span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/7cd6cddc55ec415cbc7bd8c8a78769c6" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">栈：栈用于维护函数调用的上下文，包括函数的参数，局部变量等等。</span></span></li><li id="https://www.notion.so/477e038a0ef74aaf88dc84f6a51f625b" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">堆：用来容纳程序中动态分配的内存区域，当程序使用malloc和new分配的内存就来自于堆里</span></span></li><li id="https://www.notion.so/cb7302a3e796466aa0c933eb5e07f1bc" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString">可执行文件映像。</span></span></li><li id="https://www.notion.so/85637744fe884f9cb3cdd5dacc32a7ad" class="NumberedList" value="4"><span class="SemanticStringArray"><span class="SemanticString">保留区，是对内存中受到保护而禁止访问的内存区域的总称。</span></span></li></ol><div id="https://www.notion.so/e8448f84f84046e4815e0a75abf2882e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">下图是linux下一个进程的典型内存布局: 在经典的操作系统中，栈总是 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">向下增长</strong></span><span class="SemanticString"> ，从高地址向低地址增长，其中栈顶指针存储在 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">[E|R]SP</strong></span><span class="SemanticString"> 寄存器中，而堆则总是 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">向上增长</strong></span><span class="SemanticString"> ，从低地址向高地址增长。</span></span></p></div><div id="https://www.notion.so/c5879966abb14d0491848eeb9961449c" class="Image Image--Normal"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F2f585320-a4d6-4979-961b-0a169b04878c%2F1.png?width=432&amp;table=block&amp;id=c5879966-abb1-4d04-9184-8eeb9961449c"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F2f585320-a4d6-4979-961b-0a169b04878c%2F1.png?width=432&amp;table=block&amp;id=c5879966-abb1-4d04-9184-8eeb9961449c" style="width:432px"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><h3 id="https://www.notion.so/2b22dcb77b2e4cf2bc9ff961583966cf" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/2b22dcb77b2e4cf2bc9ff961583966cf"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">栈的增长方式</span></span></h3><div id="https://www.notion.so/28061cfb7ed1478885b3d9531bd7745b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">栈在程序运行中具有举足轻重的地位，最重要的，栈保存了一个函数调用所需要维护的信息，这常常被称为</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">堆栈帧</strong></span><span class="SemanticString">，堆栈帧一般包括下面几方面内容：</span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/a775348e18804f569577bd5696b8c872" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">函数的返回地址和参数</span></span></li><li id="https://www.notion.so/566135cf86a0434f89f39215e1e2c243" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量</span></span></li><li id="https://www.notion.so/7dd7685b9ab24279950594f3bb0f0e5a" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString">保存的上下文：包括在函数调用前后需要保存不变的寄存器的值</span></span></li></ol><div id="https://www.notion.so/39ecc7419782454b993fdb7890590db5" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">一个函数的堆栈帧用 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">[E|R]SP,[E|R]BP</strong></span><span class="SemanticString"> ，这两个寄存器划定范围，</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">[E|R]SP</strong></span><span class="SemanticString">始终指向栈顶的位置称为栈指针寄存器，</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">[E|R]SP</strong></span><span class="SemanticString">指向堆栈帧的一个固定位置，</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">[E|R]SP</strong></span><span class="SemanticString"> 又被称为帧指针，一般函数中的局部变量靠 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">[E|R]SP</strong></span><span class="SemanticString"> 加上偏移量寻找。</span></span></p></div><blockquote id="https://www.notion.so/29377723682743b1b7e5a00885c84e6d" class="ColorfulBlock ColorfulBlock--ColorDefault Quote"><span class="SemanticStringArray"><span class="SemanticString">[E|R]SP表示esp或者rsp寄存器，esp表示32位x86架构下的栈指针寄存器，rsp表示64位x86架构下的栈指针寄存器，同理于[E|R]BP。 帧指针并不是必须的, x86-64过程中的栈帧通常有固定的大小，在调用过程中栈指针保持固定的位置，使得可以通过相对于栈指针的偏移量来访问数据^1。</span></span></blockquote><div id="https://www.notion.so/02dfd3f1184542808f127c4dcba1500b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">下面我们就简单讲解一下当程序调用一个简单的函数时，线程中的栈是如何增长的。假设有一个foo函数</span></span></p></div><pre id="https://www.notion.so/561d9b850dc0462db46261f381d0f4c7" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span><span class="token keyword">int</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// #i</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span></span></span></span></code></pre><div id="https://www.notion.so/1a39536d56b44a448f3b250b1f2bec16" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">该函数对应的堆栈帧的内存空间如下所示，一个函数的堆栈帧增长过程是这样的：</span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/f2a98136448d4430b1622209ce3d9f80" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">把所有或一部分参数加入栈中，如果有其他参数没有入栈，那么使用某些寄存器传递</span></span></li><li id="https://www.notion.so/b18b653d7c604ae19d166a769380ec71" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">把当前指令的下一条指令地址压入栈中</span></span></li><li id="https://www.notion.so/f27bb9b313bb49db8c171793c0b3b922" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString">跳转到函数体执行:</span></span><ol class="NumberedListWrapper"><li id="https://www.notion.so/af276c49d991474188bc6d741ccbddc1" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">把[e|r]bp压入栈中，指向上一个函数堆栈帧中的帧指针的位置</span></span></li><li id="https://www.notion.so/6ee7a8c588d4461ca813f23d8fbd38bf" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">保存调用前后需要保存不变的寄存器的值</span></span></li><li id="https://www.notion.so/4ce2af874ee34f428d07b9c83331c697" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString">将局部变量压入栈中</span></span></li></ol><div id="https://www.notion.so/fc6a92346e174c85ba8b14f50a17876e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">...</span></span></p></div></li></ol><div id="https://www.notion.so/2c7c2ceb8f304ef7995a67f119cc2a3c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">当函数调用返回之后，相应的函数堆栈帧也会弹出，弹出的流程不是本篇文章的重点，在此就不详细讲解，感兴趣的推荐看 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">程序员的自我修养</strong></span><span class="SemanticString"> 中讲解堆栈的部分。</span></span></p></div><div id="https://www.notion.so/804e5a0670ae447c91ad4abc6fef3448" class="Image Image--Normal"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Faa650a45-a8da-42ff-928f-147e5267be32%2F2.png?width=576&amp;table=block&amp;id=804e5a06-70ae-447c-91ad-4abc6fef3448"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Faa650a45-a8da-42ff-928f-147e5267be32%2F2.png?width=576&amp;table=block&amp;id=804e5a06-70ae-447c-91ad-4abc6fef3448" style="width:576px"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><h3 id="https://www.notion.so/8f15eff45e8c4e04ba3da948aaafb738" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/8f15eff45e8c4e04ba3da948aaafb738"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">线程</span></span></h3><div id="https://www.notion.so/bc825e5d47eb4180becb2050bf2b0438" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">一个标准的线程由线程id、程序计数器(PC)、寄存器集合和栈组成。</span></span></p></div><div id="https://www.notion.so/b16131fabc5d4137b6c8565a4aa73110" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">每个线程类似一个独立进程，不同的是线程之间共享地址空间，能够访问到相同的数据。线程之间共享进程的内存空间(包括代码段、数据段、堆等)以及以下进程级的资源（如打开文件和信号）。</span></span></p></div><div id="https://www.notion.so/506c2e8531f64ea79ce742b30229429c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">一个经典的进程和线程的关系如下图所示：</span></span></p></div><div id="https://www.notion.so/16604be91584407f98c08c5fd5751b14" class="Image Image--Normal"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F05fccb86-efa6-4487-9e8e-40d5f60136e4%2F3.png?width=672&amp;table=block&amp;id=16604be9-1584-407f-98c0-8c5fd5751b14"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F05fccb86-efa6-4487-9e8e-40d5f60136e4%2F3.png?width=672&amp;table=block&amp;id=16604be9-1584-407f-98c0-8c5fd5751b14" style="width:672px"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><h3 id="https://www.notion.so/85567b132bd84050a0dc03553b6365ba" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/85567b132bd84050a0dc03553b6365ba"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">线程上下文切换</span></span></h3><div id="https://www.notion.so/4721d6b625e74ed289892275ca522a59" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">假设有2个线程运行在一个处理器上，从运行一个线程(T1)切换到另一个线程(T2)时，一定会发生上下文切换。对于进程，我们需要将状态保存到进程控制块(PCB)中，现在我们需要一个或多个线程控制块(TCB)来保存每个线程的状态，但是和进程上下文切换相比，线程在进行上下文切换的时候</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">地址空间保持不变</strong></span><span class="SemanticString">(即不需要切换当前使用的页表)。一个拥有多线程的进程的地址空间，如下图所示，我们可以看到每个线程拥有有自己的栈。</span></span></p></div><div id="https://www.notion.so/d5644058832440cb82706a4a89600eee" class="Image Image--Normal"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Ff863127c-96fc-445d-ac83-568f72463325%2F4.png?width=476&amp;table=block&amp;id=d5644058-8324-40cb-8270-6a4a89600eee"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Ff863127c-96fc-445d-ac83-568f72463325%2F4.png?width=476&amp;table=block&amp;id=d5644058-8324-40cb-8270-6a4a89600eee" style="width:476px"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><h3 id="https://www.notion.so/e8b293fae4d7457f93e0dbc6571b8c8f" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/e8b293fae4d7457f93e0dbc6571b8c8f"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">实现协程的理论依据</span></span></h3><div id="https://www.notion.so/34183985ae684a5291f2d3abfc02531c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">有栈协程就是实现了一个用户态的线程，用户可以在堆上模拟出协程的栈空间，当需要进行协程上下文切换的时候，主线程只需要交换栈空间和恢复协程的一些相关的寄存器的状态就可以实现一个用户态的线程上下文切换，没有了从用户态转换到内核态的切换成本，协程的执行也就更加高效。</span></span></p></div><h2 id="https://www.notion.so/aec6fa3ab1c54d4599272a7e87a128ba" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/aec6fa3ab1c54d4599272a7e87a128ba"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">ucontext</span></span></h2><div id="https://www.notion.so/58b4e03823c446e79b370d48eeed4b5c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">我们参考的协程实现是云风大佬编写的coroutine，源码只有不到200行，很适合用来阅读学习。在这个版本的coroutine中，使用ucontext族函数实现。我们先来简单的看一下这个函数族的基本功能。该部分参考自博客</span><span class="SemanticString"><a class="SemanticString__Fragment SemanticString__Fragment--Link" href="https://blog.csdn.net/qq910894904/article/details/41911175">^2</a></span><span class="SemanticString">。</span></span></p></div><div id="https://www.notion.so/4afce38be95f476cb13a9921914499f1" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在类System V环境中,在头文件</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">&lt; ucontext.h &gt;</code></span><span class="SemanticString"> 中定义了两个结构类型，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">mcontext_t</code></span><span class="SemanticString"> 和 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ucontext_t</code></span><span class="SemanticString">和四个函数</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">getcontext()</code></span><span class="SemanticString">,</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">setcontext()</code></span><span class="SemanticString">,</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">makecontext()</code></span><span class="SemanticString">,</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">swapcontext()</code></span><span class="SemanticString">.利用它们可以在一个进程中实现用户级的线程切换。
</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ucontext_t</code></span><span class="SemanticString"> 结构体定义如下:</span></span></p></div><pre id="https://www.notion.so/1360dbb9771c498c81914ffaef5ffe59" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">ucontext</span> <span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">ucontext</span> <span class="token operator">*</span>uc_link<span class="token punctuation">;</span>
  <span class="token class-name">sigset_t</span>         uc_sigmask<span class="token punctuation">;</span>
  <span class="token class-name">stack_t</span>          uc_stack<span class="token punctuation">;</span>
  <span class="token class-name">mcontext_t</span>       uc_mcontext<span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span> <span class="token class-name">ucontext_t</span><span class="token punctuation">;</span></span></span></span></code></pre><div id="https://www.notion.so/6e70ab57951441fc960ef4843dd8c186" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">当当前上下文(如使用 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">makecontext</code></span><span class="SemanticString"> 创建的上下文）运行终止时系统会恢复</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">uc_link</code></span><span class="SemanticString">指向的上下文；</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">uc_sigmask</code></span><span class="SemanticString">为该上下文中的阻塞信号集合；</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">uc_stack</code></span><span class="SemanticString">为该上下文中使用的栈；</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">uc_mcontext</code></span><span class="SemanticString">保存的上下文的特定机器表示，包括调用线程的特定寄存器等。</span></span></p></div><div id="https://www.notion.so/d7e4569d795f4ec3906c9a1ceffff8f4" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">下面讲解四个函数的作用，详细的函数使用方法参考man手册:</span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/ecab5deeeddf41758383ef6b0ea57872" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">初始化ucp结构体，将当前的上下文保存到ucp中</span></span><pre id="https://www.notion.so/f2884a3e26c64b06b4ba4ede9f4c786b" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span><span class="token keyword">int</span> <span class="token function">getcontext</span><span class="token punctuation">(</span><span class="token class-name">ucontext_t</span> <span class="token operator">*</span>ucp<span class="token punctuation">)</span><span class="token punctuation">;</span></span></span></span></code></pre></li><li id="https://www.notion.so/b51a26a42b8c4a66ab2e11ecc9164a57" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">修改用户线程的上下文指向参数ucp，在调用makecontext之前必须调用getcontext初始化一个ucp，并且需要分配一个栈空间给初始化后的ucp，当上下文通过setcontext或者swapcontext激活后，就会紧接着调用第二个参数指向的函数func，参数argc代表 func所需的参数，在调用makecontext之前你需要初始化参数ucp-&gt;uc_link，这个参数表示func()执行之后，用户线程将要切换到ucp-&gt;uc_link所代表的上下文，其实是隐式的调用了setcontext函数。</span></span><pre id="https://www.notion.so/12f0b2e64b484742b5d8b9c501428d1c" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span><span class="token keyword">void</span> <span class="token function">makecontext</span><span class="token punctuation">(</span><span class="token class-name">ucontext_t</span> <span class="token operator">*</span>ucp<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span></span></span></code></pre></li><li id="https://www.notion.so/8f3c8f03c55642baae3ebe5e96e31761" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString">设置当前的上下文为ucp，setcontext的上下文ucp应该通过getcontext或者makecontext取得，如果调用成功则不返回。</span></span><pre id="https://www.notion.so/7ceb772a190e4e61a0d6418f441aa6b3" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span><span class="token keyword">int</span> <span class="token function">setcontext</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">ucontext_t</span> <span class="token operator">*</span>ucp<span class="token punctuation">)</span><span class="token punctuation">;</span></span></span></span></code></pre></li><li id="https://www.notion.so/7b8d8d4c7399444986c79e6ba64ef813" class="NumberedList" value="4"><span class="SemanticStringArray"><span class="SemanticString">保存当前上下文到oucp结构体中，然后激活upc上下文。</span></span><pre id="https://www.notion.so/5866c20009bb4c5c8aa800bfa3d2ba0b" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span><span class="token keyword">int</span> <span class="token function">swapcontext</span><span class="token punctuation">(</span><span class="token class-name">ucontext_t</span> <span class="token operator">*</span>oucp<span class="token punctuation">,</span> <span class="token class-name">ucontext_t</span> <span class="token operator">*</span>ucp<span class="token punctuation">)</span><span class="token punctuation">;</span></span></span></span></code></pre></li></ol><div id="https://www.notion.so/b7902eb851bc4906ac00b6f03072e4b8" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">写个简单的例子来看一下如何使用：</span></span></p></div><pre id="https://www.notion.so/fd8eb254f36a4bcc9c6e9e012cabc58c" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;ucontext.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"this is func"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">coroutine_test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">char</span> stack<span class="token punctuation">[</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">128</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token class-name">ucontext_t</span> child<span class="token punctuation">,</span> main<span class="token punctuation">;</span>
  <span class="token comment">// 获取当前上下文</span>
  <span class="token function">getcontext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 分配栈空间 uc_stack.ss_sp 指向栈顶</span>
  child<span class="token punctuation">.</span>uc_stack<span class="token punctuation">.</span>ss_sp <span class="token operator">=</span> stack<span class="token punctuation">;</span>
  child<span class="token punctuation">.</span>uc_stack<span class="token punctuation">.</span>ss_size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token punctuation">;</span>
  child<span class="token punctuation">.</span>uc_stack<span class="token punctuation">.</span>ss_flags <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token comment">// 指定后继上下文</span>
  child<span class="token punctuation">.</span>uc_link <span class="token operator">=</span> <span class="token operator">&amp;</span>main<span class="token punctuation">;</span>
  <span class="token comment">// child.uc_link = NULL;</span>

  <span class="token function">makecontext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>child<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">)</span>func<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">//切换到child上下文，保存当前上下文到main</span>
  <span class="token function">swapcontext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>main<span class="token punctuation">,</span> <span class="token operator">&amp;</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 如果设置了后继上下文，func函数指向完后会返回此处 如果设置为NULL，就不会执行这一步</span>
  <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"this is coroutine_test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">coroutine_test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></span></span></span></code></pre><div id="https://www.notion.so/786c34d610c0484d81360b3e6400b1d7" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">程序的执行结果为：</span></span></p></div><pre id="https://www.notion.so/211c55072fd54f379090c7e0edb60bcc" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span>this is func
this is coroutine_test</span></span></span></code></pre><h2 id="https://www.notion.so/1badb3bd39bb4d25ade4c1ed12edad42" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/1badb3bd39bb4d25ade4c1ed12edad42"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">coroutine实现</span></span></h2><div id="https://www.notion.so/03c93c468327442a83ae492ee298eb9b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">本文不打算详细讲解coroutine的代码实现，具体的实现细节大家可以参考文章</span><span class="SemanticString"><a class="SemanticString__Fragment SemanticString__Fragment--Link" href="https://zhuanlan.zhihu.com/p/84935949">^3</a></span><span class="SemanticString">,本文的代码注释也来自这篇文章，建议看完本节之后再阅读该文章来了解代码实现细节。通过学习了前几节讲到的基础知识，相信大家能够比较轻松的看懂协程代码的实现。本小节主要从整体的角度来讲解coroutine的实现。</span></span></p></div><h3 id="https://www.notion.so/8cb8158c60b940c3ae59989e41a84319" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/8cb8158c60b940c3ae59989e41a84319"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">coroutine例子</span></span></h3><pre id="https://www.notion.so/32997e8ae62f492abb490d6345c6e1e6" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"coroutine.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">struct</span> <span class="token class-name">args</span> <span class="token punctuation">{</span>
	<span class="token keyword">int</span> n<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">void</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">schedule</span> <span class="token operator">*</span> S<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>ud<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">struct</span> <span class="token class-name">args</span> <span class="token operator">*</span> arg <span class="token operator">=</span> ud<span class="token punctuation">;</span>
	<span class="token keyword">int</span> start <span class="token operator">=</span> arg<span class="token operator">-></span>n<span class="token punctuation">;</span>
	<span class="token keyword">int</span> i<span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"coroutine %d : %d\\n"</span><span class="token punctuation">,</span><span class="token function">coroutine_running</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span> <span class="token punctuation">,</span> start <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// 切出当前协程</span>
		<span class="token function">coroutine_yield</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">schedule</span> <span class="token operator">*</span>S<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">struct</span> <span class="token class-name">args</span> arg1 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">args</span> arg2 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">100</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

	<span class="token comment">// 创建两个协程</span>
	<span class="token keyword">int</span> co1 <span class="token operator">=</span> <span class="token function">coroutine_new</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> foo<span class="token punctuation">,</span> <span class="token operator">&amp;</span>arg1<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> co2 <span class="token operator">=</span> <span class="token function">coroutine_new</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> foo<span class="token punctuation">,</span> <span class="token operator">&amp;</span>arg2<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"main start\\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">coroutine_status</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span>co1<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">coroutine_status</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span>co2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// 使用协程co1</span>
		<span class="token function">coroutine_resume</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span>co1<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// 使用协程co2</span>
		<span class="token function">coroutine_resume</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span>co2<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"main end\\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span>
<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// 创建一个协程调度器</span>
	<span class="token keyword">struct</span> <span class="token class-name">schedule</span> <span class="token operator">*</span> S <span class="token operator">=</span> <span class="token function">coroutine_open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">test</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 关闭协程调度器</span>
	<span class="token function">coroutine_close</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></span></span></span></code></pre><h3 id="https://www.notion.so/860ce9447bdc41079ce49eb1fe04cc8d" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/860ce9447bdc41079ce49eb1fe04cc8d"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">核心对象</span></span></h3><ol class="NumberedListWrapper"><li id="https://www.notion.so/313311e82e7b48a59c0801b63e9cbe52" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">struct schedule* S</code></span><span class="SemanticString"> 协程调度器</span></span><pre id="https://www.notion.so/a9309168c2ef490bae416440374720de" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span><span class="token keyword">struct</span> <span class="token class-name">schedule</span> <span class="token punctuation">{</span>
    <span class="token keyword">char</span> stack<span class="token punctuation">[</span>STACK_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 运行时栈，此栈即是共享栈</span>
    <span class="token class-name">ucontext_t</span> main<span class="token punctuation">;</span> <span class="token comment">// 主协程的上下文</span>
    <span class="token keyword">int</span> nco<span class="token punctuation">;</span>        <span class="token comment">// 当前存活的协程个数</span>
    <span class="token keyword">int</span> cap<span class="token punctuation">;</span>        <span class="token comment">// 协程管理器的当前最大容量，即可以同时支持多少个协程。如果不够了，则进行2倍扩容</span>
    <span class="token keyword">int</span> running<span class="token punctuation">;</span>    <span class="token comment">// 正在运行的协程ID</span>
    <span class="token keyword">struct</span> <span class="token class-name">coroutine</span> <span class="token operator">*</span><span class="token operator">*</span>co<span class="token punctuation">;</span> <span class="token comment">// 一个一维数组，用于存放所有协程。其长度等于cap</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></span></span></code></pre><div id="https://www.notion.so/a13cec39664a42a7849fe34787b828c1" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">调度器中包含协程运行时的共享栈stack，共享栈可以认为所有的协程在运行时用的都是同一块栈，当调用协程的时候，将自己的栈拷贝到共享栈即可。当协程切出时，将栈空间再复制出来。</span></span></p></div><div id="https://www.notion.so/b8d438047bed490cb2565ea12a5602fb" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">还包括主协程上下文，可以认为是协程执行完毕之后回到的上下文。</span></span></p></div><div id="https://www.notion.so/9f993acc66d44c65986286c0e2c2c8d9" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">以及一个一维数组，用来存放调度器包括的所有协程。</span></span></p></div></li><li id="https://www.notion.so/7879a969dce049ed8a2c208c19437175" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">coroutine</code></span><span class="SemanticString">协程</span></span><pre id="https://www.notion.so/598c2edbf7bb4286aef7ec6172b9204e" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span><span class="token keyword">struct</span> <span class="token class-name">coroutine</span> <span class="token punctuation">{</span>
    coroutine_func func<span class="token punctuation">;</span> <span class="token comment">// 协程所用的函数</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>ud<span class="token punctuation">;</span>  <span class="token comment">// 协程参数</span>
    <span class="token class-name">ucontext_t</span> ctx<span class="token punctuation">;</span> <span class="token comment">// 协程上下文</span>
    <span class="token keyword">struct</span> <span class="token class-name">schedule</span> <span class="token operator">*</span> sch<span class="token punctuation">;</span> <span class="token comment">// 该协程所属的调度器</span>
    <span class="token class-name">ptrdiff_t</span> cap<span class="token punctuation">;</span>   <span class="token comment">// 已经分配的内存大小</span>
    <span class="token class-name">ptrdiff_t</span> size<span class="token punctuation">;</span> <span class="token comment">// 当前协程运行时栈，保存起来后的大小</span>
    <span class="token keyword">int</span> status<span class="token punctuation">;</span> <span class="token comment">// 协程当前的状态</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>stack<span class="token punctuation">;</span> <span class="token comment">// 当前协程的保存起来的运行时栈</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></span></span></code></pre><div id="https://www.notion.so/6e9a89364dd949db823780ce5c1a045d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">coroutine</code></span><span class="SemanticString">结构体包括协程需要执行的函数，协程自己的上下文，用于上下文切换，以及stack用来保存运行时栈。</span></span></p></div></li></ol><h3 id="https://www.notion.so/ffad741c58c14cb68f733b4050adfd70" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/ffad741c58c14cb68f733b4050adfd70"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">协程状态</span></span></h3><div id="https://www.notion.so/6958bf0d34614216b3daecaec8b7aa62" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">协程有4个状态，分别是READY、RUNNING、SUSPEND、DEAD这四个状态。状态转换如图所示：</span></span></p></div><div id="https://www.notion.so/f274e696f907485785b01889acab6a7e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">coroutine_new</code></span><span class="SemanticString">函数用来创建一个协程，协程进行状态转移的核心实现位于</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">coroutine_resume</code></span><span class="SemanticString">函数和</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">coroutine_yield</code></span><span class="SemanticString">函数中。</span></span></p></div><div id="https://www.notion.so/d7601527b3ea40b49b246065e45a953a" class="Image Image--Normal"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fd0c9deec-3a63-47c3-8324-1ba7c40f2ee6%2F5.png?width=528&amp;table=block&amp;id=d7601527-b3ea-40b4-9b24-6065e45a953a"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fd0c9deec-3a63-47c3-8324-1ba7c40f2ee6%2F5.png?width=528&amp;table=block&amp;id=d7601527-b3ea-40b4-9b24-6065e45a953a" style="width:528px"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><h3 id="https://www.notion.so/cce74e23347142019bb33a6f3640798d" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/cce74e23347142019bb33a6f3640798d"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">READY -&gt; RUNNING</span></span></h3><div id="https://www.notion.so/aac26174f61b453b800a89c26f48d084" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">我们现看一下从READY状态转移到RUNNING状态进行的操作，和我们上面讲ucontext举的例子一样。首先，我们初始化协程的上下文，将协程的栈空间指向调度器中的共享栈，uc_link参数设定为S-&gt;main，当执行完makecontext指定的函数之后就会返回到调用coroutine_resume函数的地方。</span></span></p></div><pre id="https://www.notion.so/b1d0734b687f42c8b5f6818c808ebf17" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span><span class="token comment">// coroutine_resume</span>
<span class="token keyword">switch</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">case</span> COROUTINE_READY<span class="token operator">:</span>
	    <span class="token comment">//初始化ucontext_t结构体,将当前的上下文放到C->ctx里面</span>
		<span class="token function">getcontext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>C<span class="token operator">-></span>ctx<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// 将当前协程的运行时栈的栈顶设置为S->stack，每个协程都这么设置，这就是所谓的共享栈。（注意，这里是栈顶）</span>
		C<span class="token operator">-></span>ctx<span class="token punctuation">.</span>uc_stack<span class="token punctuation">.</span>ss_sp <span class="token operator">=</span> S<span class="token operator">-></span>stack<span class="token punctuation">;</span>
		C<span class="token operator">-></span>ctx<span class="token punctuation">.</span>uc_stack<span class="token punctuation">.</span>ss_size <span class="token operator">=</span> STACK_SIZE<span class="token punctuation">;</span>
		C<span class="token operator">-></span>ctx<span class="token punctuation">.</span>uc_link <span class="token operator">=</span> <span class="token operator">&amp;</span>S<span class="token operator">-></span>main<span class="token punctuation">;</span> <span class="token comment">// 如果协程执行完，将切换到主协程中执行</span>
		S<span class="token operator">-></span>running <span class="token operator">=</span> id<span class="token punctuation">;</span>
		C<span class="token operator">-></span>status <span class="token operator">=</span> COROUTINE_RUNNING<span class="token punctuation">;</span>

		<span class="token comment">// 设置执行C->ctx函数, 并将S作为参数传进去</span>
		<span class="token class-name">uintptr_t</span> ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uintptr_t</span><span class="token punctuation">)</span>S<span class="token punctuation">;</span>
		<span class="token function">makecontext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>C<span class="token operator">-></span>ctx<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">)</span> mainfunc<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>ptr<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span>ptr<span class="token operator">>></span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">// 将当前的上下文放入S->main中，并将C->ctx的上下文替换到当前上下文</span>
		<span class="token function">swapcontext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token operator">-></span>main<span class="token punctuation">,</span> <span class="token operator">&amp;</span>C<span class="token operator">-></span>ctx<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">break</span><span class="token punctuation">;</span></span></span></span></code></pre><h3 id="https://www.notion.so/3cf237b741d74562a909445c4d3aeb5a" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/3cf237b741d74562a909445c4d3aeb5a"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">RUNNING -&gt; SUSPEND</span></span></h3><div id="https://www.notion.so/cc2a375a1bcf4de7a0618e487e80cc94" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">当执行coroutine_yield函数之后，我们看到程序会首先保存当前协程的运行时栈，然后把协程的状态修改为挂起状态，并切换到主协程中。</span></span></p></div><pre id="https://www.notion.so/d43a0fdffa38408084b5049b079f2d1b" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span><span class="token keyword">void</span>
<span class="token function">coroutine_yield</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">schedule</span> <span class="token operator">*</span> S<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// 取出当前正在运行的协程</span>
	<span class="token keyword">int</span> id <span class="token operator">=</span> S<span class="token operator">-></span>running<span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>id <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">struct</span> <span class="token class-name">coroutine</span> <span class="token operator">*</span> C <span class="token operator">=</span> S<span class="token operator">-></span>co<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>C <span class="token operator">></span> S<span class="token operator">-></span>stack<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 将当前运行的协程的栈内容保存起来</span>
	<span class="token function">_save_stack</span><span class="token punctuation">(</span>C<span class="token punctuation">,</span>S<span class="token operator">-></span>stack <span class="token operator">+</span> STACK_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 将当前栈的状态改为 挂起</span>
	C<span class="token operator">-></span>status <span class="token operator">=</span> COROUTINE_SUSPEND<span class="token punctuation">;</span>
	S<span class="token operator">-></span>running <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>

	<span class="token comment">// 所以这里可以看到，只能从协程切换到主协程中</span>
	<span class="token function">swapcontext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>C<span class="token operator">-></span>ctx <span class="token punctuation">,</span> <span class="token operator">&amp;</span>S<span class="token operator">-></span>main<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></span></span></span></code></pre><h3 id="https://www.notion.so/2aac51fa201044d39f25a12a1a25a1aa" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/2aac51fa201044d39f25a12a1a25a1aa"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">SUSPEND -&gt; RUNNING</span></span></h3><div id="https://www.notion.so/fdaa6ec2c1ae4739859d9a6253ca6d49" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">当从挂起状态恢复为执行状态时，会将协程的运行时栈拷贝到共享栈，并再次切换上下文回到调用coroutine_yield函数的地方。</span></span></p></div><pre id="https://www.notion.so/3cc175c809004b25870cfeb99d357621" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span>	<span class="token keyword">case</span> COROUTINE_SUSPEND<span class="token operator">:</span>
	    <span class="token comment">// 将协程所保存的栈的内容，拷贝到当前运行时栈中</span>
		<span class="token comment">// 其中C->size在yield时有保存</span>
		<span class="token function">memcpy</span><span class="token punctuation">(</span>S<span class="token operator">-></span>stack <span class="token operator">+</span> STACK_SIZE <span class="token operator">-</span> C<span class="token operator">-></span>size<span class="token punctuation">,</span> C<span class="token operator">-></span>stack<span class="token punctuation">,</span> C<span class="token operator">-></span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
		S<span class="token operator">-></span>running <span class="token operator">=</span> id<span class="token punctuation">;</span>
		C<span class="token operator">-></span>status <span class="token operator">=</span> COROUTINE_RUNNING<span class="token punctuation">;</span>
		<span class="token function">swapcontext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token operator">-></span>main<span class="token punctuation">,</span> <span class="token operator">&amp;</span>C<span class="token operator">-></span>ctx<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">break</span><span class="token punctuation">;</span></span></span></span></code></pre><h3 id="https://www.notion.so/62c8a347d32947fbb98de5a6ecc7b574" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/62c8a347d32947fbb98de5a6ecc7b574"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">运行栈保存</span></span></h3><div id="https://www.notion.so/a4e980d73a774494879b20f61d0a6745" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">当执行coroutine_yield函数的时候，会发现该函数会调用</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">_save_stack</code></span><span class="SemanticString">将当前协程的栈保存起来，因为coroutine是基于共享栈的，所以协程的栈内容需要单独保存起来。这里有一个很trick的点，那就是当前协程的运行栈怎么保存起来，也就是如何获取协程的栈空间。</span></span></p></div><div id="https://www.notion.so/f029987608144fc4a89c1bc1afa1d335" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">一开始我们会在初始化调度器的时候设置共享栈的大小，stack指向栈顶，为了降低内存的占用，我们保存协程栈的时候不会直接保存一份和共享栈一样大小的栈空间，这时候我们需要找到该协程的栈顶位置。</span></span></p></div><div id="https://www.notion.so/493baba8ba0344ec8a1dec876370b377" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">下面代码的实现非常巧妙，他声明了一个局部变量dummy，而dummy的地址就是栈顶位置，大家可以参考上面讲的foo函数栈增长部分，相信你一定也能想到。</span></span></p></div><pre id="https://www.notion.so/4208bd3788fb4e13aa43cfbc099a798e" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span><span class="token keyword">static</span> <span class="token keyword">void</span>
<span class="token function">_save_stack</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">coroutine</span> <span class="token operator">*</span>C<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>top<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// 这个dummy很关键，是求取整个栈的关键</span>
	<span class="token comment">// 这个非常经典，涉及到linux的内存分布，栈是从高地址向低地址扩展，因此</span>
	<span class="token comment">// S->stack + STACK_SIZE就是运行时栈的栈底</span>
	<span class="token comment">// dummy，此时在栈中，肯定是位于最底的位置的，即栈顶</span>
	<span class="token comment">// top - &amp;dummy 即整个栈的容量</span>
	<span class="token keyword">char</span> dummy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>top <span class="token operator">-</span> <span class="token operator">&amp;</span>dummy <span class="token operator">&lt;=</span> STACK_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>C<span class="token operator">-></span>cap <span class="token operator">&lt;</span> top <span class="token operator">-</span> <span class="token operator">&amp;</span>dummy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">free</span><span class="token punctuation">(</span>C<span class="token operator">-></span>stack<span class="token punctuation">)</span><span class="token punctuation">;</span>
		C<span class="token operator">-></span>cap <span class="token operator">=</span> top<span class="token operator">-</span><span class="token operator">&amp;</span>dummy<span class="token punctuation">;</span>
		C<span class="token operator">-></span>stack <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>C<span class="token operator">-></span>cap<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	C<span class="token operator">-></span>size <span class="token operator">=</span> top <span class="token operator">-</span> <span class="token operator">&amp;</span>dummy<span class="token punctuation">;</span>
	<span class="token function">memcpy</span><span class="token punctuation">(</span>C<span class="token operator">-></span>stack<span class="token punctuation">,</span> <span class="token operator">&amp;</span>dummy<span class="token punctuation">,</span> C<span class="token operator">-></span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></span></span></span></code></pre><h2 id="https://www.notion.so/a2781ff2b97e4c21ab0a19ea80c7a8d8" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/a2781ff2b97e4c21ab0a19ea80c7a8d8"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">goroutine实现</span></span></h2><div id="https://www.notion.so/f7735bac39254a89ac4172f7e6b7b60a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">golang语言中的goroutine也是一个有栈协程，但是和本文讲到的coroutine还是有很大不同，首先golang有自己的协程调度器，而且golang的协程是抢占式执行的，关于golang的协程要写的东西还是太多了，得再开一篇文章讨论，大家可以阅读下面的文章有个深入的了解。</span></span></p></div><div id="https://www.notion.so/37ecafa9c65f464bb0e1a9a1ab2d6c2d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><a class="SemanticString__Fragment SemanticString__Fragment--Link" href="https://zboya.github.io/post/go_scheduler/#%E6%B7%B1%E5%85%A5golang-runtime%E7%9A%84%E8%B0%83%E5%BA%A6">深入golang-runtime的调度</a></span></span></p></div><h2 id="https://www.notion.so/1bfa850fe5b04654aef93de03787cc0e" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/1bfa850fe5b04654aef93de03787cc0e"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">参考文献</span></span></h2><ol class="NumberedListWrapper"><li id="https://www.notion.so/db80e062e43841058fcdb5a2833a9c24" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString"><a class="SemanticString__Fragment SemanticString__Fragment--Link" href="https://book.douban.com/subject/19973015/">Operating Systems</a></span></span></li><li id="https://www.notion.so/ca60dc1119c6467b84d5f2cb91fd20fd" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString"><a class="SemanticString__Fragment SemanticString__Fragment--Link" href="https://book.douban.com/subject/3652388/">程序员的自我修养</a></span></span></li></ol><div id="https://www.notion.so/fd9ca7a7161d4d4986881ef238819909" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div></div></div></article>
  <footer class="Footer">
  <div>&copy; yangsoon の 自嗨 2019-2021</div>
  <div>&centerdot;</div>
  <div>Powered by <a href="https://github.com/dragonman225/notablog" target="_blank"
      rel="noopener noreferrer">Notablog</a>.
  </div>
</footer>
</body>

</html>